
<!DOCTYPE html>


<html lang="zh-CN" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>22. 似然比过程 &#8212; Python中级数量经济学</title>
    <script src="https://unpkg.com/@popperjs/core@2.9.2/dist/umd/popper.min.js"></script>
    <script src="https://unpkg.com/tippy.js@6.3.1/dist/tippy-bundle.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
    
        <script>
            MathJax = {
            loader: {load: ['[tex]/boldsymbol', '[tex]/textmacros']},
            tex: {
                packages: {'[+]': ['boldsymbol', 'textmacros']},
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                processEscapes: true,
                macros: {
                    "argmax" : "arg\\,max",
                    "argmin" : "arg\\,min",
                    "col"    : "col",
                    "Span"   :  "span",
                    "epsilon": "\\varepsilon",
                    "EE": "\\mathbb{E}",
                    "PP": "\\mathbb{P}",
                    "RR": "\\mathbb{R}",
                    "NN": "\\mathbb{N}",
                    "ZZ": "\\mathbb{Z}",
                    "aA": "\\mathcal{A}",
                    "bB": "\\mathcal{B}",
                    "cC": "\\mathcal{C}",
                    "dD": "\\mathcal{D}",
                    "eE": "\\mathcal{E}",
                    "fF": "\\mathcal{F}",
                    "gG": "\\mathcal{G}",
                    "hH": "\\mathcal{H}",
                }
            },
            svg: {
                fontCache: 'global',
                scale: 0.92,
                displayAlign: "center",
            },
            };
        </script>
    
    
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" href="_static/styles/quantecon-book-theme.css?digest=a459934d9fea1f60268e46d95e2569a33e1f6ec2" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css?v=6644e6bb" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="_static/exercise.css?v=982b99e0" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css?v=b4b7a797" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>


    <script src="_static/documentation_options.js?v=946197a6"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=f281be69"></script>
    <script src="_static/scripts/sphinx-book-theme.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js?v=4a39c7ea"></script>
    <script src="_static/scripts/quantecon-book-theme.js?digest=06ebc90d5139b434c2742937a4ef3b185cb93e2f"></script>
    <script src="_static/scripts/jquery.js?v=5d32c60e"></script>
    <script src="_static/scripts/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="_static/translations.js?v=beaddf03"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js?v=f930bc37"></script>
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-J0SMYR4SG3"></script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-J0SMYR4SG3');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-J0SMYR4SG3');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"tex": {"macros": {"argmax": "arg\\,max", "argmin": "arg\\,min"}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'likelihood_ratio_process';</script>
    <link rel="canonical" href="https://python.quantecon-zh-cn.org/likelihood_ratio_process.html" />
    <link rel="icon" href="_static/lectures-favicon.ico"/>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="23. 异质信念与金融市场" href="likelihood_ratio_process_2.html" />
    <link rel="prev" title="21. 统计散度度量" href="divergence_measures.html" />

<!-- Normal Meta Tags -->
<meta name="author" context="Thomas J. Sargent &amp; John Stachurski" />
<meta name="keywords" content="Python, QuantEcon, Quantitative Economics, Economics, Sloan, Alfred P. Sloan Foundation, Tom J. Sargent, John Stachurski" />
<meta name="description" content=本课程是由托马斯·萨金特（Thomas J. Sargent）和约翰·斯塔胡斯基（John Stachurski）设计和编写的数量经济建模讲座。 />

<!-- Twitter tags -->
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@quantecon" />
<meta name="twitter:title" content="似然比过程"/>
<meta name="twitter:description" content="本课程是由托马斯·萨金特（Thomas J. Sargent）和约翰·斯塔胡斯基（John Stachurski）设计和编写的数量经济建模讲座。">
<meta name="twitter:creator" content="@quantecon">
<meta name="twitter:image" content="https://assets.quantecon.org/img/qe-twitter-logo.png">

<!-- Opengraph tags -->
<meta property="og:title" content="似然比过程" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://python.quantecon-zh-cn.org/likelihood_ratio_process.html" />
<meta property="og:image" content="https://assets.quantecon.org/img/qe-og-logo.png" />
<meta property="og:description" content="本课程是由托马斯·萨金特（Thomas J. Sargent）和约翰·斯塔胡斯基（John Stachurski）设计和编写的数量经济建模讲座。" />
<meta property="og:site_name" content="Python中级数量经济学" />
<meta name="theme-color" content="#ffffff" />

  </head>
<body>

<!-- Override QuantEcon theme colors -->

    <span id="top"></span>

    <div class="qe-wrapper">

        <div class="qe-main">

            <div class="qe-page" id=likelihood_ratio_process>

                <div class="qe-page__toc">

                    <div class="inner">

                        
                        <div class="qe-page__toc-header">
                            On this page
                        </div>


                        <nav id="bd-toc-nav" class="qe-page__toc-nav">
                            <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">22.1. 概述</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">22.2. 似然比过程</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#g">22.3. 当自然永久从密度g中抽取时</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">22.4. 特殊性质</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#f">22.5. 自然永久从密度f中抽样</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">22.6. 似然比检验</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#h">22.6.1. 第三个分布 <span class="math notranslate nohighlight">\(h\)</span></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kl-link">22.6.2. 一个有用的公式</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">22.7. 假设检验和分类</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">22.7.1. 模型选择错误概率</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">22.7.2. 分类</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id13">22.7.3. 误差概率和散度度量</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#lrp-markov">22.8. 马尔可夫链</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#kl">22.8.1. KL散度率</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id15">22.8.2. 模拟</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id16">22.9. 相关讲座</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id18">22.10. 练习</a></li>
</ul>
                            <p class="logo">
                                
                                    
                                    <a href=https://quantecon.org><img src="_static/qe-logo-large.png" class="logo logo-img" alt="logo"></a>
                                    
                                    
                                
                            </p>

                            <p class="powered">Powered by <a href="https://jupyterbook.org/en/stable/">Jupyter Book</a></p>

                        </nav>

                        <div class="qe-page__toc-footer">
                            
                            
                            <p><a href="#top"><strong>Back to top</strong></a></p>
                        </div>

                    </div>

                </div>

                <div class="qe-page__header">

                    <div class="qe-page__header-copy">

                        <p class="qe-page__header-heading"><a href="intro.html">Python中级数量经济学</a></p>

                        <p class="qe-page__header-subheading">似然比过程</p>

                    </div>
                    <!-- length 2, since its a string and empty dict has length 2 - {} -->
                        <p class="qe-page__header-authors" font-size="18">
                            
                                
                                    <a href="http://www.tomsargent.com/" target="_blank"><span>托马斯·萨金特（Thomas J. Sargent）</span></a>
                                
                            
                                
                                    and <a href="https://johnstachurski.net/" target="_blank"><span>约翰·斯塔胡斯基（John Stachurski）</span></a>
                                
                            
                        </p>


                </div> <!-- .page__header -->



                
                <main class="qe-page__content" role="main">
                    
                    <div>
                        
  <section class="tex2jax_ignore mathjax_ignore" id="id1">
<h1><a class="toc-backref" href="#id19" role="doc-backlink"><span class="section-number">22. </span>似然比过程</a><a class="headerlink" href="#id1" title="Link to this heading">#</a></h1>
<nav class="contents" id="id2">
<p class="topic-title">目录</p>
<ul class="simple">
<li><p><a class="reference internal" href="#id1" id="id19">似然比过程</a></p>
<ul>
<li><p><a class="reference internal" href="#id3" id="id20">概述</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id21">似然比过程</a></p></li>
<li><p><a class="reference internal" href="#g" id="id22">当自然永久从密度g中抽取时</a></p></li>
<li><p><a class="reference internal" href="#id6" id="id23">特殊性质</a></p></li>
<li><p><a class="reference internal" href="#f" id="id24">自然永久从密度f中抽样</a></p></li>
<li><p><a class="reference internal" href="#id7" id="id25">似然比检验</a></p></li>
<li><p><a class="reference internal" href="#id10" id="id26">假设检验和分类</a></p></li>
<li><p><a class="reference internal" href="#lrp-markov" id="id27">马尔可夫链</a></p></li>
<li><p><a class="reference internal" href="#id16" id="id28">相关讲座</a></p></li>
<li><p><a class="reference internal" href="#id18" id="id29">练习</a></p></li>
</ul>
</li>
</ul>
</nav>
<p>除了Anaconda中已有的库外，本讲座还需要以下库：</p>
<div class="cell tag_hide-output docutils container">
<div class="cell_input above-output-prompt docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">!</span>pip<span class="w"> </span>install<span class="w"> </span>--upgrade<span class="w"> </span>quantecon
</pre></div>
</div>
</div>
<details class="admonition hide below-input">
<summary aria-label="Toggle hidden content">
<p class="collapsed admonition-title">Show code cell output</p>
<p class="expanded admonition-title">Hide code cell output</p>
</summary>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Requirement already satisfied: quantecon in /home/runner/miniconda3/envs/quantecon/lib/python3.13/site-packages (0.10.1)
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Requirement already satisfied: numba&gt;=0.49.0 in /home/runner/miniconda3/envs/quantecon/lib/python3.13/site-packages (from quantecon) (0.61.0)
Requirement already satisfied: numpy&gt;=1.17.0 in /home/runner/miniconda3/envs/quantecon/lib/python3.13/site-packages (from quantecon) (2.1.3)
Requirement already satisfied: requests in /home/runner/miniconda3/envs/quantecon/lib/python3.13/site-packages (from quantecon) (2.32.3)
Requirement already satisfied: scipy&gt;=1.5.0 in /home/runner/miniconda3/envs/quantecon/lib/python3.13/site-packages (from quantecon) (1.15.3)
Requirement already satisfied: sympy in /home/runner/miniconda3/envs/quantecon/lib/python3.13/site-packages (from quantecon) (1.13.3)
Requirement already satisfied: llvmlite&lt;0.45,&gt;=0.44.0dev0 in /home/runner/miniconda3/envs/quantecon/lib/python3.13/site-packages (from numba&gt;=0.49.0-&gt;quantecon) (0.44.0)
Requirement already satisfied: charset-normalizer&lt;4,&gt;=2 in /home/runner/miniconda3/envs/quantecon/lib/python3.13/site-packages (from requests-&gt;quantecon) (3.3.2)
Requirement already satisfied: idna&lt;4,&gt;=2.5 in /home/runner/miniconda3/envs/quantecon/lib/python3.13/site-packages (from requests-&gt;quantecon) (3.7)
Requirement already satisfied: urllib3&lt;3,&gt;=1.21.1 in /home/runner/miniconda3/envs/quantecon/lib/python3.13/site-packages (from requests-&gt;quantecon) (2.3.0)
Requirement already satisfied: certifi&gt;=2017.4.17 in /home/runner/miniconda3/envs/quantecon/lib/python3.13/site-packages (from requests-&gt;quantecon) (2025.4.26)
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Requirement already satisfied: mpmath&lt;1.4,&gt;=1.1.0 in /home/runner/miniconda3/envs/quantecon/lib/python3.13/site-packages (from sympy-&gt;quantecon) (1.3.0)
</pre></div>
</div>
</div>
</details>
</div>
<section id="id3">
<h2><a class="toc-backref" href="#id20" role="doc-backlink"><span class="section-number">22.1. </span>概述</a><a class="headerlink" href="#id3" title="Link to this heading">#</a></h2>
<p>本讲座介绍似然比过程及其一些用途。</p>
<p>我们将研究与<a class="reference internal" href="exchangeable.html"><span class="doc">可交换性讲座</span></a>中相同的设定。</p>
<p>我们将学习的内容包括：</p>
<ul class="simple">
<li><p>似然比过程如何成为频率派假设检验的关键要素</p></li>
<li><p><strong>接收者操作特征曲线</strong>如何总结频率派假设检验中的虚警概率和检验效能的信息</p></li>
<li><p>统计学家如何将第一类和第二类错误的频率派概率结合起来，形成模型选择或个体分类问题中的错误后验概率</p></li>
<li><p>如何使用Kullback-Leibler散度来量化具有相同支撑的两个概率分布之间的差异</p></li>
<li><p>二战期间美国海军如何设计一个决策规则来对弹药批次进行质量控制，这个话题为<a class="reference internal" href="wald_friedman.html"><span class="doc">这个讲座</span></a>做铺垫</p></li>
<li><p>似然比过程的一个特殊性质</p></li>
</ul>
<p>让我们先导入一些Python工具。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="n">FONTPATH</span> <span class="o">=</span> <span class="s2">&quot;fonts/SourceHanSerifSC-SemiBold.otf&quot;</span>
<span class="n">mpl</span><span class="o">.</span><span class="n">font_manager</span><span class="o">.</span><span class="n">fontManager</span><span class="o">.</span><span class="n">addfont</span><span class="p">(</span><span class="n">FONTPATH</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;font.family&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Source Han Serif SC&#39;</span><span class="p">]</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numba</span><span class="w"> </span><span class="kn">import</span> <span class="n">vectorize</span><span class="p">,</span> <span class="n">jit</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">gamma</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.integrate</span><span class="w"> </span><span class="kn">import</span> <span class="n">quad</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">brentq</span><span class="p">,</span> <span class="n">minimize_scalar</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">beta</span> <span class="k">as</span> <span class="n">beta_dist</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">IPython.display</span><span class="w"> </span><span class="kn">import</span> <span class="n">display</span><span class="p">,</span> <span class="n">Math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">quantecon</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">qe</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">NameError</span><span class="g g-Whitespace">                                 </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">line</span> <span class="mi">3</span>
<span class="g g-Whitespace">      </span><span class="mi">1</span> <span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="g g-Whitespace">      </span><span class="mi">2</span> <span class="n">FONTPATH</span> <span class="o">=</span> <span class="s2">&quot;fonts/SourceHanSerifSC-SemiBold.otf&quot;</span>
<span class="ne">----&gt; </span><span class="mi">3</span> <span class="n">mpl</span><span class="o">.</span><span class="n">font_manager</span><span class="o">.</span><span class="n">fontManager</span><span class="o">.</span><span class="n">addfont</span><span class="p">(</span><span class="n">FONTPATH</span><span class="p">)</span>
<span class="g g-Whitespace">      </span><span class="mi">4</span> <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;font.family&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Source Han Serif SC&#39;</span><span class="p">]</span>
<span class="g g-Whitespace">      </span><span class="mi">6</span> <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="ne">NameError</span>: name &#39;mpl&#39; is not defined
</pre></div>
</div>
</div>
</div>
</section>
<section id="id4">
<h2><a class="toc-backref" href="#id21" role="doc-backlink"><span class="section-number">22.2. </span>似然比过程</a><a class="headerlink" href="#id4" title="Link to this heading">#</a></h2>
<p>一个非负随机变量 <span class="math notranslate nohighlight">\(W\)</span> 具有两个概率密度函数之一，要么是 <span class="math notranslate nohighlight">\(f\)</span>，要么是 <span class="math notranslate nohighlight">\(g\)</span>。</p>
<p>在时间开始之前，自然界一次性地决定是从 <span class="math notranslate nohighlight">\(f\)</span> 还是 <span class="math notranslate nohighlight">\(g\)</span> 中进行一系列独立同分布的抽样。</p>
<p>我们有时用 <span class="math notranslate nohighlight">\(q\)</span> 表示自然界一次性选择的密度，所以 <span class="math notranslate nohighlight">\(q\)</span> 要么是 <span class="math notranslate nohighlight">\(f\)</span> 要么是 <span class="math notranslate nohighlight">\(g\)</span>，且是永久性的。</p>
<p>自然界知道它永久性地从哪个密度中抽样，但我们这些观察者并不知道。</p>
<p>我们知道 <span class="math notranslate nohighlight">\(f\)</span> 和 <span class="math notranslate nohighlight">\(g\)</span> 两个密度，但不知道自然界选择了哪一个。</p>
<p>但我们想要知道。</p>
<p>为此，我们使用观测值。</p>
<p>我们观察到一个序列 <span class="math notranslate nohighlight">\(\{w_t\}_{t=1}^T\)</span>，包含 <span class="math notranslate nohighlight">\(T\)</span> 个独立同分布的抽样，我们知道这些抽样要么来自 <span class="math notranslate nohighlight">\(f\)</span> 要么来自 <span class="math notranslate nohighlight">\(g\)</span>。</p>
<p>我们想要利用这些观测值来推断自然界选择了 <span class="math notranslate nohighlight">\(f\)</span> 还是 <span class="math notranslate nohighlight">\(g\)</span>。</p>
<p><strong>似然比过程</strong>是完成这项任务的有用工具。</p>
<p>首先，我们定义似然比过程的一个关键组成部分，即时间 <span class="math notranslate nohighlight">\(t\)</span> 的似然比，作为随机变量：</p>
<div class="math notranslate nohighlight">
\[
\ell (w_t)=\frac{f\left(w_t\right)}{g\left(w_t\right)},\quad t\geq1.
\]</div>
<p>我们假设 <span class="math notranslate nohighlight">\(f\)</span> 和 <span class="math notranslate nohighlight">\(g\)</span> 在随机变量 <span class="math notranslate nohighlight">\(W\)</span> 的相同可能实现区间上都具有正概率。</p>
<p>这意味着在 <span class="math notranslate nohighlight">\(g\)</span> 密度下，<span class="math notranslate nohighlight">\(\ell (w_t)=\frac{f\left(w_{t}\right)}{g\left(w_{t}\right)}\)</span> 是一个均值为1的非负随机变量。</p>
<p>序列 <span class="math notranslate nohighlight">\(\left\{ w_{t}\right\} _{t=1}^{\infty}\)</span> 的<strong>似然比过程</strong>定义为：</p>
<div class="math notranslate nohighlight">
\[
L\left(w^{t}\right)=\prod_{i=1}^{t} \ell (w_i),
\]</div>
<p>其中 <span class="math notranslate nohighlight">\(w^t=\{ w_1,\dots,w_t\}\)</span> 是直到时间 <span class="math notranslate nohighlight">\(t\)</span> (包括 <span class="math notranslate nohighlight">\(t\)</span>) 的观测历史。</p>
<p>为简便起见，我们有时会写作 <span class="math notranslate nohighlight">\(L_t = L(w^t)\)</span>。</p>
<p>注意似然过程满足以下<em>递归</em>关系</p>
<div class="math notranslate nohighlight">
\[
L(w^t) = \ell (w_t) L (w^{t-1}) .
\]</div>
<p>似然比及其对数是 Neyman 和 Pearson <span id="id5">[<a class="reference internal" href="zreferences.html#id263" title="J. Neyman and E. S Pearson. On the problem of the most efficient tests of statistical hypotheses. Phil. Trans. R. Soc. Lond. A. 231 (694–706), pages 289–337, 1933.">Neyman and Pearson, 1933</a>]</span> 经典频率派推断方法中的关键工具。</p>
<p>为了帮助我们理解其工作原理，以下 Python 代码将 <span class="math notranslate nohighlight">\(f\)</span> 和 <span class="math notranslate nohighlight">\(g\)</span> 定义为两个不同的 Beta 分布，然后通过从两个概率分布之一(例如，从 <span class="math notranslate nohighlight">\(g\)</span> 生成 IID 序列)生成序列 <span class="math notranslate nohighlight">\(w^t\)</span> 来计算和模拟相关的似然比过程。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Parameters for the two Beta distributions</span>
<span class="n">F_a</span><span class="p">,</span> <span class="n">F_b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
<span class="n">G_a</span><span class="p">,</span> <span class="n">G_b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="mf">1.2</span>

<span class="nd">@vectorize</span>
<span class="k">def</span><span class="w"> </span><span class="nf">p</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Beta distribution density function.&quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">gamma</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">gamma</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">r</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span> <span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">b</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">F_a</span><span class="p">,</span> <span class="n">F_b</span><span class="p">))</span>
<span class="n">g</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">G_a</span><span class="p">,</span> <span class="n">G_b</span><span class="p">))</span>

<span class="k">def</span><span class="w"> </span><span class="nf">create_beta_density</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a beta density function with specified parameters.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">jit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>

<span class="k">def</span><span class="w"> </span><span class="nf">likelihood_ratio</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">f_func</span><span class="p">,</span> <span class="n">g_func</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute likelihood ratio for observation(s) w.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">f_func</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">/</span> <span class="n">g_func</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>

<span class="nd">@jit</span>
<span class="k">def</span><span class="w"> </span><span class="nf">simulate_likelihood_ratios</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">f_func</span><span class="p">,</span> <span class="n">g_func</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">500</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate N sets of T observations of the likelihood ratio.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">l_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">T</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">beta</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="n">l_arr</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">f_func</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">/</span> <span class="n">g_func</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">l_arr</span>

<span class="k">def</span><span class="w"> </span><span class="nf">simulate_sequences</span><span class="p">(</span><span class="n">distribution</span><span class="p">,</span> <span class="n">f_func</span><span class="p">,</span> <span class="n">g_func</span><span class="p">,</span> 
        <span class="n">F_params</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">G_params</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">),</span> <span class="n">T</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">500</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate N sequences of T observations from specified distribution.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">F_params</span>
    <span class="k">elif</span> <span class="n">distribution</span> <span class="o">==</span> <span class="s1">&#39;g&#39;</span><span class="p">:</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">G_params</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;distribution must be &#39;f&#39; or &#39;g&#39;&quot;</span><span class="p">)</span>
    
    <span class="n">l_arr</span> <span class="o">=</span> <span class="n">simulate_likelihood_ratios</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">f_func</span><span class="p">,</span> <span class="n">g_func</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">l_seq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">l_arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">l_arr</span><span class="p">,</span> <span class="n">l_seq</span>

<span class="k">def</span><span class="w"> </span><span class="nf">plot_likelihood_paths</span><span class="p">(</span><span class="n">l_seq</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Likelihood ratio paths&quot;</span><span class="p">,</span> 
                        <span class="n">ylim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_paths</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Plot likelihood ratio paths.&quot;&quot;&quot;</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">l_seq</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">n_show</span> <span class="o">=</span> <span class="n">n_paths</span> <span class="ow">or</span> <span class="nb">min</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_show</span><span class="p">):</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="n">l_seq</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">ylim</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="n">ylim</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;$L(w^t)$&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="g">
<span id="nature-likeli"></span><h2><a class="toc-backref" href="#id22" role="doc-backlink"><span class="section-number">22.3. </span>当自然永久从密度g中抽取时</a><a class="headerlink" href="#g" title="Link to this heading">#</a></h2>
<p>我们首先模拟当自然永久从<span class="math notranslate nohighlight">\(g\)</span>中抽取时的似然比过程。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 模拟当自然从g中抽取时的情况</span>
<span class="n">l_arr_g</span><span class="p">,</span> <span class="n">l_seq_g</span> <span class="o">=</span> <span class="n">simulate_sequences</span><span class="p">(</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="p">(</span><span class="n">F_a</span><span class="p">,</span> <span class="n">F_b</span><span class="p">),</span> <span class="p">(</span><span class="n">G_a</span><span class="p">,</span> <span class="n">G_b</span><span class="p">))</span>
<span class="n">plot_likelihood_paths</span><span class="p">(</span><span class="n">l_seq_g</span><span class="p">,</span> 
                     <span class="n">title</span><span class="o">=</span><span class="s2">&quot;当自然从g中抽取时的$L(w^</span><span class="si">{t}</span><span class="s2">)$路径&quot;</span><span class="p">,</span>
                     <span class="n">ylim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<p>显然，随着样本长度 <span class="math notranslate nohighlight">\(T\)</span> 的增长，大部分概率质量
向零靠近</p>
<p>为了更清楚地看到这一点，我们绘制了随时间变化的
路径 <span class="math notranslate nohighlight">\(L\left(w^{t}\right)\)</span> 落在区间
<span class="math notranslate nohighlight">\(\left[0, 0.01\right]\)</span> 内的比例。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">l_arr_g</span><span class="o">.</span><span class="n">shape</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">l_seq_g</span> <span class="o">&lt;=</span> <span class="mf">0.01</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>尽管大部分概率质量明显收敛到接近<span class="math notranslate nohighlight">\(0\)</span>的一个很小区间内，但在概率密度<span class="math notranslate nohighlight">\(g\)</span>下，<span class="math notranslate nohighlight">\(L\left(w^t\right)\)</span>的无条件均值对所有<span class="math notranslate nohighlight">\(t\)</span>恒等于<span class="math notranslate nohighlight">\(1\)</span>。</p>
<p>为了验证这个论断，首先注意到如前所述，对所有<span class="math notranslate nohighlight">\(t\)</span>，无条件均值<span class="math notranslate nohighlight">\(E\left[\ell \left(w_{t}\right)\bigm|q=g\right]\)</span>等于<span class="math notranslate nohighlight">\(1\)</span>：</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
E\left[\ell \left(w_{t}\right)\bigm|q=g\right]  &amp;=\int\frac{f\left(w_{t}\right)}{g\left(w_{t}\right)}g\left(w_{t}\right)dw_{t} \\
    &amp;=\int f\left(w_{t}\right)dw_{t} \\
    &amp;=1,
\end{aligned}
\end{split}\]</div>
<p>这直接推出</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
E\left[L\left(w^{1}\right)\bigm|q=g\right]  &amp;=E\left[\ell \left(w_{1}\right)\bigm|q=g\right]\\
    &amp;=1.\\
\end{aligned}
\end{split}\]</div>
<p>因为<span class="math notranslate nohighlight">\(L(w^t) = \ell(w_t) L(w^{t-1})\)</span>且<span class="math notranslate nohighlight">\(\{w_t\}_{t=1}^t\)</span>是独立同分布序列，我们有</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
E\left[L\left(w^{t}\right)\bigm|q=g\right]  &amp;=E\left[L\left(w^{t-1}\right)\ell \left(w_{t}\right)\bigm|q=g\right] \\
         &amp;=E\left[L\left(w^{t-1}\right)E\left[\ell \left(w_{t}\right)\bigm|q=g,w^{t-1}\right]\bigm|q=g\right] \\
     &amp;=E\left[L\left(w^{t-1}\right)E\left[\ell \left(w_{t}\right)\bigm|q=g\right]\bigm|q=g\right] \\
    &amp;=E\left[L\left(w^{t-1}\right)\bigm|q=g\right] \\
\end{aligned}
\end{split}\]</div>
<p>对任意<span class="math notranslate nohighlight">\(t \geq 1\)</span>成立。</p>
<p>数学归纳法表明对所有<span class="math notranslate nohighlight">\(t \geq 1\)</span>，<span class="math notranslate nohighlight">\(E\left[L\left(w^{t}\right)\bigm|q=g\right]=1\)</span>。</p>
</section>
<section id="id6">
<h2><a class="toc-backref" href="#id23" role="doc-backlink"><span class="section-number">22.4. </span>特殊性质</a><a class="headerlink" href="#id6" title="Link to this heading">#</a></h2>
<p>当似然比过程的大部分概率质量在 <span class="math notranslate nohighlight">\(t \rightarrow + \infty\)</span> 时堆积在 <span class="math notranslate nohighlight">\(0\)</span> 附近时，<span class="math notranslate nohighlight">\(E\left[L\left(w^{t}\right)\bigm|q=g\right]=1\)</span> 怎么可能成立？</p>
<p>答案是，当 <span class="math notranslate nohighlight">\(t \rightarrow + \infty\)</span> 时，<span class="math notranslate nohighlight">\(L_t\)</span> 的分布变得越来越厚尾：足够多的质量向 <span class="math notranslate nohighlight">\(L_t\)</span> 的更大值移动，使得尽管大部分概率质量堆积在 <span class="math notranslate nohighlight">\(0\)</span> 附近，<span class="math notranslate nohighlight">\(L_t\)</span> 的均值仍然保持为1。</p>
<p>为了说明这个特殊性质，我们模拟多条路径，并通过在每个时刻 <span class="math notranslate nohighlight">\(t\)</span> 对这些路径取平均来计算 <span class="math notranslate nohighlight">\(L\left(w^t\right)\)</span> 的无条件均值。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">l_arr_g</span><span class="p">,</span> <span class="n">l_seq_g</span> <span class="o">=</span> <span class="n">simulate_sequences</span><span class="p">(</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> 
                <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="p">(</span><span class="n">F_a</span><span class="p">,</span> <span class="n">F_b</span><span class="p">),</span> <span class="p">(</span><span class="n">G_a</span><span class="p">,</span> <span class="n">G_b</span><span class="p">),</span> <span class="n">N</span><span class="o">=</span><span class="mi">50000</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>使用模拟来验证无条件期望值<span class="math notranslate nohighlight">\(E\left[L\left(w^{t}\right)\right]\)</span>等于1(通过对样本路径取平均)会很有用。</p>
<p>但是在这里使用标准蒙特卡洛模拟方法会消耗太多计算时间,因此我们不会这样做。</p>
<p>原因是对于较大的<span class="math notranslate nohighlight">\(t\)</span>值,<span class="math notranslate nohighlight">\(L\left(w^{t}\right)\)</span>的分布极度偏斜。</p>
<p>因为右尾部的概率密度接近于0,从右尾部采样足够多的点需要太多计算时间。</p>
<p>我们在<a class="reference internal" href="imp_sample.html"><span class="doc">这篇讲座</span></a>中详细解释了这个问题。</p>
<p>在那里我们描述了一种通过从不同的概率分布中采样来计算不同随机变量的均值,从而计算似然比均值的替代方法。</p>
</section>
<section id="f">
<h2><a class="toc-backref" href="#id24" role="doc-backlink"><span class="section-number">22.5. </span>自然永久从密度f中抽样</a><a class="headerlink" href="#f" title="Link to this heading">#</a></h2>
<p>现在假设在时间0之前,自然界永久决定反复从密度f中抽样。</p>
<p>虽然似然比<span class="math notranslate nohighlight">\(\ell \left(w_{t}\right)\)</span>在密度<span class="math notranslate nohighlight">\(g\)</span>下的均值是1,但在密度<span class="math notranslate nohighlight">\(f\)</span>下的均值超过1。</p>
<p>为了说明这一点,我们计算:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}
\begin{aligned}
E\left[\ell \left(w_{t}\right)\bigm|q=f\right]  &amp;=\int\frac{f\left(w_{t}\right)}{g\left(w_{t}\right)}f\left(w_{t}\right)dw_{t} \\
     &amp;=\int\frac{f\left(w_{t}\right)}{g\left(w_{t}\right)}\frac{f\left(w_{t}\right)}{g\left(w_{t}\right)}g\left(w_{t}\right)dw_{t} \\
     &amp;=\int \ell \left(w_{t}\right)^{2}g\left(w_{t}\right)dw_{t} \\\end{split}\\\begin{split}&amp;=E\left[\ell \left(w_{t}\right)^{2}\mid q=g\right] \\
     &amp;=E\left[\ell \left(w_{t}\right)\mid q=g\right]^{2}+Var\left(\ell \left(w_{t}\right)\mid q=g\right) \\
     &amp;&gt;E\left[\ell \left(w_{t}\right)\mid q=g\right]^{2} = 1 \\
       \end{aligned}
\end{split}\end{aligned}\end{align} \]</div>
<p>这反过来意味着似然比过程<span class="math notranslate nohighlight">\(L(w^t)\)</span>的无条件均值将趋向于<span class="math notranslate nohighlight">\(+ \infty\)</span>。</p>
<p>下面的模拟验证了这个结论。</p>
<p>请注意<span class="math notranslate nohighlight">\(y\)</span>轴的刻度。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 模拟当自然从f中抽取时</span>
<span class="n">l_arr_f</span><span class="p">,</span> <span class="n">l_seq_f</span> <span class="o">=</span> <span class="n">simulate_sequences</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> 
                        <span class="p">(</span><span class="n">F_a</span><span class="p">,</span> <span class="n">F_b</span><span class="p">),</span> <span class="p">(</span><span class="n">G_a</span><span class="p">,</span> <span class="n">G_b</span><span class="p">),</span> <span class="n">N</span><span class="o">=</span><span class="mi">50000</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">l_arr_f</span><span class="o">.</span><span class="n">shape</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">l_seq_f</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>我们还绘制了 <span class="math notranslate nohighlight">\(L\left(w^t\right)\)</span> 落入区间 <span class="math notranslate nohighlight">\([10000, \infty)\)</span> 的概率随时间的变化图，观察概率质量向 <span class="math notranslate nohighlight">\(+\infty\)</span> 发散的速度。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">l_seq_f</span> <span class="o">&gt;</span> <span class="mi">10000</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="id7">
<h2><a class="toc-backref" href="#id25" role="doc-backlink"><span class="section-number">22.6. </span>似然比检验</a><a class="headerlink" href="#id7" title="Link to this heading">#</a></h2>
<p>我们现在描述如何运用 Neyman 和 Pearson <span id="id8">[<a class="reference internal" href="zreferences.html#id263" title="J. Neyman and E. S Pearson. On the problem of the most efficient tests of statistical hypotheses. Phil. Trans. R. Soc. Lond. A. 231 (694–706), pages 289–337, 1933.">Neyman and Pearson, 1933</a>]</span> 的方法来检验历史数据 <span class="math notranslate nohighlight">\(w^t\)</span> 是否由密度函数 <span class="math notranslate nohighlight">\(f\)</span> 的独立同分布重复抽样生成。</p>
<p>令 <span class="math notranslate nohighlight">\(q\)</span> 表示数据生成过程，因此 <span class="math notranslate nohighlight">\(q=f \text{ 或 } g\)</span>。</p>
<p>在观察到样本 <span class="math notranslate nohighlight">\(\{W_i\}_{i=1}^t\)</span> 后，我们想通过执行（频率学派的）假设检验来判断自然是从 <span class="math notranslate nohighlight">\(g\)</span> 还是从 <span class="math notranslate nohighlight">\(f\)</span> 中抽样。</p>
<p>我们指定：</p>
<ul class="simple">
<li><p>零假设 <span class="math notranslate nohighlight">\(H_0\)</span>：<span class="math notranslate nohighlight">\(q=f\)</span></p></li>
<li><p>备择假设 <span class="math notranslate nohighlight">\(H_1\)</span>：<span class="math notranslate nohighlight">\(q=g\)</span></p></li>
</ul>
<p>Neyman 和 Pearson 证明了检验这个假设的最佳方法是使用<strong>似然比检验</strong>，形式如下：</p>
<ul class="simple">
<li><p>当 <span class="math notranslate nohighlight">\(L(W^t) &gt; c\)</span> 时接受 <span class="math notranslate nohighlight">\(H_0\)</span></p></li>
<li><p>当 <span class="math notranslate nohighlight">\(L(W^t) &lt; c\)</span> 时拒绝 <span class="math notranslate nohighlight">\(H_0\)</span></p></li>
</ul>
<p>其中 <span class="math notranslate nohighlight">\(c\)</span> 是给定的判别阈值。</p>
<p>设置 <span class="math notranslate nohighlight">\(c=1\)</span> 是一个常见的选择。</p>
<p>我们将在下面讨论其他 <span class="math notranslate nohighlight">\(c\)</span> 值选择的影响。</p>
<p>这个检验是<em>最佳的</em>，因为它是<strong>一致最优检验</strong>。</p>
<p>为了理解这一点，我们需要定义两个重要事件的概率，这些概率可以帮助我们描述与给定阈值 <span class="math notranslate nohighlight">\(c\)</span> 相关的检验。</p>
<p>这两个概率是：</p>
<ul>
<li><p>第一类错误的概率（当 <span class="math notranslate nohighlight">\(H_0\)</span> 为真时拒绝它）：</p>
<div class="math notranslate nohighlight">
\[
  \alpha \equiv  \Pr\left\{ L\left(w^{t}\right)&lt;c\mid q=f\right\}
  \]</div>
</li>
<li><p>第二类错误的概率（当 <span class="math notranslate nohighlight">\(H_0\)</span> 为假时接受它）：</p>
<div class="math notranslate nohighlight">
\[
  \beta \equiv \Pr\left\{ L\left(w^{t}\right)&gt;c\mid q=g\right\}
  \]</div>
</li>
</ul>
<p>这两个概率是以下两个概念的基础：</p>
<ul>
<li><p>虚警概率（=显著性水平=第一类错误概率）：</p>
<div class="math notranslate nohighlight">
\[
  \alpha \equiv  \Pr\left\{ L\left(w^{t}\right)&lt;c\mid q=f\right\}
  \]</div>
</li>
<li><p>检测概率（=检验力=1减去第二类错误概率）：</p>
<div class="math notranslate nohighlight">
\[
  1-\beta \equiv \Pr\left\{ L\left(w^{t}\right)&lt;c\mid q=g\right\}
  \]</div>
</li>
</ul>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Neyman%E2%80%93Pearson_lemma">奈曼-皮尔逊引理</a>指出，在所有可能的检验中，似然比检验在给定虚警概率的情况下能最大化检测概率。</p>
<p>换句话说，在所有可能的检验中，似然比检验在给定<strong>显著性水平</strong>的情况下能最大化<strong>检验力</strong>。</p>
<p>我们希望虚警概率小，检测概率大。</p>
<p>当样本量<span class="math notranslate nohighlight">\(t\)</span>固定时，我们可以通过调整<span class="math notranslate nohighlight">\(c\)</span>来改变这两个概率。</p>
<p>一个令人困扰的”现实”是，当我们改变临界值<span class="math notranslate nohighlight">\(c\)</span>时，这两个概率会朝同一方向变化。</p>
<p>如果不指定第一类和第二类错误的具体损失，我们很难说应该如何权衡这两种错误的概率。</p>
<p>我们知道增加样本量<span class="math notranslate nohighlight">\(t\)</span>可以改善统计推断。</p>
<p>下面我们将绘制一些说明性图表来展示这一点。</p>
<p>我们还将介绍一个用于选择样本量<span class="math notranslate nohighlight">\(t\)</span>的经典频率派方法。</p>
<p>让我们从将阈值<span class="math notranslate nohighlight">\(c\)</span>固定为<span class="math notranslate nohighlight">\(1\)</span>的情况开始。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
</div>
<p>下面我们绘制上面模拟的累积似然比的对数的经验分布，这些分布是由<span class="math notranslate nohighlight">\(f\)</span>或<span class="math notranslate nohighlight">\(g\)</span>生成的。</p>
<p>取对数不会影响概率的计算，因为对数是单调变换。</p>
<p>随着<span class="math notranslate nohighlight">\(t\)</span>的增加，第一类错误和第二类错误的概率都在减小，这是好事。</p>
<p>这是因为当<span class="math notranslate nohighlight">\(g\)</span>是数据生成过程时，log<span class="math notranslate nohighlight">\((L(w^t))\)</span>的大部分概率质量向<span class="math notranslate nohighlight">\(-\infty\)</span>移动，而当数据由<span class="math notranslate nohighlight">\(f\)</span>生成时，log<span class="math notranslate nohighlight">\((L(w^t))\)</span>趋向于<span class="math notranslate nohighlight">\(\infty\)</span>。</p>
<p>log<span class="math notranslate nohighlight">\((L(w^t))\)</span>在<span class="math notranslate nohighlight">\(f\)</span>和<span class="math notranslate nohighlight">\(g\)</span>下的这种不同行为使得最终能够区分<span class="math notranslate nohighlight">\(q=f\)</span>和<span class="math notranslate nohighlight">\(q=g\)</span>成为可能。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">plot_log_histograms</span><span class="p">(</span><span class="n">l_seq_f</span><span class="p">,</span> <span class="n">l_seq_g</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">time_points</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">21</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;绘制对数似然比直方图。&quot;&quot;&quot;</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
    
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">time_points</span><span class="p">):</span>
        <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">i</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span>
        
        <span class="n">axs</span><span class="p">[</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">]</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">)</span>
        
        <span class="n">hist_f</span><span class="p">,</span> <span class="n">x_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">l_seq_f</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]),</span> <span class="mi">200</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">hist_g</span><span class="p">,</span> <span class="n">x_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">l_seq_g</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]),</span> <span class="mi">200</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="n">axs</span><span class="p">[</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_f</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">hist_f</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;f下的分布&quot;</span><span class="p">)</span>
        <span class="n">axs</span><span class="p">[</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_g</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">hist_g</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;g下的分布&quot;</span><span class="p">)</span>
        
        <span class="c1"># 填充错误区域</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">hist</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">([</span><span class="n">x_f</span><span class="p">,</span> <span class="n">x_g</span><span class="p">],</span> <span class="p">[</span><span class="n">hist_f</span><span class="p">,</span> <span class="n">hist_g</span><span class="p">],</span> 
            <span class="p">[</span><span class="s2">&quot;第一类错误&quot;</span><span class="p">,</span> <span class="s2">&quot;第二类错误&quot;</span><span class="p">])):</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">axs</span><span class="p">[</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">]</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:][</span><span class="n">ind</span><span class="p">],</span> <span class="n">hist</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> 
                                    <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        
        <span class="n">axs</span><span class="p">[</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">axs</span><span class="p">[</span><span class="n">nr</span><span class="p">,</span> <span class="n">nc</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;t=</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">plot_log_histograms</span><span class="p">(</span><span class="n">l_seq_f</span><span class="p">,</span> <span class="n">l_seq_g</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>在上述图表中，</p>
<ul class="simple">
<li><p>蓝色区域与第一类错误的概率 <span class="math notranslate nohighlight">\(\alpha\)</span> 相关但不相等，因为
它们是在拒绝域 <span class="math notranslate nohighlight">\(L_t &lt; 1\)</span> 上 <span class="math notranslate nohighlight">\(\log L_t\)</span> 的积分，而不是 <span class="math notranslate nohighlight">\(L_t\)</span> 的积分</p></li>
<li><p>橙色区域与第二类错误的概率 <span class="math notranslate nohighlight">\(\beta\)</span> 相关但不相等，因为
它们是在接受域 <span class="math notranslate nohighlight">\(L_t &gt; 1\)</span> 上 <span class="math notranslate nohighlight">\(\log L_t\)</span> 的积分，而不是 <span class="math notranslate nohighlight">\(L_t\)</span> 的积分</p></li>
</ul>
<p>当我们将 <span class="math notranslate nohighlight">\(c\)</span> 固定在 <span class="math notranslate nohighlight">\(c=1\)</span> 时，下图显示：</p>
<ul class="simple">
<li><p>检测概率随着 <span class="math notranslate nohighlight">\(t\)</span> 的增加单调增加</p></li>
<li><p>虚警概率随着 <span class="math notranslate nohighlight">\(t\)</span> 的增加单调减少</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">compute_error_probabilities</span><span class="p">(</span><span class="n">l_seq_f</span><span class="p">,</span> <span class="n">l_seq_g</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    计算第一类和第二类错误概率。</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">l_seq_f</span><span class="o">.</span><span class="n">shape</span>
    
    <span class="c1"># 第一类错误（虚警）- 在H0为真时拒绝H0</span>
    <span class="n">PFA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">l_seq_f</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">)])</span>
    
    <span class="c1"># 第二类错误 - 在H0为假时接受H0</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">l_seq_g</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">)])</span>
    
    <span class="c1"># 检测概率（检验效能）</span>
    <span class="n">PD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">l_seq_g</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">)])</span>
    
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="n">PFA</span><span class="p">,</span>
        <span class="s1">&#39;beta&#39;</span><span class="p">:</span> <span class="n">beta</span><span class="p">,</span> 
        <span class="s1">&#39;PD&#39;</span><span class="p">:</span> <span class="n">PD</span><span class="p">,</span>
        <span class="s1">&#39;PFA&#39;</span><span class="p">:</span> <span class="n">PFA</span>
    <span class="p">}</span>

<span class="k">def</span><span class="w"> </span><span class="nf">plot_error_probabilities</span><span class="p">(</span><span class="n">error_dict</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">title_suffix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;绘制随时间变化的错误概率。&quot;&quot;&quot;</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="n">error_dict</span><span class="p">[</span><span class="s1">&#39;PD&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;检测概率&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="n">error_dict</span><span class="p">[</span><span class="s1">&#39;PFA&#39;</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;虚警概率&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;概率&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;错误概率 (c=</span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">)</span><span class="si">{</span><span class="n">title_suffix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">error_probs</span> <span class="o">=</span> <span class="n">compute_error_probabilities</span><span class="p">(</span><span class="n">l_seq_f</span><span class="p">,</span> <span class="n">l_seq_g</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
<span class="n">N</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">l_seq_f</span><span class="o">.</span><span class="n">shape</span>
<span class="n">plot_error_probabilities</span><span class="p">(</span><span class="n">error_probs</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>对于给定的样本量 <span class="math notranslate nohighlight">\(t\)</span>，阈值 <span class="math notranslate nohighlight">\(c\)</span> 唯一确定了两种类型错误的概率。</p>
<p>如果在固定 <span class="math notranslate nohighlight">\(t\)</span> 的情况下，我们释放并移动 <span class="math notranslate nohighlight">\(c\)</span>，我们将得到检测概率作为虚警概率的函数。</p>
<p>这就产生了<a class="reference external" href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic">接收者操作特征曲线（ROC曲线）</a>。</p>
<p>下面，我们为不同的样本量 <span class="math notranslate nohighlight">\(t\)</span> 绘制接收者操作特征曲线。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">plot_roc_curves</span><span class="p">(</span><span class="n">l_seq_f</span><span class="p">,</span> <span class="n">l_seq_g</span><span class="p">,</span> <span class="n">t_values</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">13</span><span class="p">],</span> <span class="n">N</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;绘制不同样本量的ROC曲线。&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">l_seq_f</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="n">PFA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">t_values</span><span class="p">:</span>
        <span class="n">percentile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">l_seq_f</span><span class="p">[:,</span> <span class="n">t</span><span class="p">],</span> <span class="n">PFA</span><span class="p">)</span>
        <span class="n">PD</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">l_seq_g</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">percentile</span><span class="p">]</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">PFA</span> <span class="o">/</span> <span class="mi">100</span><span class="p">,</span> <span class="n">PD</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;t=</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;完美检测&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;随机检测&quot;</span><span class="p">)</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">arrow</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.15</span><span class="p">,</span> <span class="n">head_width</span><span class="o">=</span><span class="mf">0.03</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.35</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="s2">&quot;更好&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;虚警概率&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;检测概率&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;ROC曲线&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


<span class="n">plot_roc_curves</span><span class="p">(</span><span class="n">l_seq_f</span><span class="p">,</span> <span class="n">l_seq_g</span><span class="p">,</span> <span class="n">t_values</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>注意到随着 <span class="math notranslate nohighlight">\(t\)</span> 的增加，对于给定的判别阈值 <span class="math notranslate nohighlight">\(c\)</span>，我们可以确保更高的检测概率和更低的虚警概率。</p>
<p>对于给定的样本量 <span class="math notranslate nohighlight">\(t\)</span>，当我们改变 <span class="math notranslate nohighlight">\(c\)</span> 时，<span class="math notranslate nohighlight">\(\alpha\)</span> 和 <span class="math notranslate nohighlight">\(\beta\)</span> 都会发生变化。</p>
<p>当我们增加 <span class="math notranslate nohighlight">\(c\)</span> 时</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\alpha \equiv  \Pr\left\{ L\left(w^{t}\right)&lt;c\mid q=f\right\}\)</span> 增加</p></li>
<li><p><span class="math notranslate nohighlight">\(\beta \equiv \Pr\left\{ L\left(w^{t}\right)&gt;c\mid q=g\right\}\)</span> 减少</p></li>
</ul>
<p>当 <span class="math notranslate nohighlight">\(t \rightarrow + \infty\)</span> 时，我们接近完美检测曲线，该曲线在蓝点处呈直角。</p>
<p>对于给定的样本量 <span class="math notranslate nohighlight">\(t\)</span>，判别阈值 <span class="math notranslate nohighlight">\(c\)</span> 决定了接收者操作特征曲线上的一个点。</p>
<p>测试设计者需要权衡这两种类型错误的概率。</p>
<p>但我们知道如何选择最小样本量来达到给定的概率目标。</p>
<p>通常，频率学派的目标是在虚警概率有上限的情况下实现高检测概率。</p>
<p>下面我们展示一个例子，其中我们将虚警概率固定在 <span class="math notranslate nohighlight">\(0.05\)</span>。</p>
<p>做出决定所需的样本量则由目标检测概率决定，例如 <span class="math notranslate nohighlight">\(0.9\)</span>，如下图所示。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">PFA</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">PD</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>

<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">l_seq_f</span><span class="p">[:,</span> <span class="n">t</span><span class="p">],</span> <span class="n">PFA</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">PD</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">l_seq_g</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="n">PD</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;检测概率&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;虚警概率=</span><span class="si">{</span><span class="n">PFA</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>美国海军显然在第二次世界大战期间使用类似这样的程序来选择质量控制测试的样本大小 <span class="math notranslate nohighlight">\(t\)</span>。</p>
<p>一位被命令执行此类测试的海军上校对此产生了疑虑，他向米尔顿·弗里德曼提出了这些疑虑，我们在<a class="reference internal" href="wald_friedman.html"><span class="doc">这篇讲座</span></a>中对此进行了描述。</p>
<section id="h">
<span id="llr-h"></span><h3><span class="section-number">22.6.1. </span>第三个分布 <span class="math notranslate nohighlight">\(h\)</span><a class="headerlink" href="#h" title="Link to this heading">#</a></h3>
<p>现在让我们考虑一种既不是 <span class="math notranslate nohighlight">\(g\)</span> 也不是 <span class="math notranslate nohighlight">\(f\)</span> 生成数据的情况。</p>
<p>而是由第三个分布 <span class="math notranslate nohighlight">\(h\)</span> 生成。</p>
<p>让我们研究当 <span class="math notranslate nohighlight">\(h\)</span> 支配数据时，累积似然比 <span class="math notranslate nohighlight">\(L\)</span> 的表现。</p>
<p>这里的一个关键工具被称为<strong>库尔贝克-莱布勒散度</strong>，我们在<a class="reference internal" href="divergence_measures.html"><span class="doc">统计散度度量</span></a>中已经研究过。</p>
<p>在我们的应用中，我们想要度量 <span class="math notranslate nohighlight">\(f\)</span> 或 <span class="math notranslate nohighlight">\(g\)</span> 与 <span class="math notranslate nohighlight">\(h\)</span> 的偏离程度。</p>
<p>与我们相关的两个库尔贝克-莱布勒散度是 <span class="math notranslate nohighlight">\(K_f\)</span> 和 <span class="math notranslate nohighlight">\(K_g\)</span>，定义如下：</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
K_{f} = D_{KL}\bigl(h\|f\bigr) = KL(h, f)
          &amp;= E_{h}\left[\log\frac{h(w)}{f(w)}\right] \\
          &amp;= \int \log\left(\frac{h(w)}{f(w)}\right)h(w)dw .
\end{aligned}
\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
K_{g} = D_{KL}\bigl(h\|g\bigr) = KL(h, g)
          &amp;= E_{h}\left[\log\frac{h(w)}{g(w)}\right] \\
          &amp;= \int \log\left(\frac{h(w)}{g(w)}\right)h(w)dw .
\end{aligned}
\end{split}\]</div>
<p>让我们使用<a class="reference internal" href="divergence_measures.html"><span class="doc">统计散度度量</span></a>中的相同代码来计算库尔贝克-莱布勒差异。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">compute_KL</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    计算KL散度 KL(f, g)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">integrand</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">/</span> <span class="n">g</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
    <span class="n">val</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="mf">1e-5</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">val</span>

<span class="k">def</span><span class="w"> </span><span class="nf">compute_KL_h</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    计算相对于参考分布h的KL散度</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Kf</span> <span class="o">=</span> <span class="n">compute_KL</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
    <span class="n">Kg</span> <span class="o">=</span> <span class="n">compute_KL</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Kf</span><span class="p">,</span> <span class="n">Kg</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="kl-link">
<span id="id9"></span><h3><span class="section-number">22.6.2. </span>一个有用的公式<a class="headerlink" href="#kl-link" title="Link to this heading">#</a></h3>
<p>似然比和KL散度之间存在一个数学关系。</p>
<p>当数据由分布<span class="math notranslate nohighlight">\(h\)</span>生成时，期望对数似然比为：</p>
<div class="math notranslate nohighlight" id="equation-eq-kl-likelihood-link">
<span class="eqno">(22.1)<a class="headerlink" href="#equation-eq-kl-likelihood-link" title="Link to this equation">#</a></span>\[
\frac{1}{t} E_{h}\!\bigl[\log L_t\bigr] = K_g - K_f
\]</div>
<p>其中<span class="math notranslate nohighlight">\(L_t=\prod_{j=1}^{t}\frac{f(w_j)}{g(w_j)}\)</span>是似然比过程。</p>
<p>方程<a class="reference internal" href="#equation-eq-kl-likelihood-link">(22.1)</a>告诉我们：</p>
<ul class="simple">
<li><p>当<span class="math notranslate nohighlight">\(K_g &lt; K_f\)</span>（即<span class="math notranslate nohighlight">\(g\)</span>比<span class="math notranslate nohighlight">\(f\)</span>更接近<span class="math notranslate nohighlight">\(h\)</span>）时，期望对数似然比为负，所以<span class="math notranslate nohighlight">\(L\left(w^t\right) \rightarrow 0\)</span>。</p></li>
<li><p>当<span class="math notranslate nohighlight">\(K_g &gt; K_f\)</span>（即<span class="math notranslate nohighlight">\(f\)</span>比<span class="math notranslate nohighlight">\(g\)</span>更接近<span class="math notranslate nohighlight">\(h\)</span>）时，期望对数似然比为正，所以<span class="math notranslate nohighlight">\(L\left(w^t\right) \rightarrow + \infty\)</span>。</p></li>
</ul>
<p>让我们通过模拟来验证这一点。</p>
<p>在模拟中，我们使用Beta分布<span class="math notranslate nohighlight">\(f\)</span>、<span class="math notranslate nohighlight">\(g\)</span>和<span class="math notranslate nohighlight">\(h\)</span>生成多条路径，并计算<span class="math notranslate nohighlight">\(\log(L(w^t))\)</span>的路径。</p>
<p>首先，我们编写一个函数来计算似然比过程</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">compute_likelihood_ratios</span><span class="p">(</span><span class="n">sequences</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;计算似然比和累积乘积。&quot;&quot;&quot;</span>
    <span class="n">l_ratios</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">sequences</span><span class="p">)</span> <span class="o">/</span> <span class="n">g</span><span class="p">(</span><span class="n">sequences</span><span class="p">)</span>
    <span class="n">L_cumulative</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">l_ratios</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">l_ratios</span><span class="p">,</span> <span class="n">L_cumulative</span>
</pre></div>
</div>
</div>
</div>
<p>我们考虑三种情况：(1) <span class="math notranslate nohighlight">\(h\)</span> 更接近 <span class="math notranslate nohighlight">\(f\)</span>，(2) <span class="math notranslate nohighlight">\(f\)</span> 和 <span class="math notranslate nohighlight">\(g\)</span> 与 <span class="math notranslate nohighlight">\(h\)</span> 的距离大致相等，以及 (3) <span class="math notranslate nohighlight">\(h\)</span> 更接近 <span class="math notranslate nohighlight">\(g\)</span>。</p>
<div class="cell tag_hide-input docutils container">
<details class="admonition hide above-input">
<summary aria-label="Toggle hidden content">
<p class="collapsed admonition-title">Show code cell source</p>
<p class="expanded admonition-title">Hide code cell source</p>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define test scenarios</span>
<span class="n">scenarios</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span>
        <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;KL(h,g) &gt; KL(h,f)&quot;</span><span class="p">,</span>
        <span class="s2">&quot;h_params&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">),</span>
        <span class="s2">&quot;expected&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;$L_t \to \infty$&quot;</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;KL(h,g) ≈ KL(h,f)&quot;</span><span class="p">,</span>
        <span class="s2">&quot;h_params&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">1.35</span><span class="p">),</span>
        <span class="s2">&quot;expected&quot;</span><span class="p">:</span> <span class="s2">&quot;$L_t$ fluctuates&quot;</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;KL(h,g) &lt; KL(h,f)&quot;</span><span class="p">,</span> 
        <span class="s2">&quot;h_params&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mf">3.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">),</span>
        <span class="s2">&quot;expected&quot;</span><span class="p">:</span> <span class="sa">r</span><span class="s2">&quot;$L_t \to 0$&quot;</span>
    <span class="p">}</span>
<span class="p">]</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">scenario</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scenarios</span><span class="p">):</span>
    <span class="c1"># Define h</span>
    <span class="n">h</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">scenario</span><span class="p">[</span><span class="s2">&quot;h_params&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> 
                    <span class="n">scenario</span><span class="p">[</span><span class="s2">&quot;h_params&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="c1"># Compute KL divergences</span>
    <span class="n">Kf</span><span class="p">,</span> <span class="n">Kg</span> <span class="o">=</span> <span class="n">compute_KL_h</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
    <span class="n">kl_diff</span> <span class="o">=</span> <span class="n">Kg</span> <span class="o">-</span> <span class="n">Kf</span>
    
    <span class="c1"># Simulate paths</span>
    <span class="n">N_paths</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">150</span>

    <span class="c1"># Generate data from h</span>
    <span class="n">h_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">beta</span><span class="p">(</span><span class="n">scenario</span><span class="p">[</span><span class="s2">&quot;h_params&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> 
                <span class="n">scenario</span><span class="p">[</span><span class="s2">&quot;h_params&quot;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">N_paths</span><span class="p">,</span> <span class="n">T</span><span class="p">))</span>
    <span class="n">l_ratios</span><span class="p">,</span> <span class="n">l_cumulative</span> <span class="o">=</span> <span class="n">compute_likelihood_ratios</span><span class="p">(</span><span class="n">h_data</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
    <span class="n">log_l_cumulative</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">l_cumulative</span><span class="p">)</span>
    
    <span class="c1"># Plot distributions</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
    <span class="n">x_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.999</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_range</span><span class="p">,</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">x_range</span><span class="p">],</span> 
        <span class="s1">&#39;b-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_range</span><span class="p">,</span> <span class="p">[</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">x_range</span><span class="p">],</span> 
        <span class="s1">&#39;r-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_range</span><span class="p">,</span> <span class="p">[</span><span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">x_range</span><span class="p">],</span> 
        <span class="s1">&#39;g--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;h (data)&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;density&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">scenario</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    
    <span class="c1"># Plot log likelihood ratio paths</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">N_paths</span><span class="p">)):</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">log_l_cumulative</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;purple&#39;</span><span class="p">)</span>
    
    <span class="c1"># Plot theoretical expectation</span>
    <span class="n">theory_line</span> <span class="o">=</span> <span class="n">kl_diff</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">theory_line</span><span class="p">,</span> <span class="s1">&#39;k--&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$t \times (K_g - K_f)$&#39;</span><span class="p">)</span>
    
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$log L_t$&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;KL(h,f)=</span><span class="si">{</span><span class="n">Kf</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">, KL(h,g)=</span><span class="si">{</span><span class="n">Kg</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="se">\n</span><span class="si">{</span><span class="n">scenario</span><span class="p">[</span><span class="s2">&quot;expected&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> 
                 <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</details>
</div>
<p>请注意</p>
<ul class="simple">
<li><p>在第一张图中，由于 <span class="math notranslate nohighlight">\(K_g &gt; K_f\)</span>，<span class="math notranslate nohighlight">\(\log L(w^t)\)</span> 发散到 <span class="math notranslate nohighlight">\(\infty\)</span>。</p></li>
<li><p>在第二张图中，虽然仍然有 <span class="math notranslate nohighlight">\(K_g &gt; K_f\)</span>，但差值较小，所以 <span class="math notranslate nohighlight">\(L(w^t)\)</span> 发散到无穷的速度较慢。</p></li>
<li><p>在最后一张图中，由于 <span class="math notranslate nohighlight">\(K_g &lt; K_f\)</span>，<span class="math notranslate nohighlight">\(\log L(w^t)\)</span> 发散到 <span class="math notranslate nohighlight">\(-\infty\)</span>。</p></li>
<li><p>黑色虚线 <span class="math notranslate nohighlight">\(t \left(D_{KL}(h\|g) - D_{KL}(h\|f)\right)\)</span> 与验证 <a class="reference internal" href="#equation-eq-kl-likelihood-link">(22.1)</a> 的路径紧密吻合。</p></li>
</ul>
<p>这些观察结果与理论相符。</p>
<p>在 <a class="reference internal" href="likelihood_ratio_process_2.html"><span class="doc">异质信念与金融市场</span></a> 中，我们将看到这些思想的一个应用。</p>
</section>
</section>
<section id="id10">
<h2><a class="toc-backref" href="#id26" role="doc-backlink"><span class="section-number">22.7. </span>假设检验和分类</a><a class="headerlink" href="#id10" title="Link to this heading">#</a></h2>
<p>本节讨论似然比过程的另一个应用。</p>
<p>我们描述统计学家如何结合第一类和第二类错误的频率主义概率来</p>
<ul class="simple">
<li><p>计算基于样本长度 <span class="math notranslate nohighlight">\(T\)</span> 选择错误模型的预期频率</p></li>
<li><p>计算分类问题中的预期错误率</p></li>
</ul>
<p>我们考虑这样一种情况：自然界用已知的混合参数 <span class="math notranslate nohighlight">\(\pi_{-1} \in (0,1)\)</span> 混合已知密度 <span class="math notranslate nohighlight">\(f\)</span> 和 <span class="math notranslate nohighlight">\(g\)</span> 来生成数据，使得随机变量 <span class="math notranslate nohighlight">\(w\)</span> 从以下密度中抽取</p>
<div class="math notranslate nohighlight">
\[
h (w) = \pi_{-1} f(w) + (1-\pi_{-1}) g(w) 
\]</div>
<p>我们假设统计学家知道密度 <span class="math notranslate nohighlight">\(f\)</span> 和 <span class="math notranslate nohighlight">\(g\)</span> 以及混合参数 <span class="math notranslate nohighlight">\(\pi_{-1}\)</span>。</p>
<p>下面，我们将设定 <span class="math notranslate nohighlight">\(\pi_{-1} = .5\)</span>，尽管使用其他 <span class="math notranslate nohighlight">\(\pi_{-1} \in (0,1)\)</span> 的值进行分析也是可行的。</p>
<p>我们假设 <span class="math notranslate nohighlight">\(f\)</span> 和 <span class="math notranslate nohighlight">\(g\)</span> 在随机变量 <span class="math notranslate nohighlight">\(W\)</span> 的相同可能实现区间上都赋予正概率。</p>
<p>在下面的模拟中，我们指定 <span class="math notranslate nohighlight">\(f\)</span> 是 <span class="math notranslate nohighlight">\(\text{Beta}(1, 1)\)</span> 分布，<span class="math notranslate nohighlight">\(g\)</span> 是 <span class="math notranslate nohighlight">\(\text{Beta}(3, 1.2)\)</span> 分布。</p>
<p>我们考虑两种替代的时序协议。</p>
<ul class="simple">
<li><p>时序协议1用于模型选择问题</p></li>
<li><p>时序协议2用于个体分类问题</p></li>
</ul>
<p><strong>时序协议1：</strong> 自然只在 <span class="math notranslate nohighlight">\(t=-1\)</span> 时刻<strong>一次性</strong>掷硬币，以概率 <span class="math notranslate nohighlight">\(\pi_{-1}\)</span> 从 <span class="math notranslate nohighlight">\(f\)</span> 生成一个 IID 序列 <span class="math notranslate nohighlight">\(\{w_t\}_{t=1}^T\)</span>，以概率 <span class="math notranslate nohighlight">\(1-\pi_{-1}\)</span> 从 <span class="math notranslate nohighlight">\(g\)</span> 生成一个 IID 序列 <span class="math notranslate nohighlight">\(\{w_t\}_{t=1}^T\)</span>。</p>
<p><strong>时序协议2：</strong> 自然<strong>频繁</strong>掷硬币。在每个时刻 <span class="math notranslate nohighlight">\(t \geq 0\)</span>，自然掷一次硬币，以概率 <span class="math notranslate nohighlight">\(\pi_{-1}\)</span> 从 <span class="math notranslate nohighlight">\(f\)</span> 中抽取 <span class="math notranslate nohighlight">\(w_t\)</span>，以概率 <span class="math notranslate nohighlight">\(1-\pi_{-1}\)</span> 从 <span class="math notranslate nohighlight">\(g\)</span> 中抽取 <span class="math notranslate nohighlight">\(w_t\)</span>。</p>
<p>以下是我们用来实现时序协议1和2的Python代码</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">protocol_1</span><span class="p">(</span><span class="n">π_minus_1</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">F_params</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">G_params</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulate Protocol 1: Nature decides once at t=-1 which model to use.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">F_a</span><span class="p">,</span> <span class="n">F_b</span> <span class="o">=</span> <span class="n">F_params</span>
    <span class="n">G_a</span><span class="p">,</span> <span class="n">G_b</span> <span class="o">=</span> <span class="n">G_params</span>
    
    <span class="c1"># Single coin flip for the true model</span>
    <span class="n">true_models_F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">π_minus_1</span>
    <span class="n">sequences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">T</span><span class="p">))</span>
    
    <span class="n">n_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">true_models_F</span><span class="p">)</span>
    <span class="n">n_g</span> <span class="o">=</span> <span class="n">N</span> <span class="o">-</span> <span class="n">n_f</span>
    
    <span class="k">if</span> <span class="n">n_f</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sequences</span><span class="p">[</span><span class="n">true_models_F</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">beta</span><span class="p">(</span><span class="n">F_a</span><span class="p">,</span> <span class="n">F_b</span><span class="p">,</span> <span class="p">(</span><span class="n">n_f</span><span class="p">,</span> <span class="n">T</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">n_g</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sequences</span><span class="p">[</span><span class="o">~</span><span class="n">true_models_F</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">beta</span><span class="p">(</span><span class="n">G_a</span><span class="p">,</span> <span class="n">G_b</span><span class="p">,</span> <span class="p">(</span><span class="n">n_g</span><span class="p">,</span> <span class="n">T</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">sequences</span><span class="p">,</span> <span class="n">true_models_F</span>

<span class="k">def</span><span class="w"> </span><span class="nf">protocol_2</span><span class="p">(</span><span class="n">π_minus_1</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">F_params</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">G_params</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulate Protocol 2: Nature decides at each time step which model to use.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">F_a</span><span class="p">,</span> <span class="n">F_b</span> <span class="o">=</span> <span class="n">F_params</span>
    <span class="n">G_a</span><span class="p">,</span> <span class="n">G_b</span> <span class="o">=</span> <span class="n">G_params</span>
    
    <span class="c1"># Coin flips for each time step</span>
    <span class="n">true_models_F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">π_minus_1</span>
    <span class="n">sequences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">T</span><span class="p">))</span>
    
    <span class="n">n_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">true_models_F</span><span class="p">)</span>
    <span class="n">n_g</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="n">T</span> <span class="o">-</span> <span class="n">n_f</span>
    
    <span class="k">if</span> <span class="n">n_f</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sequences</span><span class="p">[</span><span class="n">true_models_F</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">beta</span><span class="p">(</span><span class="n">F_a</span><span class="p">,</span> <span class="n">F_b</span><span class="p">,</span> <span class="n">n_f</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n_g</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">sequences</span><span class="p">[</span><span class="o">~</span><span class="n">true_models_F</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">beta</span><span class="p">(</span><span class="n">G_a</span><span class="p">,</span> <span class="n">G_b</span><span class="p">,</span> <span class="n">n_g</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">sequences</span><span class="p">,</span> <span class="n">true_models_F</span>
</pre></div>
</div>
</div>
</div>
<p><strong>注释：</strong> 在时序协议2下，<span class="math notranslate nohighlight">\(\{w_t\}_{t=1}^T\)</span> 是从 <span class="math notranslate nohighlight">\(h(w)\)</span> 中独立同分布(IID)抽取的序列。在时序协议1下，<span class="math notranslate nohighlight">\(\{w_t\}_{t=1}^T\)</span> 不是独立同分布的。它是<strong>条件独立同分布</strong>的 – 意味着以概率 <span class="math notranslate nohighlight">\(\pi_{-1}\)</span> 它是从 <span class="math notranslate nohighlight">\(f(w)\)</span> 中独立同分布抽取的序列，以概率 <span class="math notranslate nohighlight">\(1-\pi_{-1}\)</span> 它是从 <span class="math notranslate nohighlight">\(g(w)\)</span> 中独立同分布抽取的序列。关于这一点的更多信息，请参见<a class="reference internal" href="exchangeable.html"><span class="doc">这篇关于可交换性的讲座</span></a>。</p>
<p>我们再次部署一个<strong>似然比过程</strong>，其时间 <span class="math notranslate nohighlight">\(t\)</span> 分量是似然比</p>
<div class="math notranslate nohighlight">
\[
\ell (w_t)=\frac{f\left(w_t\right)}{g\left(w_t\right)},\quad t\geq1.
\]</div>
<p>序列 <span class="math notranslate nohighlight">\(\left\{ w_{t}\right\} _{t=1}^{\infty}\)</span> 的<strong>似然比过程</strong>是</p>
<div class="math notranslate nohighlight">
\[
L\left(w^{t}\right)=\prod_{i=1}^{t} \ell (w_i),
\]</div>
<p>为简便起见，我们将写作 <span class="math notranslate nohighlight">\(L_t = L(w^t)\)</span>。</p>
<section id="id11">
<h3><span class="section-number">22.7.1. </span>模型选择错误概率<a class="headerlink" href="#id11" title="Link to this heading">#</a></h3>
<p>我们首先研究假设时序协议1的问题。</p>
<p>考虑一个决策者想要知道是模型 <span class="math notranslate nohighlight">\(f\)</span> 还是模型 <span class="math notranslate nohighlight">\(g\)</span> 支配着长度为 <span class="math notranslate nohighlight">\(T\)</span> 观测值的数据集。</p>
<p>决策者已经观察到序列 <span class="math notranslate nohighlight">\(\{w_t\}_{t=1}^T\)</span>。</p>
<p>基于观察到的序列，似然比检验在 <span class="math notranslate nohighlight">\(L_T \geq 1\)</span> 时选择模型 <span class="math notranslate nohighlight">\(f\)</span>，在 <span class="math notranslate nohighlight">\(L_T &lt; 1\)</span> 时选择模型 <span class="math notranslate nohighlight">\(g\)</span>。</p>
<p>当模型 <span class="math notranslate nohighlight">\(f\)</span> 生成数据时，似然比检验选择错误模型的概率是</p>
<div class="math notranslate nohighlight">
\[ 
p_f = {\rm Prob}\left(L_T &lt; 1\Big| f\right) = \alpha_T .
\]</div>
<p>当模型 <span class="math notranslate nohighlight">\(g\)</span> 生成数据时，似然比检验选择错误模型的概率是</p>
<div class="math notranslate nohighlight">
\[ 
p_g = {\rm Prob}\left(L_T \geq 1 \Big|g \right) = \beta_T.
\]</div>
<p>我们可以通过赋予自然选择模型 <span class="math notranslate nohighlight">\(f\)</span> 的贝叶斯先验概率 <span class="math notranslate nohighlight">\(\pi_{-1} = .5\)</span>，然后对 <span class="math notranslate nohighlight">\(p_f\)</span> 和 <span class="math notranslate nohighlight">\(p_g\)</span> 取平均值来构造似然比选择错误模型的概率，从而得到检测错误的贝叶斯后验概率等于</p>
<div class="math notranslate nohighlight" id="equation-eq-detectionerrorprob">
<span class="eqno">(22.2)<a class="headerlink" href="#equation-eq-detectionerrorprob" title="Link to this equation">#</a></span>\[ 
p(\textrm{wrong decision}) = {1 \over 2} (\alpha_T + \beta_T) .
\]</div>
<p>现在让我们模拟时序协议1并计算错误概率</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">compute_protocol_1_errors</span><span class="p">(</span><span class="n">π_minus_1</span><span class="p">,</span> <span class="n">T_max</span><span class="p">,</span> <span class="n">N_simulations</span><span class="p">,</span> <span class="n">f_func</span><span class="p">,</span> <span class="n">g_func</span><span class="p">,</span> 
                              <span class="n">F_params</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">G_params</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    计算协议1的错误概率。</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sequences</span><span class="p">,</span> <span class="n">true_models</span> <span class="o">=</span> <span class="n">protocol_1</span><span class="p">(</span>
        <span class="n">π_minus_1</span><span class="p">,</span> <span class="n">T_max</span><span class="p">,</span> <span class="n">N_simulations</span><span class="p">,</span> <span class="n">F_params</span><span class="p">,</span> <span class="n">G_params</span><span class="p">)</span>
    <span class="n">l_ratios</span><span class="p">,</span> <span class="n">L_cumulative</span> <span class="o">=</span> <span class="n">compute_likelihood_ratios</span><span class="p">(</span><span class="n">sequences</span><span class="p">,</span> 
                                    <span class="n">f_func</span><span class="p">,</span> <span class="n">g_func</span><span class="p">)</span>
    
    <span class="n">T_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">T_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="n">mask_f</span> <span class="o">=</span> <span class="n">true_models</span>
    <span class="n">mask_g</span> <span class="o">=</span> <span class="o">~</span><span class="n">true_models</span>
    
    <span class="n">L_f</span> <span class="o">=</span> <span class="n">L_cumulative</span><span class="p">[</span><span class="n">mask_f</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">L_g</span> <span class="o">=</span> <span class="n">L_cumulative</span><span class="p">[</span><span class="n">mask_g</span><span class="p">,</span> <span class="p">:]</span>
    
    <span class="n">α_T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">L_f</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">β_T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">L_g</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">error_prob</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">α_T</span> <span class="o">+</span> <span class="n">β_T</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;T_range&#39;</span><span class="p">:</span> <span class="n">T_range</span><span class="p">,</span>
        <span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="n">α_T</span><span class="p">,</span>
        <span class="s1">&#39;beta&#39;</span><span class="p">:</span> <span class="n">β_T</span><span class="p">,</span> 
        <span class="s1">&#39;error_prob&#39;</span><span class="p">:</span> <span class="n">error_prob</span><span class="p">,</span>
        <span class="s1">&#39;L_cumulative&#39;</span><span class="p">:</span> <span class="n">L_cumulative</span><span class="p">,</span>
        <span class="s1">&#39;true_models&#39;</span><span class="p">:</span> <span class="n">true_models</span>
    <span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>以下代码可视化了时序协议1的错误概率</p>
<div class="cell tag_hide-input docutils container">
<details class="admonition hide above-input">
<summary aria-label="Toggle hidden content">
<p class="collapsed admonition-title">Show code cell source</p>
<p class="expanded admonition-title">Hide code cell source</p>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">analyze_protocol_1</span><span class="p">(</span><span class="n">π_minus_1</span><span class="p">,</span> <span class="n">T_max</span><span class="p">,</span> <span class="n">N_simulations</span><span class="p">,</span> <span class="n">f_func</span><span class="p">,</span> <span class="n">g_func</span><span class="p">,</span> 
                      <span class="n">F_params</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">G_params</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;分析协议1&quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">compute_protocol_1_errors</span><span class="p">(</span><span class="n">π_minus_1</span><span class="p">,</span> <span class="n">T_max</span><span class="p">,</span> <span class="n">N_simulations</span><span class="p">,</span> 
                                      <span class="n">f_func</span><span class="p">,</span> <span class="n">g_func</span><span class="p">,</span> <span class="n">F_params</span><span class="p">,</span> <span class="n">G_params</span><span class="p">)</span>
    
    <span class="c1"># 绘制结果</span>
    <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
    
    <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;T_range&#39;</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">],</span> <span class="s1">&#39;b-&#39;</span><span class="p">,</span> 
             <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$\alpha_T$&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;T_range&#39;</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;beta&#39;</span><span class="p">],</span> <span class="s1">&#39;r-&#39;</span><span class="p">,</span> 
             <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$\beta_T$&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$T$&#39;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;错误概率&#39;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    
    <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;T_range&#39;</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;error_prob&#39;</span><span class="p">],</span> <span class="s1">&#39;g-&#39;</span><span class="p">,</span> 
             <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$\frac</span><span class="si">{1}{2}</span><span class="s1">(\alpha_T+\beta_T)$&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$T$&#39;</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;错误概率&#39;</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    
    <span class="c1"># 打印总结</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;在T=</span><span class="si">{</span><span class="n">T_max</span><span class="si">}</span><span class="s2">时:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;α_</span><span class="si">{</span><span class="n">T_max</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;β_</span><span class="si">{</span><span class="n">T_max</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;beta&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;模型选择错误概率 = </span><span class="si">{</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;error_prob&#39;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">result</span>

<span class="c1"># 分析协议1</span>
<span class="n">π_minus_1</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">T_max</span> <span class="o">=</span> <span class="mi">30</span>
<span class="n">N_simulations</span> <span class="o">=</span> <span class="mi">10_000</span>

<span class="n">result_p1</span> <span class="o">=</span> <span class="n">analyze_protocol_1</span><span class="p">(</span><span class="n">π_minus_1</span><span class="p">,</span> <span class="n">T_max</span><span class="p">,</span> <span class="n">N_simulations</span><span class="p">,</span> 
                                <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="p">(</span><span class="n">F_a</span><span class="p">,</span> <span class="n">F_b</span><span class="p">),</span> <span class="p">(</span><span class="n">G_a</span><span class="p">,</span> <span class="n">G_b</span><span class="p">))</span>
</pre></div>
</div>
</div>
</details>
</div>
<p>注意随着<span class="math notranslate nohighlight">\(T\)</span>的增长，模型选择的错误概率趋近于零。</p>
</section>
<section id="id12">
<h3><span class="section-number">22.7.2. </span>分类<a class="headerlink" href="#id12" title="Link to this heading">#</a></h3>
<p>我们现在考虑一个假设采用时序协议2的问题。</p>
<p>决策者想要将观察序列<span class="math notranslate nohighlight">\(\{w_t\}_{t=1}^T\)</span>的组成部分分类为来自<span class="math notranslate nohighlight">\(f\)</span>或<span class="math notranslate nohighlight">\(g\)</span>。</p>
<p>决策者使用以下分类规则：</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
w_t  &amp; \ {\rm 来自 \ }  f  \ {\rm 如果 \ } l_t &gt; 1 \\
w_t  &amp; \ {\rm 来自 \ } g  \ {\rm 如果 \ } l_t \leq 1 . 
\end{aligned}
\end{split}\]</div>
<p>在这个规则下，预期的错误分类率为</p>
<div class="math notranslate nohighlight" id="equation-eq-classerrorprob">
<span class="eqno">(22.3)<a class="headerlink" href="#equation-eq-classerrorprob" title="Link to this equation">#</a></span>\[
p(\textrm{misclassification}) = {1 \over 2} (\tilde \alpha_t + \tilde \beta_t) 
\]</div>
<p>其中<span class="math notranslate nohighlight">\(\tilde \alpha_t = {\rm Prob}(l_t &lt; 1 \mid f)\)</span>且<span class="math notranslate nohighlight">\(\tilde \beta_t = {\rm Prob}(l_t \geq 1 \mid g)\)</span>。</p>
<p>现在让我们编写一些代码来模拟它</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">compute_protocol_2_errors</span><span class="p">(</span><span class="n">π_minus_1</span><span class="p">,</span> <span class="n">T_max</span><span class="p">,</span> <span class="n">N_simulations</span><span class="p">,</span> <span class="n">f_func</span><span class="p">,</span> <span class="n">g_func</span><span class="p">,</span>
                              <span class="n">F_params</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">G_params</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    计算协议2的错误概率。</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sequences</span><span class="p">,</span> <span class="n">true_models</span> <span class="o">=</span> <span class="n">protocol_2</span><span class="p">(</span><span class="n">π_minus_1</span><span class="p">,</span> 
                        <span class="n">T_max</span><span class="p">,</span> <span class="n">N_simulations</span><span class="p">,</span> <span class="n">F_params</span><span class="p">,</span> <span class="n">G_params</span><span class="p">)</span>
    <span class="n">l_ratios</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">compute_likelihood_ratios</span><span class="p">(</span><span class="n">sequences</span><span class="p">,</span> <span class="n">f_func</span><span class="p">,</span> <span class="n">g_func</span><span class="p">)</span>
    
    <span class="n">T_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">T_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="n">accuracy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">T_max</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T_max</span><span class="p">):</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="p">(</span><span class="n">l_ratios</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">actual</span> <span class="o">=</span> <span class="n">true_models</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span>
        <span class="n">accuracy</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">predictions</span> <span class="o">==</span> <span class="n">actual</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;T_range&#39;</span><span class="p">:</span> <span class="n">T_range</span><span class="p">,</span>
        <span class="s1">&#39;accuracy&#39;</span><span class="p">:</span> <span class="n">accuracy</span><span class="p">,</span>
        <span class="s1">&#39;l_ratios&#39;</span><span class="p">:</span> <span class="n">l_ratios</span><span class="p">,</span>
        <span class="s1">&#39;true_models&#39;</span><span class="p">:</span> <span class="n">true_models</span>
    <span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>由于对于每个 <span class="math notranslate nohighlight">\(t\)</span>，决策边界都是相同的，因此可以通过以下方式计算决策边界</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">root</span> <span class="o">=</span> <span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">w</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">/</span> <span class="n">g</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.999</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>我们可以绘制<span class="math notranslate nohighlight">\(f\)</span>和<span class="math notranslate nohighlight">\(g\)</span>的分布以及决策边界</p>
<div class="cell tag_hide-input docutils container">
<details class="admonition hide above-input">
<summary aria-label="Toggle hidden content">
<p class="collapsed admonition-title">Show code cell source</p>
<p class="expanded admonition-title">Hide code cell source</p>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

<span class="n">w_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="mf">1e-5</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="n">f_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">w_range</span><span class="p">]</span>
<span class="n">g_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">w_range</span><span class="p">]</span>
<span class="n">ratio_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">/</span><span class="n">g</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">w_range</span><span class="p">]</span>

<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">w_range</span><span class="p">,</span> <span class="n">f_values</span><span class="p">,</span> <span class="s1">&#39;b-&#39;</span><span class="p">,</span> 
        <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$f(w) \sim Beta(1,1)$&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">w_range</span><span class="p">,</span> <span class="n">g_values</span><span class="p">,</span> <span class="s1">&#39;r-&#39;</span><span class="p">,</span> 
        <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$g(w) \sim Beta(3,1.2)$&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">type1_prob</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">beta_dist</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">F_a</span><span class="p">,</span> <span class="n">F_b</span><span class="p">)</span>
<span class="n">type2_prob</span> <span class="o">=</span> <span class="n">beta_dist</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">G_a</span><span class="p">,</span> <span class="n">G_b</span><span class="p">)</span>

<span class="n">w_type1</span> <span class="o">=</span> <span class="n">w_range</span><span class="p">[</span><span class="n">w_range</span> <span class="o">&gt;=</span> <span class="n">root</span><span class="p">]</span>
<span class="n">f_type1</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">w_type1</span><span class="p">]</span>
<span class="n">ax</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">w_type1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">f_type1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> 
                <span class="n">label</span><span class="o">=</span><span class="sa">fr</span><span class="s1">&#39;$\tilde \alpha_t = </span><span class="si">{</span><span class="n">type1_prob</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">$&#39;</span><span class="p">)</span>

<span class="n">w_type2</span> <span class="o">=</span> <span class="n">w_range</span><span class="p">[</span><span class="n">w_range</span> <span class="o">&lt;=</span> <span class="n">root</span><span class="p">]</span>
<span class="n">g_type2</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">w_type2</span><span class="p">]</span>
<span class="n">ax</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">w_type2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">g_type2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> 
                <span class="n">label</span><span class="o">=</span><span class="sa">fr</span><span class="s1">&#39;$\tilde \beta_t = </span><span class="si">{</span><span class="n">type2_prob</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">$&#39;</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> 
            <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;决策边界: $w=$</span><span class="si">{</span><span class="n">root</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;概率密度&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</details>
</div>
<p>在绿色垂直线的左侧，<span class="math notranslate nohighlight">\(g &lt; f\)</span>，所以 <span class="math notranslate nohighlight">\(l_t &gt; 1\)</span>；因此，落在绿线左侧的 <span class="math notranslate nohighlight">\(w_t\)</span> 被归类为 <span class="math notranslate nohighlight">\(f\)</span> 类型个体。</p>
<ul class="simple">
<li><p>红色阴影区域等于 <span class="math notranslate nohighlight">\(\beta\)</span> – 将实际为 <span class="math notranslate nohighlight">\(f\)</span> 类型的个体错误分类为 <span class="math notranslate nohighlight">\(g\)</span> 类型的概率。</p></li>
</ul>
<p>在绿色垂直线的右侧，<span class="math notranslate nohighlight">\(g &gt; f\)</span>，所以 <span class="math notranslate nohighlight">\(l_t &lt; 1\)</span>；因此，落在绿线右侧的 <span class="math notranslate nohighlight">\(w_t\)</span> 被归类为 <span class="math notranslate nohighlight">\(g\)</span> 类型个体。</p>
<ul class="simple">
<li><p>蓝色阴影区域等于 <span class="math notranslate nohighlight">\(\alpha\)</span> – 将实际为 <span class="math notranslate nohighlight">\(g\)</span> 类型的个体错误分类为 <span class="math notranslate nohighlight">\(f\)</span> 类型的概率。</p></li>
</ul>
<p>这给了我们计算理论分类错误概率的线索</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 计算理论 tilde α_t 和 tilde β_t</span>
<span class="k">def</span><span class="w"> </span><span class="nf">α_integrand</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;用于计算 tilde α_t = P(l_t &lt; 1 | f) 的积分&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">if</span> <span class="n">f</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">/</span> <span class="n">g</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>

<span class="k">def</span><span class="w"> </span><span class="nf">β_integrand</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;用于计算 tilde β_t = P(l_t &gt;= 1 | g) 的积分&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">g</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">if</span> <span class="n">f</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">/</span> <span class="n">g</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>

<span class="c1"># 计算积分</span>
<span class="n">α_theory</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="n">α_integrand</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">β_theory</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="n">β_integrand</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

<span class="n">theory_error</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">α_theory</span> <span class="o">+</span> <span class="n">β_theory</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;理论 tilde α_t = </span><span class="si">{</span><span class="n">α_theory</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;理论 tilde β_t = </span><span class="si">{</span><span class="n">β_theory</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;理论分类错误概率 = </span><span class="si">{</span><span class="n">theory_error</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>现在我们模拟时序协议2并计算分类错误概率。</p>
<p>在下一个单元格中，我们还将理论分类准确率与实验分类准确率进行比较</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">analyze_protocol_2</span><span class="p">(</span><span class="n">π_minus_1</span><span class="p">,</span> <span class="n">T_max</span><span class="p">,</span> <span class="n">N_simulations</span><span class="p">,</span> <span class="n">f_func</span><span class="p">,</span> <span class="n">g_func</span><span class="p">,</span> 
                      <span class="n">theory_error</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">F_params</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">G_params</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;分析协议2。&quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">compute_protocol_2_errors</span><span class="p">(</span><span class="n">π_minus_1</span><span class="p">,</span> <span class="n">T_max</span><span class="p">,</span> <span class="n">N_simulations</span><span class="p">,</span> 
                                      <span class="n">f_func</span><span class="p">,</span> <span class="n">g_func</span><span class="p">,</span> <span class="n">F_params</span><span class="p">,</span> <span class="n">G_params</span><span class="p">)</span>
    
    <span class="c1"># 绘制结果</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="s1">&#39;T_range&#39;</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;accuracy&#39;</span><span class="p">],</span> 
            <span class="s1">&#39;b-&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;实验准确率&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">theory_error</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">theory_error</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> 
                   <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;理论准确率 = </span><span class="si">{</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">theory_error</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;$t$&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;准确率&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">result</span>

<span class="c1"># 分析协议2</span>
<span class="n">result_p2</span> <span class="o">=</span> <span class="n">analyze_protocol_2</span><span class="p">(</span><span class="n">π_minus_1</span><span class="p">,</span> <span class="n">T_max</span><span class="p">,</span> <span class="n">N_simulations</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> 
                              <span class="n">theory_error</span><span class="p">,</span> <span class="p">(</span><span class="n">F_a</span><span class="p">,</span> <span class="n">F_b</span><span class="p">),</span> <span class="p">(</span><span class="n">G_a</span><span class="p">,</span> <span class="n">G_b</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>让我们观察随着观测数据的不断累积，两种时序协议所做出的决策变化。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">compare_protocols</span><span class="p">(</span><span class="n">result1</span><span class="p">,</span> <span class="n">result2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;比较两种协议的结果。&quot;&quot;&quot;</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">result1</span><span class="p">[</span><span class="s1">&#39;T_range&#39;</span><span class="p">],</span> <span class="n">result1</span><span class="p">[</span><span class="s1">&#39;error_prob&#39;</span><span class="p">],</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> 
            <span class="n">label</span><span class="o">=</span><span class="s1">&#39;协议1（模型选择）&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">result2</span><span class="p">[</span><span class="s1">&#39;T_range&#39;</span><span class="p">],</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">result2</span><span class="p">[</span><span class="s1">&#39;accuracy&#39;</span><span class="p">],</span> 
            <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> 
            <span class="n">label</span><span class="o">=</span><span class="s1">&#39;协议2（分类）&#39;</span><span class="p">)</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;$T$&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;错误概率&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    
<span class="n">compare_protocols</span><span class="p">(</span><span class="n">result_p1</span><span class="p">,</span> <span class="n">result_p2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>从上图可以看出：</p>
<ul class="simple">
<li><p>对于两种时序协议，误差概率都从相同的水平开始，只是受到一些随机性的影响。</p></li>
<li><p>对于时序协议1，随着样本量的增加，误差概率会降低，因为我们只做<strong>一个</strong>决定 – 即选择是<span class="math notranslate nohighlight">\(f\)</span>还是<span class="math notranslate nohighlight">\(g\)</span>支配<strong>所有</strong>个体。更多的数据提供了更好的证据。</p></li>
<li><p>对于时序协议2，误差概率保持不变，因为我们在做<strong>多个</strong>决定 – 对每个观测都要做一个分类决定。</p></li>
</ul>
<p>**注意：**思考一下大数定律是如何应用于计算模型选择问题和分类问题的误差概率的。</p>
</section>
<section id="id13">
<h3><span class="section-number">22.7.3. </span>误差概率和散度度量<a class="headerlink" href="#id13" title="Link to this heading">#</a></h3>
<p>一个合理的猜测是，似然比区分分布<span class="math notranslate nohighlight">\(f\)</span>和<span class="math notranslate nohighlight">\(g\)</span>的能力取决于它们有多”不同”。</p>
<p>我们在<a class="reference internal" href="divergence_measures.html"><span class="doc">统计散度度量</span></a>中已经学习了一些衡量分布之间”差异”的度量。</p>
<p>现在让我们研究两个在模型选择和分类背景下有用的分布之间”差异”的度量。</p>
<p>回顾一下，概率密度<span class="math notranslate nohighlight">\(f\)</span>和<span class="math notranslate nohighlight">\(g\)</span>之间的Chernoff熵定义为：</p>
<div class="math notranslate nohighlight">
\[
C(f,g) = - \log \min_{\phi \in (0,1)} \int f^\phi(x) g^{1-\phi}(x) dx
\]</div>
<p>模型选择误差概率的上界是</p>
<div class="math notranslate nohighlight">
\[
e^{-C(f,g)T} .
\]</div>
<p>让我们用Python代码来数值计算Chernoff熵</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">chernoff_integrand</span><span class="p">(</span><span class="n">ϕ</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    计算Chernoff熵的被积函数</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">integrand</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">**</span><span class="n">ϕ</span> <span class="o">*</span> <span class="n">g</span><span class="p">(</span><span class="n">w</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">ϕ</span><span class="p">)</span>
    
    <span class="n">result</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="mf">1e-5</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span><span class="w"> </span><span class="nf">compute_chernoff_entropy</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    计算Chernoff熵C(f,g)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">objective</span><span class="p">(</span><span class="n">ϕ</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">chernoff_integrand</span><span class="p">(</span><span class="n">ϕ</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
    
    <span class="c1"># 在(0,1)区间内找到最小值</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">minimize_scalar</span><span class="p">(</span><span class="n">objective</span><span class="p">,</span> 
                             <span class="n">bounds</span><span class="o">=</span><span class="p">(</span><span class="mf">1e-5</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="mf">1e-5</span><span class="p">),</span> 
                             <span class="n">method</span><span class="o">=</span><span class="s1">&#39;bounded&#39;</span><span class="p">)</span>
    <span class="n">min_value</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">fun</span>
    <span class="n">ϕ_optimal</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span>
    
    <span class="n">chernoff_entropy</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">min_value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">chernoff_entropy</span><span class="p">,</span> <span class="n">ϕ_optimal</span>
<span class="n">C_fg</span><span class="p">,</span> <span class="n">ϕ_optimal</span> <span class="o">=</span> <span class="n">compute_chernoff_entropy</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Chernoff熵C(f,g) = </span><span class="si">{</span><span class="n">C_fg</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;最优ϕ = </span><span class="si">{</span><span class="n">ϕ_optimal</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>现在让我们来研究 <span class="math notranslate nohighlight">\(e^{-C(f,g)T}\)</span> 作为 <span class="math notranslate nohighlight">\(T\)</span> 的函数时的表现，并将其与模型选择错误概率进行比较</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">T_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">T_max</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">chernoff_bound</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">C_fg</span> <span class="o">*</span> <span class="n">T_range</span><span class="p">)</span>

<span class="c1"># 绘制比较图</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

<span class="n">ax</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">T_range</span><span class="p">,</span> <span class="n">chernoff_bound</span><span class="p">,</span> <span class="s1">&#39;r-&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> 
           <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;$e^</span><span class="se">{{</span><span class="s1">-C(f,g)T</span><span class="se">}}</span><span class="s1">$&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">T_range</span><span class="p">,</span> <span class="n">result_p1</span><span class="p">[</span><span class="s1">&#39;error_prob&#39;</span><span class="p">],</span> <span class="s1">&#39;b-&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> 
           <span class="n">label</span><span class="o">=</span><span class="s1">&#39;模型选择错误概率&#39;</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;错误概率（对数刻度）&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>显然，<span class="math notranslate nohighlight">\(e^{-C(f,g)T}\)</span>是误差率的上界。</p>
<p>在<code class="docutils literal notranslate"><span class="pre">{doc}</span></code>divergence_measures`中，我们还研究了<strong>Jensen-Shannon散度</strong>作为分布之间的对称距离度量。</p>
<p>我们可以使用Jensen-Shannon散度来测量分布<span class="math notranslate nohighlight">\(f\)</span>和<span class="math notranslate nohighlight">\(g\)</span>之间的距离，并计算它与模型选择错误概率的协方差。</p>
<p>我们还可以通过一些Python代码来数值计算Jensen-Shannon散度</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">compute_JS</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    计算Jensen-Shannon散度</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">m</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
    
    <span class="n">js_div</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">compute_KL</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">compute_KL</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">js_div</span>
</pre></div>
</div>
</div>
</div>
<p>现在让我们回到我们的猜想，即在大样本量情况下的错误概率与两个分布之间的Chernoff熵有关。</p>
<p>我们通过计算时序协议1下<span class="math notranslate nohighlight">\(T=50\)</span>时错误概率的对数与散度度量之间的相关性来验证这一点。</p>
<p>在下面的模拟中，自然界从<span class="math notranslate nohighlight">\(g\)</span>中抽取<span class="math notranslate nohighlight">\(N/2\)</span>个序列，从<span class="math notranslate nohighlight">\(f\)</span>中抽取<span class="math notranslate nohighlight">\(N/2\)</span>个序列。</p>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>自然界采用这种方式，而不是在每次长度为<span class="math notranslate nohighlight">\(T\)</span>的模拟之前抛一次公平硬币来决定是从<span class="math notranslate nohighlight">\(g\)</span>还是<span class="math notranslate nohighlight">\(f\)</span>中抽取。</p>
</div>
<p>我们使用以下Beta分布对作为<span class="math notranslate nohighlight">\(f\)</span>和<span class="math notranslate nohighlight">\(g\)</span>的测试用例</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">distribution_pairs</span> <span class="o">=</span> <span class="p">[</span>
    <span class="c1"># (f_params, g_params)</span>
    <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)),</span>
    <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)),</span>
    <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">)),</span>
    <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)),</span>
    <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">)),</span>
    <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">)),</span>
    <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">1.05</span><span class="p">)),</span>
    <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">)),</span>
    <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)),</span>
    <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)),</span>
    <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">1.8</span><span class="p">)),</span>
    <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)),</span>
    <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
    <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>现在让我们运行模拟</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 模拟参数</span>
<span class="n">T_large</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">N_sims</span> <span class="o">=</span> <span class="mi">5000</span>
<span class="n">N_half</span> <span class="o">=</span> <span class="n">N_sims</span> <span class="o">//</span> <span class="mi">2</span>

<span class="c1"># 初始化数组</span>
<span class="n">n_pairs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">distribution_pairs</span><span class="p">)</span>
<span class="n">kl_fg_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_pairs</span><span class="p">)</span>
<span class="n">kl_gf_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_pairs</span><span class="p">)</span> 
<span class="n">js_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_pairs</span><span class="p">)</span>
<span class="n">chernoff_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_pairs</span><span class="p">)</span>
<span class="n">error_probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_pairs</span><span class="p">)</span>
<span class="n">pair_names</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">((</span><span class="n">f_a</span><span class="p">,</span> <span class="n">f_b</span><span class="p">),</span> <span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">g_b</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">distribution_pairs</span><span class="p">):</span>
    <span class="c1"># 创建密度函数</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">f_a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">f_b</span><span class="p">:</span> <span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">g_a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="n">g_b</span><span class="p">:</span> <span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>

    <span class="c1"># 计算散度度量</span>
    <span class="n">kl_fg_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_KL</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
    <span class="n">kl_gf_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_KL</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
    <span class="n">js_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_JS</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
    <span class="n">chernoff_vals</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">_</span> <span class="o">=</span> <span class="n">compute_chernoff_entropy</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>

    <span class="c1"># 生成样本</span>
    <span class="n">sequences_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">beta</span><span class="p">(</span><span class="n">f_a</span><span class="p">,</span> <span class="n">f_b</span><span class="p">,</span> <span class="p">(</span><span class="n">N_half</span><span class="p">,</span> <span class="n">T_large</span><span class="p">))</span>
    <span class="n">sequences_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">beta</span><span class="p">(</span><span class="n">g_a</span><span class="p">,</span> <span class="n">g_b</span><span class="p">,</span> <span class="p">(</span><span class="n">N_half</span><span class="p">,</span> <span class="n">T_large</span><span class="p">))</span>

    <span class="c1"># 计算似然比和累积乘积</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">L_cumulative_f</span> <span class="o">=</span> <span class="n">compute_likelihood_ratios</span><span class="p">(</span><span class="n">sequences_f</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">L_cumulative_g</span> <span class="o">=</span> <span class="n">compute_likelihood_ratios</span><span class="p">(</span><span class="n">sequences_g</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span>
    
    <span class="c1"># 获取最终值</span>
    <span class="n">L_cumulative_f</span> <span class="o">=</span> <span class="n">L_cumulative_f</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">L_cumulative_g</span> <span class="o">=</span> <span class="n">L_cumulative_g</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># 计算错误概率</span>
    <span class="n">error_probs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">L_cumulative_f</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> 
                            <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">L_cumulative_g</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">pair_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Beta(</span><span class="si">{</span><span class="n">f_a</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">f_b</span><span class="si">}</span><span class="s2">) and Beta(</span><span class="si">{</span><span class="n">g_a</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">g_b</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

<span class="n">cor_data</span> <span class="o">=</span>  <span class="p">{</span>
    <span class="s1">&#39;kl_fg&#39;</span><span class="p">:</span> <span class="n">kl_fg_vals</span><span class="p">,</span>
    <span class="s1">&#39;kl_gf&#39;</span><span class="p">:</span> <span class="n">kl_gf_vals</span><span class="p">,</span>
    <span class="s1">&#39;js&#39;</span><span class="p">:</span> <span class="n">js_vals</span><span class="p">,</span> 
    <span class="s1">&#39;chernoff&#39;</span><span class="p">:</span> <span class="n">chernoff_vals</span><span class="p">,</span>
    <span class="s1">&#39;error_prob&#39;</span><span class="p">:</span> <span class="n">error_probs</span><span class="p">,</span>
    <span class="s1">&#39;names&#39;</span><span class="p">:</span> <span class="n">pair_names</span><span class="p">,</span>
    <span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="n">T_large</span><span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<p>现在让我们来可视化这些相关性</p>
<div class="cell tag_hide-input docutils container">
<details class="admonition hide above-input">
<summary aria-label="Toggle hidden content">
<p class="collapsed admonition-title">Show code cell source</p>
<p class="expanded admonition-title">Hide code cell source</p>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">plot_error_divergence</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    绘制误差概率和散度测量之间的相关性。</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 过滤掉接近零的误差概率以适应对数刻度</span>
    <span class="n">nonzero_mask</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;error_prob&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">1e-6</span>
    <span class="n">log_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;error_prob&#39;</span><span class="p">][</span><span class="n">nonzero_mask</span><span class="p">])</span>
    <span class="n">js_vals</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;js&#39;</span><span class="p">][</span><span class="n">nonzero_mask</span><span class="p">]</span>
    <span class="n">chernoff_vals</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;chernoff&#39;</span><span class="p">][</span><span class="n">nonzero_mask</span><span class="p">]</span>

    <span class="c1"># 创建图形和坐标轴</span>
    <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
    
    <span class="c1"># 绘制相关性的函数</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot_correlation</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">x_vals</span><span class="p">,</span> <span class="n">x_label</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x_vals</span><span class="p">,</span> <span class="n">log_error</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">x_label</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;T=</span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">时的对数误差概率&#39;</span><span class="p">)</span>
        
        <span class="c1"># 计算相关性和趋势线</span>
        <span class="n">corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">x_vals</span><span class="p">,</span> <span class="n">log_error</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x_vals</span><span class="p">,</span> <span class="n">log_error</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">x_trend</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x_vals</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">x_vals</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="mi">100</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_trend</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">z</span><span class="p">)(</span><span class="n">x_trend</span><span class="p">),</span> 
                <span class="s2">&quot;r--&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;对数误差概率与</span><span class="si">{</span><span class="n">x_label</span><span class="si">}</span><span class="s1">的关系</span><span class="se">\n</span><span class="s1">&#39;</span>
                     <span class="sa">f</span><span class="s1">&#39;相关性 = </span><span class="si">{</span><span class="n">corr</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    
    <span class="c1"># 绘制两个相关性图</span>
    <span class="n">plot_correlation</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">js_vals</span><span class="p">,</span> <span class="s1">&#39;JS散度&#39;</span><span class="p">,</span> <span class="s1">&#39;C0&#39;</span><span class="p">)</span>
    <span class="n">plot_correlation</span><span class="p">(</span><span class="n">ax2</span><span class="p">,</span> <span class="n">chernoff_vals</span><span class="p">,</span> <span class="s1">&#39;Chernoff熵&#39;</span><span class="p">,</span> <span class="s1">&#39;C1&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">plot_error_divergence</span><span class="p">(</span><span class="n">cor_data</span><span class="p">)</span>
</pre></div>
</div>
</div>
</details>
</div>
<p>显然，Chernoff熵和Jensen-Shannon熵都与模型选择错误概率密切相关。</p>
<p>我们很快将在<a class="reference internal" href="wald_friedman.html"><span class="doc">让弥尔顿·弗里德曼困惑的问题</span></a>中遇到相关概念。</p>
</section>
</section>
<section id="lrp-markov">
<span id="id14"></span><h2><a class="toc-backref" href="#id27" role="doc-backlink"><span class="section-number">22.8. </span>马尔可夫链</a><a class="headerlink" href="#lrp-markov" title="Link to this heading">#</a></h2>
<p>现在让我们来看看一个非独立同分布随机变量序列的似然比过程。</p>
<p>这里我们假设该序列是由有限状态空间上的马尔可夫链生成的。</p>
<p>我们考虑在相同状态空间{1, 2, …, n}上的两个n状态不可约非周期马尔可夫链模型，它们具有正转移矩阵<span class="math notranslate nohighlight">\(P^{(f)}\)</span>、<span class="math notranslate nohighlight">\(P^{(g)}\)</span>和初始分布<span class="math notranslate nohighlight">\(\pi_0^{(f)}\)</span>、<span class="math notranslate nohighlight">\(\pi_0^{(g)}\)</span>。</p>
<p>我们假设自然从链f中采样。</p>
<p>对于样本路径<span class="math notranslate nohighlight">\((x_0, x_1, \ldots, x_T)\)</span>，让<span class="math notranslate nohighlight">\(N_{ij}\)</span>计算从状态i到j的转移次数。</p>
<p>模型<span class="math notranslate nohighlight">\(m \in \{f, g\}\)</span>下的似然过程为</p>
<div class="math notranslate nohighlight">
\[
L_T^{(m)} = \pi_{0,x_0}^{(m)} \prod_{i=1}^n \prod_{j=1}^n \left(P_{ij}^{(m)}\right)^{N_{ij}}
\]</div>
<p>因此，</p>
<div class="math notranslate nohighlight">
\[
\log L_T^{(m)} =\log\pi_{0,x_0}^{(m)} +\sum_{i,j}N_{ij}\log P_{ij}^{(m)}
\]</div>
<p>对数似然比为</p>
<div class="math notranslate nohighlight" id="equation-eq-llr-markov">
<span class="eqno">(22.4)<a class="headerlink" href="#equation-eq-llr-markov" title="Link to this equation">#</a></span>\[
\log \frac{L_T^{(f)}}{L_T^{(g)}} = \log \frac{\pi_{0,x_0}^{(f)}}{\pi_{0,x_0}^{(g)}} + \sum_{i,j}N_{ij}\log \frac{P_{ij}^{(f)}}{P_{ij}^{(g)}}
\]</div>
<section id="kl">
<h3><span class="section-number">22.8.1. </span>KL散度率<a class="headerlink" href="#kl" title="Link to this heading">#</a></h3>
<p>根据不可约非周期马尔可夫链的遍历定理，我们有</p>
<div class="math notranslate nohighlight">
\[
\frac{N_{ij}}{T} \xrightarrow{a.s.} \pi_i^{(f)}P_{ij}^{(f)} \quad \text{当 } T \to \infty
\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\boldsymbol{\pi}^{(f)}\)</span> 是满足 <span class="math notranslate nohighlight">\(\boldsymbol{\pi}^{(f)} = \boldsymbol{\pi}^{(f)} P^{(f)}\)</span> 的平稳分布。</p>
<p>因此，</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{T}\log \frac{L_T^{(f)}}{L_T^{(g)}} = \frac{1}{T}\log \frac{\pi_{0,x_0}^{(f)}}{\pi_{0,x_0}^{(g)}} + \frac{1}{T}\sum_{i,j}N_{ij}\log \frac{P_{ij}^{(f)}}{P_{ij}^{(g)}}
\]</div>
<p>当 <span class="math notranslate nohighlight">\(T \to \infty\)</span> 时，我们有：</p>
<ul class="simple">
<li><p>第一项：<span class="math notranslate nohighlight">\(\frac{1}{T}\log \frac{\pi_{0,x_0}^{(f)}}{\pi_{0,x_0}^{(g)}} \to 0\)</span></p></li>
<li><p>第二项：<span class="math notranslate nohighlight">\(\frac{1}{T}\sum_{i,j}N_{ij}\log \frac{P_{ij}^{(f)}}{P_{ij}^{(g)}} \xrightarrow{a.s.} \sum_{i,j}\pi_i^{(f)}P_{ij}^{(f)}\log \frac{P_{ij}^{(f)}}{P_{ij}^{(g)}}\)</span></p></li>
</ul>
<p>定义<strong>KL散度率</strong>为</p>
<div class="math notranslate nohighlight">
\[
h_{KL}(f, g) = \sum_{i=1}^n \pi_i^{(f)} \underbrace{\sum_{j=1}^n P_{ij}^{(f)} \log \frac{P_{ij}^{(f)}}{P_{ij}^{(g)}}}_{=: KL(P_{i\cdot}^{(f)}, P_{i\cdot}^{(g)})}
\]</div>
<p>其中 <span class="math notranslate nohighlight">\(KL(P_{i\cdot}^{(f)}, P_{i\cdot}^{(g)})\)</span> 是按行计算的KL散度。</p>
<p>根据遍历定理，我们有</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{T}\log \frac{L_T^{(f)}}{L_T^{(g)}} \xrightarrow{a.s.} h_{KL}(f, g) \quad \text{当 } T \to \infty
\]</div>
<p>取期望并使用控制收敛定理，我们得到</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{T}E_f\left[\log \frac{L_T^{(f)}}{L_T^{(g)}}\right] \to h_{KL}(f, g) \quad \text{当 } T \to \infty
\]</div>
<p>在这里我们邀请读者停下来比较这个结果与<a class="reference internal" href="#equation-eq-kl-likelihood-link">(22.1)</a>。</p>
<p>让我们在下面的模拟中验证这一点。</p>
</section>
<section id="id15">
<h3><span class="section-number">22.8.2. </span>模拟<a class="headerlink" href="#id15" title="Link to this heading">#</a></h3>
<p>让我们通过三状态马尔可夫链的模拟来说明这些概念。</p>
<p>首先编写函数来计算马尔可夫链模型的平稳分布和KL散度率。</p>
<div class="cell tag_hide-input docutils container">
<details class="admonition hide above-input">
<summary aria-label="Toggle hidden content">
<p class="collapsed admonition-title">Show code cell source</p>
<p class="expanded admonition-title">Hide code cell source</p>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">compute_stationary_dist</span><span class="p">(</span><span class="n">P</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    计算转移矩阵P的平稳分布</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">eigenvalues</span><span class="p">,</span> <span class="n">eigenvectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">eigenvalues</span><span class="p">))</span>
    <span class="n">stationary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">eigenvectors</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">stationary</span> <span class="o">/</span> <span class="n">stationary</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

<span class="k">def</span><span class="w"> </span><span class="nf">markov_kl_divergence</span><span class="p">(</span><span class="n">P_f</span><span class="p">,</span> <span class="n">P_g</span><span class="p">,</span> <span class="n">pi_f</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    计算两个马尔可夫链之间的KL散度率</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">((</span><span class="n">P_f</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">P_g</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    
    <span class="n">valid_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">P_f</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">P_g</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">log_ratios</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">P_f</span><span class="p">)</span>
    <span class="n">log_ratios</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">P_f</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">]</span> <span class="o">/</span> <span class="n">P_g</span><span class="p">[</span><span class="n">valid_mask</span><span class="p">])</span>
    
    <span class="c1"># 用平稳概率加权并求和</span>
    <span class="n">kl_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pi_f</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">P_f</span> <span class="o">*</span> <span class="n">log_ratios</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">kl_rate</span>

<span class="k">def</span><span class="w"> </span><span class="nf">simulate_markov_chain</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">pi_0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N_paths</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    模拟马尔可夫链的N_paths条样本路径</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mc</span> <span class="o">=</span> <span class="n">qe</span><span class="o">.</span><span class="n">MarkovChain</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">state_values</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">initial_states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">N_paths</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">pi_0</span><span class="p">)</span>
    <span class="n">paths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N_paths</span><span class="p">,</span> <span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_paths</span><span class="p">):</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">mc</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="n">initial_states</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">paths</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">path</span>
    
    <span class="k">return</span> <span class="n">paths</span>

<span class="k">def</span><span class="w"> </span><span class="nf">compute_likelihood_ratio_markov</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">P_f</span><span class="p">,</span> <span class="n">P_g</span><span class="p">,</span> <span class="n">π_0_f</span><span class="p">,</span> <span class="n">π_0_g</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    计算马尔可夫链路径的似然比过程</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N_paths</span><span class="p">,</span> <span class="n">T_plus_1</span> <span class="o">=</span> <span class="n">paths</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">T_plus_1</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">L_ratios</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">N_paths</span><span class="p">,</span> <span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    
    <span class="c1"># 初始似然比</span>
    <span class="n">L_ratios</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">π_0_f</span><span class="p">[</span><span class="n">paths</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span> <span class="o">/</span> <span class="n">π_0_g</span><span class="p">[</span><span class="n">paths</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span>
    
    <span class="c1"># 计算序列似然比</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">prev_states</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[:,</span> <span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">curr_states</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span>
        
        <span class="n">transition_ratios</span> <span class="o">=</span> <span class="p">(</span><span class="n">P_f</span><span class="p">[</span><span class="n">prev_states</span><span class="p">,</span> <span class="n">curr_states</span><span class="p">]</span> <span class="o">/</span> 
                           <span class="n">P_g</span><span class="p">[</span><span class="n">prev_states</span><span class="p">,</span> <span class="n">curr_states</span><span class="p">])</span>
        <span class="n">L_ratios</span><span class="p">[:,</span> <span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_ratios</span><span class="p">[:,</span> <span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">transition_ratios</span>
    
    <span class="k">return</span> <span class="n">L_ratios</span>

<span class="k">def</span><span class="w"> </span><span class="nf">analyze_markov_chains</span><span class="p">(</span><span class="n">P_f</span><span class="p">,</span> <span class="n">P_g</span><span class="p">,</span> 
                <span class="n">T</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">N_paths</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">plot_paths</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">n_show</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    两个马尔可夫链的完整分析</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 计算平稳分布</span>
    <span class="n">π_f</span> <span class="o">=</span> <span class="n">compute_stationary_dist</span><span class="p">(</span><span class="n">P_f</span><span class="p">)</span>
    <span class="n">π_g</span> <span class="o">=</span> <span class="n">compute_stationary_dist</span><span class="p">(</span><span class="n">P_g</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;平稳分布 (f): </span><span class="si">{</span><span class="n">π_f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;平稳分布 (g): </span><span class="si">{</span><span class="n">π_g</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># 计算KL散度率</span>
    <span class="n">kl_rate_fg</span> <span class="o">=</span> <span class="n">markov_kl_divergence</span><span class="p">(</span><span class="n">P_f</span><span class="p">,</span> <span class="n">P_g</span><span class="p">,</span> <span class="n">π_f</span><span class="p">)</span>
    <span class="n">kl_rate_gf</span> <span class="o">=</span> <span class="n">markov_kl_divergence</span><span class="p">(</span><span class="n">P_g</span><span class="p">,</span> <span class="n">P_f</span><span class="p">,</span> <span class="n">π_g</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">KL散度率 h(f, g): </span><span class="si">{</span><span class="n">kl_rate_fg</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;KL散度率 h(g, f): </span><span class="si">{</span><span class="n">kl_rate_gf</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">plot_paths</span><span class="p">:</span>
        <span class="c1"># 模拟并绘制路径</span>
        <span class="n">paths_from_f</span> <span class="o">=</span> <span class="n">simulate_markov_chain</span><span class="p">(</span><span class="n">P_f</span><span class="p">,</span> <span class="n">π_f</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N_paths</span><span class="p">)</span>
        <span class="n">L_ratios_f</span> <span class="o">=</span> <span class="n">compute_likelihood_ratio_markov</span><span class="p">(</span>
            <span class="n">paths_from_f</span><span class="p">,</span> <span class="n">P_f</span><span class="p">,</span> <span class="n">P_g</span><span class="p">,</span> <span class="n">π_f</span><span class="p">,</span> <span class="n">π_g</span><span class="p">)</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        
        <span class="c1"># 绘制个别路径</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">n_show</span><span class="p">,</span> <span class="n">N_paths</span><span class="p">)):</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">L_ratios_f</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]),</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
        
        <span class="c1"># 绘制理论期望</span>
        <span class="n">theory_line</span> <span class="o">=</span> <span class="n">kl_rate_fg</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">theory_line</span><span class="p">,</span> <span class="s1">&#39;k--&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> 
                <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$T \times h_</span><span class="si">{KL}</span><span class="s1">(f,g)$&#39;</span><span class="p">)</span>
        
        <span class="c1"># 绘制经验平均值</span>
        <span class="n">avg_log_L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">L_ratios_f</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">avg_log_L</span><span class="p">,</span> <span class="s1">&#39;r-&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> 
                <span class="n">label</span><span class="o">=</span><span class="s1">&#39;经验平均值&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
        
        <span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$T$&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;$\log L_T$&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;马尔可夫链似然比(本质 = f)&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;stationary_f&#39;</span><span class="p">:</span> <span class="n">π_f</span><span class="p">,</span>
        <span class="s1">&#39;stationary_g&#39;</span><span class="p">:</span> <span class="n">π_g</span><span class="p">,</span>
        <span class="s1">&#39;kl_rate_fg&#39;</span><span class="p">:</span> <span class="n">kl_rate_fg</span><span class="p">,</span>
        <span class="s1">&#39;kl_rate_gf&#39;</span><span class="p">:</span> <span class="n">kl_rate_gf</span>
    <span class="p">}</span>

<span class="k">def</span><span class="w"> </span><span class="nf">compute_markov_selection_error</span><span class="p">(</span><span class="n">T_values</span><span class="p">,</span> <span class="n">P_f</span><span class="p">,</span> <span class="n">P_g</span><span class="p">,</span> <span class="n">π_0_f</span><span class="p">,</span> <span class="n">π_0_g</span><span class="p">,</span> <span class="n">N_sim</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    计算马尔可夫链的模型选择错误概率</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">T</span> <span class="ow">in</span> <span class="n">T_values</span><span class="p">:</span>
        <span class="c1"># 从两个模型中模拟</span>
        <span class="n">paths_f</span> <span class="o">=</span> <span class="n">simulate_markov_chain</span><span class="p">(</span><span class="n">P_f</span><span class="p">,</span> <span class="n">π_0_f</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N_sim</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">paths_g</span> <span class="o">=</span> <span class="n">simulate_markov_chain</span><span class="p">(</span><span class="n">P_g</span><span class="p">,</span> <span class="n">π_0_g</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N_sim</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="c1"># 计算似然比</span>
        <span class="n">L_f</span> <span class="o">=</span> <span class="n">compute_likelihood_ratio_markov</span><span class="p">(</span><span class="n">paths_f</span><span class="p">,</span> <span class="n">P_f</span><span class="p">,</span> <span class="n">P_g</span><span class="p">,</span> <span class="n">π_0_f</span><span class="p">,</span> <span class="n">π_0_g</span><span class="p">)</span>
        <span class="n">L_g</span> <span class="o">=</span> <span class="n">compute_likelihood_ratio_markov</span><span class="p">(</span><span class="n">paths_g</span><span class="p">,</span> <span class="n">P_f</span><span class="p">,</span> <span class="n">P_g</span><span class="p">,</span> <span class="n">π_0_f</span><span class="p">,</span> <span class="n">π_0_g</span><span class="p">)</span>
        
        <span class="c1"># 决策规则：如果L_T &gt;= 1则选择f</span>
        <span class="n">error_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">L_f</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1"># 第一类错误</span>
        <span class="n">error_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">L_g</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># 第二类错误</span>
        
        <span class="n">total_error</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">error_f</span> <span class="o">+</span> <span class="n">error_g</span><span class="p">)</span>
        <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">total_error</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">errors</span><span class="p">)</span>
</pre></div>
</div>
</div>
</details>
</div>
<p>现在让我们创建一个包含两个不同的3状态马尔可夫链的示例。</p>
<p>我们现在准备模拟路径并可视化似然比是如何演变的。</p>
<p>我们通过绘制经验平均值和理论预测线来验证从平稳分布开始的 <span class="math notranslate nohighlight">\(\frac{1}{T}E_f\left[\log \frac{L_T^{(f)}}{L_T^{(g)}}\right] = h_{KL}(f, g)\)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 定义示例马尔可夫链转移矩阵</span>
<span class="n">P_f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span>
                <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span>
                <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">]])</span>

<span class="n">P_g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span>
                <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span>
                <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">]])</span>

<span class="n">markov_results</span> <span class="o">=</span> <span class="n">analyze_markov_chains</span><span class="p">(</span><span class="n">P_f</span><span class="p">,</span> <span class="n">P_g</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="id16">
<h2><a class="toc-backref" href="#id28" role="doc-backlink"><span class="section-number">22.9. </span>相关讲座</a><a class="headerlink" href="#id16" title="Link to this heading">#</a></h2>
<p>似然过程在贝叶斯学习中扮演重要角色，正如在<a class="reference internal" href="likelihood_bayes.html"><span class="doc">似然比过程和贝叶斯学习</span></a>中所描述的，并在<a class="reference internal" href="odu.html"><span class="doc">工作搜寻 VII: 带学习的搜索</span></a>中得到应用。</p>
<p>似然比过程是Lawrence Blume和David Easley回答他们提出的问题”如果你那么聪明，为什么不富有？” <span id="id17">[<a class="reference internal" href="zreferences.html#id9" title="Lawrence Blume and David Easley. If you're so smart, why aren't you rich? belief selection in complete and incomplete markets. Econometrica, 74(4):929–966, 2006.">Blume and Easley, 2006</a>]</span>的核心，这是讲座<a class="reference internal" href="likelihood_ratio_process_2.html"><span class="doc">异质信念与金融市场</span></a>的主题。</p>
<p>似然比过程也出现在<a class="reference external" href="https://python-advanced.quantecon.org/additive_functionals.html" title="（在 Project name not set）"><span>Additive and Multiplicative Functionals</span></a>中，其中包含了另一个关于上述似然比过程<strong>特殊性质</strong>的说明。</p>
</section>
<section id="id18">
<h2><a class="toc-backref" href="#id29" role="doc-backlink"><span class="section-number">22.10. </span>练习</a><a class="headerlink" href="#id18" title="Link to this heading">#</a></h2>
<div class="exercise admonition" id="lr_ex1">

<p class="admonition-title"><span class="caption-number">练习 22.1 </span></p>
<section id="exercise-content">
<p>考虑自然从第三个密度函数<span class="math notranslate nohighlight">\(h\)</span>生成数据的情况。</p>
<p>设<span class="math notranslate nohighlight">\(\{w_t\}_{t=1}^T\)</span>是从<span class="math notranslate nohighlight">\(h\)</span>中独立同分布抽取的样本，且<span class="math notranslate nohighlight">\(L_t = L(w^t)\)</span>是如讲座中定义的似然比过程。</p>
<p>证明：</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{t} E_h[\log L_t] = K_g - K_f
\]</div>
<p>其中<span class="math notranslate nohighlight">\(K_g, K_f\)</span>有限，<span class="math notranslate nohighlight">\(E_h |\log f(W)| &lt; \infty\)</span>且<span class="math notranslate nohighlight">\(E_h |\log g(W)| &lt; \infty\)</span>。</p>
<p><em>提示：</em> 首先将<span class="math notranslate nohighlight">\(\log L_t\)</span>表示为<span class="math notranslate nohighlight">\(\log \ell(w_i)\)</span>项的和，并与<span class="math notranslate nohighlight">\(K_f\)</span>和<span class="math notranslate nohighlight">\(K_g\)</span>的定义进行比较。</p>
</section>
</div>
<div class="solution dropdown admonition" id="likelihood_ratio_process-solution-1">

<p class="admonition-title">解答<a class="reference internal" href="#lr_ex1"> 练习 22.1</a></p>
<section id="solution-content">
<p>由于<span class="math notranslate nohighlight">\(w_1, \ldots, w_t\)</span>是从<span class="math notranslate nohighlight">\(h\)</span>中独立同分布抽取的样本，我们可以写成</p>
<div class="math notranslate nohighlight">
\[
\log L_t = \log \prod_{i=1}^t \ell(w_i) = \sum_{i=1}^t \log \ell(w_i) = \sum_{i=1}^t \log \frac{f(w_i)}{g(w_i)}
\]</div>
<p>在<span class="math notranslate nohighlight">\(h\)</span>下取期望</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}
E_h[\log L_t] 
= E_h\left[\sum_{i=1}^t \log \frac{f(w_i)}{g(w_i)}\right]\\= \sum_{i=1}^t E_h\left[\log \frac{f(w_i)}{g(w_i)}\right]
\end{aligned}\end{align} \]</div>
<p>由于 <span class="math notranslate nohighlight">\(w_i\)</span> 是同分布的</p>
<div class="math notranslate nohighlight">
\[
E_h[\log L_t] = t \cdot E_h\left[\log \frac{f(w)}{g(w)}\right]
\]</div>
<p>其中 <span class="math notranslate nohighlight">\(w \sim h\)</span>。</p>
<p>因此</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{t} E_h[\log L_t] = E_h\left[\log \frac{f(w)}{g(w)}\right] = E_h[\log f(w)] - E_h[\log g(w)]
\]</div>
<p>根据 Kullback-Leibler 散度的定义</p>
<div class="math notranslate nohighlight">
\[
K_f = \int h(w) \log \frac{h(w)}{f(w)} dw = E_h[\log h(w)] - E_h[\log f(w)]
\]</div>
<p>这给出</p>
<div class="math notranslate nohighlight">
\[
E_h[\log f(w)] = E_h[\log h(w)] - K_f
\]</div>
<p>类似地</p>
<div class="math notranslate nohighlight">
\[
E_h[\log g(w)] = E_h[\log h(w)] - K_g
\]</div>
<p>代回得到</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\frac{1}{t} E_h[\log L_t] &amp;= E_h[\log f(w)] - E_h[\log g(w)] \\
&amp;= [E_h[\log h(w)] - K_f] - [E_h[\log h(w)] - K_g] \\
&amp;= K_g - K_f
\end{aligned}
\end{split}\]</div>
</section>
</div>
<div class="exercise admonition" id="lr_ex2">

<p class="admonition-title"><span class="caption-number">练习 22.2 </span></p>
<section id="exercise-content">
<p>基于<a class="reference internal" href="#lr_ex1"><span class="std std-numref">练习 22.1</span></a>的结果，解释当 <span class="math notranslate nohighlight">\(t \to \infty\)</span> 时在以下情况下 <span class="math notranslate nohighlight">\(L_t\)</span> 会发生什么:</p>
<ol class="arabic simple">
<li><p>当 <span class="math notranslate nohighlight">\(K_g &gt; K_f\)</span> 时(即 <span class="math notranslate nohighlight">\(f\)</span> 比 <span class="math notranslate nohighlight">\(g\)</span> 更”接近” <span class="math notranslate nohighlight">\(h\)</span>)</p></li>
<li><p>当 <span class="math notranslate nohighlight">\(K_g &lt; K_f\)</span> 时(即 <span class="math notranslate nohighlight">\(g\)</span> 比 <span class="math notranslate nohighlight">\(f\)</span> 更”接近” <span class="math notranslate nohighlight">\(h\)</span>)</p></li>
</ol>
<p>将你的答案与<a class="reference internal" href="#llr-h"><span class="std std-ref">本节</span></a>中显示的模拟结果联系起来。</p>
</section>
</div>
<div class="solution dropdown admonition" id="likelihood_ratio_process-solution-3">

<p class="admonition-title">解答<a class="reference internal" href="#lr_ex2"> 练习 22.2</a></p>
<section id="solution-content">
<p>从<a class="reference internal" href="#lr_ex1"><span class="std std-numref">练习 22.1</span></a>中,我们知道:</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{t} E_h[\log L_t] = K_g - K_f
\]</div>
<p><strong>情况1:</strong> 当 <span class="math notranslate nohighlight">\(K_g &gt; K_f\)</span> 时</p>
<p>这里, <span class="math notranslate nohighlight">\(f\)</span> 比 <span class="math notranslate nohighlight">\(g\)</span> 更”接近” <span class="math notranslate nohighlight">\(h\)</span>。由于 <span class="math notranslate nohighlight">\(K_g - K_f &gt; 0\)</span></p>
<div class="math notranslate nohighlight">
\[
E_h[\log L_t] = t \cdot (K_g - K_f) \to +\infty \text{ 当 } t \to \infty
\]</div>
<p>根据大数定律，<span class="math notranslate nohighlight">\(\frac{1}{t} \log L_t \to K_g - K_f &gt; 0\)</span> 几乎必然成立。</p>
<p>因此 <span class="math notranslate nohighlight">\(L_t \to +\infty\)</span> 几乎必然成立。</p>
<p><strong>情况2:</strong> 当 <span class="math notranslate nohighlight">\(K_g &lt; K_f\)</span> 时</p>
<p>这里，<span class="math notranslate nohighlight">\(g\)</span> 比 <span class="math notranslate nohighlight">\(f\)</span> “更接近” <span class="math notranslate nohighlight">\(h\)</span>。由于 <span class="math notranslate nohighlight">\(K_g - K_f &lt; 0\)</span></p>
<div class="math notranslate nohighlight">
\[
E_h[\log L_t] = t \cdot (K_g - K_f) \to -\infty \text{ 当 } t \to \infty
\]</div>
<p>因此通过类似的推理 <span class="math notranslate nohighlight">\(L_t \to 0\)</span> 几乎必然成立。</p>
</section>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                    </div>
                    
                </main> <!-- .page__content -->
                


                <footer class="qe-page__footer">

                    <p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><img src="https://licensebuttons.net/l/by-sa/4.0/80x15.png"></a></p>

                    <p>Creative Commons License &ndash; This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International.</p>

                    <p>A theme by <a href="https://quantecon.org">QuantEcon</a></p>

                </footer> <!-- .page__footer -->

            </div> <!-- .page -->

            

            
            <div class="qe-sidebar bd-sidebar inactive" id="site-navigation">

                <div class="qe-sidebar__header">


                    Contents

                </div>

                <nav class="qe-sidebar__nav" id="qe-sidebar-nav" aria-label="Main navigation">
                    <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  基础工具
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="sir_model.html">
   1. 新冠病毒建模
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="linear_algebra.html">
   2. 线性代数
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="qr_decomp.html">
   3. QR分解
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="eig_circulant.html">
   4. 循环矩阵
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="svd_intro.html">
   5. 奇异值分解
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="var_dmd.html">
   6. 向量自回归和动态模态分解
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="newton_method.html">
   7. 使用牛顿法求解经济模型
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  基础统计学
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="prob_matrix.html">
   8. 基础概率论与矩阵
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="stats_examples.html">
   9. 一些概率分布
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lln_clt.html">
   10. 大数定律 和 中心极限定理
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="prob_meaning.html">
   11. 概率的两种含义
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="multi_hyper.html">
   12. 多元超几何分布
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="multivariate_normal.html">
   13. 多元正态分布
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="hoist_failure.html">
   14. 故障树不确定性
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="back_prop.html">
   15. 人工神经网络简介
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="rand_resp.html">
   16. 随机化回应调查
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="util_rand_resp.html">
   17. 随机回答的期望效用
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  贝叶斯定律
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="bayes_nonconj.html">
   18. 非共轭先验
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ar1_bayes.html">
   19. AR(1)参数的后验分布
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ar1_turningpts.html">
   20. 预测 AR(1) 过程
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  统计与信息论
 </span>
</p>
<ul class="current nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="divergence_measures.html">
   21. 统计散度度量
  </a>
 </li>
 <li class="toctree-l1 current active active">
  <a class="current reference internal" href="#">
   22. 似然比过程
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="likelihood_ratio_process_2.html">
   23. 异质信念与金融市场
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="likelihood_var.html">
   24. VAR模型的似然过程
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="imp_sample.html">
   25. 似然比过程的均值
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="wald_friedman.html">
   26. 让弥尔顿·弗里德曼困惑的问题
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="wald_friedman_2.html">
   27. 用贝叶斯方法解决弗里德曼和瓦尔德问题
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="exchangeable.html">
   28. 可交换性和贝叶斯更新
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="likelihood_bayes.html">
   29. 似然比过程和贝叶斯学习
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mix_model.html">
   30. 错误模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="navy_captain.html">
   31. 贝叶斯与频率主义决策规则的比较
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  线性规划
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="opt_transport.html">
   32. 最优传输
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="von_neumann_model.html">
   33. 冯·诺依曼增长模型（及其推广）
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  动态系统导论
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="finite_markov.html">
   34. 有限马尔可夫链
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="inventory_dynamics.html">
   35. 库存动态
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="linear_models.html">
   36. 线性状态空间模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="samuelson.html">
   37. 萨缪尔森乘数-加速器模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="kesten_processes.html">
   38. Kesten过程与企业动态
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="wealth_dynamics.html">
   39. 财富分布动态
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="kalman.html">
   40. 初见卡尔曼滤波器
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="kalman_2.html">
   41. 卡尔曼滤波器进阶
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  搜索
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="mccall_model.html">
   42. 工作搜寻 I: McCall搜寻模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mccall_model_with_separation.html">
   43. 工作搜寻 II：搜寻与离职
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mccall_fitted_vfi.html">
   44. 工作搜寻 III: 拟合值函数迭代
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mccall_correlated.html">
   45. 工作搜寻 IV：相关工资报价
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="career.html">
   46. 工作搜寻 V：职业选择建模
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="jv.html">
   47. 工作搜寻 VI：在职搜索
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mccall_q.html">
   48. 工作搜寻 VII：McCall劳动者的Q学习
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="odu.html">
   49. 工作搜寻 VII: 带学习的搜索
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  消费、储蓄与资本
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="cass_koopmans_1.html">
   50. Cass-Koopmans模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cass_koopmans_2.html">
   51. Cass-Koopmans竞争均衡
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cass_fiscal.html">
   52. 带扭曲性税收的Cass-Koopmans模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cass_fiscal_2.html">
   53. 带扭曲性税收的双国模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ak2.html">
   54. 代际交叠模型中的转型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cake_eating_problem.html">
   55. 吃蛋糕问题 I：最优储蓄导论
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cake_eating_numerical.html">
   56. 吃蛋糕问题 II：数值方法
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="optgrowth.html">
   57. 最优增长 I：随机最优增长模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="optgrowth_fast.html">
   58. 最优增长 II：使用Numba加速代码
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="coleman_policy_iter.html">
   59. 最优增长 III：时间迭代
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="egm_policy_iter.html">
   60. 最优增长 IV：内生网格法
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ifp.html">
   61. 收入波动问题 I：基本模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ifp_advanced.html">
   62. 收入波动问题 II：资产随机收益
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  LQ控制
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="lqcontrol.html">
   63. LQ控制：基础
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lagrangian_lqdp.html">
   64. LQ控制的拉格朗日方法
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cross_product_trick.html">
   65. 消除交叉项
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="perm_income.html">
   66. 永久收入模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="perm_income_cons.html">
   67. 永久收入 II：线性二次方法
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lq_inventories.html">
   68. 通过库存实现生产平滑
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  多主体模型
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="lake_model.html">
   69. 就业与失业的湖泊模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="rational_expectations.html">
   70. 理性预期均衡
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="re_with_feedback.html">
   71. 线性理性预期模型中的稳定性
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="markov_perf.html">
   72. 马尔可夫完美均衡
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="uncertainty_traps.html">
   73. 不确定性陷阱
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="aiyagari.html">
   74. 艾亚加里模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ak_aiyagari.html">
   75. 长寿、异质性个体、世代交叠模型
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  资产定价与金融
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="markov_asset.html">
   76. 资产定价：有限状态模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ge_arrow.html">
   77. 带有阿罗证券的竞争均衡
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="harrison_kreps.html">
   78. 异质信念与泡沫
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  数据与实证
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="pandas_panel.html">
   79. 用Pandas处理面板数据
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ols.html">
   80. Python线性回归
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mle.html">
   81. 最大似然估计
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  拍卖
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="two_auctions.html">
   82. 一价和二价拍卖
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="house_auction.html">
   83. 多种商品分配机制
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  其他
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="troubleshooting.html">
   84. 故障排除
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="zreferences.html">
   85. 参考文献
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="status.html">
   86. 执行统计
  </a>
 </li>
</ul>

                </nav>

                <div class="qe-sidebar__footer">

                </div>

            </div> <!-- .sidebar -->
            
        </div> <!-- .main -->

        <div class="qe-toolbar">

            <div class="qe-toolbar__inner">

                <ul class="qe-toolbar__main">
                    <li data-tippy-content="Table of Contents" class="btn__sidebar"><i data-feather="menu"></i></li>
                    <li data-tippy-content="Home"><a href="intro.html"><i data-feather="home"></i></a></li>
                    <li class="btn__qelogo"><a href="https://quantecon.org" title=""><span class="show-for-sr">QuantEcon</span></a></li>
                </ul>

                <ul class="qe-toolbar__links">
                    <li class="btn__search">
                        <form action="search.html" method="get">
                            <input type="search" class="form-control" name="q" id="search-input" placeholder="Search..." aria-label="Search..." autocomplete="off" accesskey="k">
                            <i data-feather="search" id="search-icon"></i>
                        </form>
                    </li>
                    <li data-tippy-content="Fullscreen" class="btn__fullscreen"><i data-feather="maximize"></i></li>
                    <li data-tippy-content="Increase font size" class="btn__plus"><i data-feather="plus-circle"></i></li>
                    <li data-tippy-content="Decrease font size" class="btn__minus"><i data-feather="minus-circle"></i></li>
                    <li data-tippy-content="Change contrast" class="btn__contrast"><i data-feather="sunset"></i></li>
                    <li data-tippy-content="Download Notebook"><a href="/_notebooks/likelihood_ratio_process.ipynb" download><i data-feather="download-cloud"></i></a></li>
                    <li class="settings-button" id="settingsButton"><div data-tippy-content="Launch Notebook"><i data-feather="play-circle"></i></div></li>
                        <li data-tippy-content="Download PDF" onClick="window.print()"><i data-feather="file"></i></li>
                    <!--
                    # Enable if looking for link to specific document hosted on GitHub
                    <li data-tippy-content="View Source"><a target="_blank" href="https://github.com/QuantEcon/lecture-python.myst/likelihood_ratio_process.md" download><i data-feather="github"></i></a></li>
                    -->
                    <li data-tippy-content="View Source"><a target="_blank" href="https://github.com/QuantEcon/lecture-python.myst" download><i data-feather="github"></i></a></li>
                </ul>

            </div>

        </div> <!-- .toolbar -->
        <div id="downloadPDFModal" style="display: none;">
            <ul class="pdf-options" style="display: block;">
                <li class="download-pdf-book" onClick="window.print()">
                    <p>Lecture (PDF)</p>
                </li>
                <li class="download-pdf-file">
                    <a href="" download><p>Book (PDF)</p></a>
                </li>
            </ul>
        </div>
        <div id="settingsModal" style="display: none;">
            <p class="modal-title"> Notebook Launcher </p>
            <div class="modal-desc">
            <p>
                Choose public or private cloud service for "Launch" button.
            </p>
            </div>
            <p class="modal-subtitle">Select a server</p>
            <ul class="modal-servers">
            <li class="active launcher-public">
                <span class="label">Public</span>
                <select id="launcher-public-input">
                
                    <option value="https://colab.research.google.com/github/QuantEcon/lecture-python.zh-cn.notebooks/blob/main/likelihood_ratio_process.ipynb">Colab</option>
                
                </select>
                <i class="fas fa-check-circle"></i>
            </li>
            <li class="launcher-private">
                <span class="label">Private</span>
                <input type="text" id="launcher-private-input" data-repourl="https://github.com/QuantEcon/lecture-python.zh-cn.notebooks" data-urlpath="tree/lecture-python.zh-cn.notebooks/likelihood_ratio_process.ipynb" data-branch=main>
                <i class="fas fa-check-circle"></i>
            </li>
            </ul>
            <p class="launch"><a href="https://colab.research.google.com/github/QuantEcon/lecture-python.zh-cn.notebooks/blob/main/likelihood_ratio_process.ipynb" id="advancedLaunchButton" target="_blank">Launch Notebook</a></p>
            <script>
                // QuantEcon Notebook Launcher
                const launcherTypeElements = document.querySelectorAll('#settingsModal .modal-servers li');
                // Highlight the server type if previous selection exists
                if (typeof localStorage.launcherType !== 'undefined') {
                  for (var i = 0; i < launcherTypeElements.length; i++) {
                    launcherTypeElements[i].classList.remove('active');
                    if ( launcherTypeElements[i].classList.contains(localStorage.launcherType) ) {
                      launcherTypeElements[i].classList.add('active');
                    }
                  }
                }
                // Highlight server type on click and set local storage value
                for (var i = 0; i < launcherTypeElements.length; i++) {
                  launcherTypeElements[i].addEventListener('click', function() {
                    for (var j = 0; j < launcherTypeElements.length; j++) {
                      launcherTypeElements[j].classList.remove('active');
                    }
                    this.classList.add('active');
                    if ( this.classList.contains('launcher-private') ) {
                      localStorage.launcherType = 'launcher-private';
                    } else if ( this.classList.contains('launcher-public') ) {
                      localStorage.launcherType = 'launcher-public';
                    }
                    setLaunchServer();
                  })
                }
                const launcherPublic = document.getElementById('launcher-public-input');
                const launcherPrivate = document.getElementById('launcher-private-input');
                const pageName = "likelihood_ratio_process";
                const repoURL = "https://github.com/QuantEcon/lecture-python.zh-cn.notebooks";
                const urlPath = "tree/lecture-python.zh-cn.notebooks/likelihood_ratio_process.ipynb";
                const branch = "main"
                const launchNotebookLink = document.getElementById('advancedLaunchButton');

                // Highlight public server option if previous selection exists
                if (typeof localStorage.launcherPublic !== 'undefined') {
                  launcherPublic.value = localStorage.launcherPublic;
                }
                // Update local storage upon public server selection
                launcherPublic.addEventListener('change', (event) => {
                  setLaunchServer();
                });
                // Populate private server input if previous entry exists
                if (typeof localStorage.launcherPrivate !== 'undefined') {
                  launcherPrivate.value = localStorage.launcherPrivate;
                }
                // Update local storage when a private server is entered
                launcherPrivate.addEventListener('input', (event) => {
                  setLaunchServer();
                });

                // Function to update the "Launch Notebook" link href
                function setLaunchServer() {
                  launchNotebookLink.removeAttribute("style")
                  if ( localStorage.launcherType == 'launcher-private' ) {
                    let repoPrefix = "/user-redirect/git-pull?repo=" + repoURL + "&branch=" + branch + "&urlpath=" + urlPath;
                    launcherPrivateValue = launcherPrivate.value
                    if (!launcherPrivateValue) {
                        launchNotebookLink.removeAttribute("href")
                        launchNotebookLink.style.background = "grey"
                        return
                    }
                    localStorage.launcherPrivate = launcherPrivateValue;
                    privateServer = localStorage.launcherPrivate.replace(/\/$/, "")
                    if (!privateServer.includes("http")) {
                        privateServer = "http://" + privateServer
                    }
                    launchNotebookLinkURL = privateServer + repoPrefix;
                  } else if ( localStorage.launcherType == 'launcher-public' ) {
                    launcherPublicValue = launcherPublic.options[launcherPublic.selectedIndex].value;
                    localStorage.launcherPublic = launcherPublicValue;
                    launchNotebookLinkURL = localStorage.launcherPublic;
                  }
                  if (launchNotebookLinkURL) launchNotebookLink.href = launchNotebookLinkURL;
                }
                // Check if user has previously selected a server
                if ( (typeof localStorage.launcherPrivate !== 'undefined') || (typeof localStorage.launcherPublic !== 'undefined') ) {
                  setLaunchServer();
                }
                </script>

        </div>

    </div> <!-- .wrapper-->
  </body>
</html>