
<!DOCTYPE html>


<html lang="zh-CN" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>33. 冯·诺依曼增长模型（及其推广） &#8212; Python中级数量经济学</title>
    <script src="https://unpkg.com/@popperjs/core@2.9.2/dist/umd/popper.min.js"></script>
    <script src="https://unpkg.com/tippy.js@6.3.1/dist/tippy-bundle.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
    
        <script>
            MathJax = {
            loader: {load: ['[tex]/boldsymbol', '[tex]/textmacros']},
            tex: {
                packages: {'[+]': ['boldsymbol', 'textmacros']},
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                processEscapes: true,
                macros: {
                    "argmax" : "arg\\,max",
                    "argmin" : "arg\\,min",
                    "col"    : "col",
                    "Span"   :  "span",
                    "epsilon": "\\varepsilon",
                    "EE": "\\mathbb{E}",
                    "PP": "\\mathbb{P}",
                    "RR": "\\mathbb{R}",
                    "NN": "\\mathbb{N}",
                    "ZZ": "\\mathbb{Z}",
                    "aA": "\\mathcal{A}",
                    "bB": "\\mathcal{B}",
                    "cC": "\\mathcal{C}",
                    "dD": "\\mathcal{D}",
                    "eE": "\\mathcal{E}",
                    "fF": "\\mathcal{F}",
                    "gG": "\\mathcal{G}",
                    "hH": "\\mathcal{H}",
                }
            },
            svg: {
                fontCache: 'global',
                scale: 0.92,
                displayAlign: "center",
            },
            };
        </script>
    
    
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" href="_static/styles/quantecon-book-theme.css?digest=3bd9fcddbe64f63e07c8604843d1cc622a07b430" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css?v=6644e6bb" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="_static/exercise.css?v=982b99e0" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css?v=b4b7a797" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>


    <script src="_static/documentation_options.js?v=946197a6"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=f281be69"></script>
    <script src="_static/scripts/sphinx-book-theme.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js?v=4a39c7ea"></script>
    <script src="_static/scripts/quantecon-book-theme.js?digest=30f7c850c5b005eca2ad6e48893cd350a6c6c4c2"></script>
    <script src="_static/scripts/jquery.js?v=5d32c60e"></script>
    <script src="_static/scripts/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="_static/translations.js?v=beaddf03"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js?v=f930bc37"></script>
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-J0SMYR4SG3"></script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-J0SMYR4SG3');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-J0SMYR4SG3');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"tex": {"macros": {"argmax": "arg\\,max", "argmin": "arg\\,min"}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'von_neumann_model';</script>
    <link rel="canonical" href="https://python.quantecon-zh-cn.org/von_neumann_model.html" />
    <link rel="icon" href="_static/lectures-favicon.ico"/>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="34. 有限马尔可夫链" href="finite_markov.html" />
    <link rel="prev" title="32. 最优传输" href="opt_transport.html" />

<!-- Normal Meta Tags -->
<meta name="author" context="Thomas J. Sargent &amp; John Stachurski" />
<meta name="keywords" content="Python, QuantEcon, Quantitative Economics, Economics, Sloan, Alfred P. Sloan Foundation, Tom J. Sargent, John Stachurski" />
<meta name="description" content=本课程是由托马斯·萨金特（Thomas J. Sargent）和约翰·斯塔胡斯基（John Stachurski）设计和编写的数量经济建模讲座。 />

<!-- Twitter tags -->
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@quantecon" />
<meta name="twitter:title" content="冯·诺依曼增长模型（及其推广）"/>
<meta name="twitter:description" content="本课程是由托马斯·萨金特（Thomas J. Sargent）和约翰·斯塔胡斯基（John Stachurski）设计和编写的数量经济建模讲座。">
<meta name="twitter:creator" content="@quantecon">
<meta name="twitter:image" content="https://assets.quantecon.org/img/qe-twitter-logo.png">

<!-- Opengraph tags -->
<meta property="og:title" content="冯·诺依曼增长模型（及其推广）" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://python.quantecon-zh-cn.org/von_neumann_model.html" />
<meta property="og:image" content="https://assets.quantecon.org/img/qe-og-logo.png" />
<meta property="og:description" content="本课程是由托马斯·萨金特（Thomas J. Sargent）和约翰·斯塔胡斯基（John Stachurski）设计和编写的数量经济建模讲座。" />
<meta property="og:site_name" content="Python中级数量经济学" />
<meta name="theme-color" content="#ffffff" />

  </head>
<body>

<!-- Override QuantEcon theme colors -->

    <span id="top"></span>

    <div class="qe-wrapper">

        <div class="qe-main">

            <div class="qe-page" id=von_neumann_model>

                <div class="qe-page__toc">

                    <div class="inner">

                        
                        <div class="qe-page__toc-header">
                            On this page
                        </div>


                        <nav id="bd-toc-nav" class="qe-page__toc-nav">
                            <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">33.1. 符号表示</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">33.2. 模型要素和假设</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">33.3. 动态解释</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">33.3.1. 平衡增长</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">33.4. 对偶性</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id15">33.5. 作为零和双人博弈的解释</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lp">33.5.1. 与线性规划(LP)的联系</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id19">33.5.2. 算法</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id21">33.5.2.1. 第1步</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id22">33.5.2.2. 第2步</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id23">33.5.3. 唯一性和不可约性</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id25">33.5.4. 特殊情况</a></li>
</ul>
</li>
</ul>
                            <p class="logo">
                                
                                    
                                    <a href=https://quantecon.org><img src="_static/qe-logo-large.png" class="logo logo-img" alt="logo"></a>
                                    
                                    
                                
                            </p>

                            <p class="powered">Powered by <a href="https://jupyterbook.org/en/stable/">Jupyter Book</a></p>

                        </nav>

                        <div class="qe-page__toc-footer">
                            
                            
                            <p><a href="#top"><strong>Back to top</strong></a></p>
                        </div>

                    </div>

                </div>

                <div class="qe-page__header">

                    <div class="qe-page__header-copy">

                        <p class="qe-page__header-heading"><a href="intro.html">Python中级数量经济学</a></p>

                        <p class="qe-page__header-subheading">冯·诺依曼增长模型（及其推广）</p>

                    </div>
                    <!-- length 2, since its a string and empty dict has length 2 - {} -->
                        <p class="qe-page__header-authors" font-size="18">
                            
                                
                                    <a href="http://www.tomsargent.com/" target="_blank"><span>托马斯·萨金特（Thomas J. Sargent）</span></a>
                                
                            
                                
                                    and <a href="https://johnstachurski.net/" target="_blank"><span>约翰·斯塔胡斯基（John Stachurski）</span></a>
                                
                            
                        </p>


                </div> <!-- .page__header -->



                
                <main class="qe-page__content" role="main">
                    
                    <div>
                        
  <section class="tex2jax_ignore mathjax_ignore" id="index-0">
<span id="id1"></span><h1><a class="toc-backref" href="#id27" role="doc-backlink"><span class="section-number">33. </span>冯·诺依曼增长模型（及其推广）</a><a class="headerlink" href="#index-0" title="Link to this heading">#</a></h1>
<nav class="contents" id="id2">
<p class="topic-title">目录</p>
<ul class="simple">
<li><p><a class="reference internal" href="#index-0" id="id27">冯·诺依曼增长模型（及其推广）</a></p>
<ul>
<li><p><a class="reference internal" href="#id5" id="id28">符号表示</a></p></li>
<li><p><a class="reference internal" href="#id6" id="id29">模型要素和假设</a></p></li>
<li><p><a class="reference internal" href="#id8" id="id30">动态解释</a></p></li>
<li><p><a class="reference internal" href="#id10" id="id31">对偶性</a></p></li>
<li><p><a class="reference internal" href="#id15" id="id32">作为零和双人博弈的解释</a></p></li>
</ul>
</li>
</ul>
</nav>
<p>本讲座使用<code class="docutils literal notranslate"><span class="pre">Neumann</span></code>类来计算约翰·冯·诺依曼<span id="id3">[<a class="reference internal" href="zreferences.html#id84" title="John von Neumann. Uber ein okonomsiches gleichungssystem und eine verallgemeinering des browerschen fixpunktsatzes. In Erge. Math. Kolloq., volume 8, 73–83. 1937.">von Neumann, 1937</a>]</span>提出的线性增长模型的一些关键要素，该模型后来被Kemeny、Morgenstern和Thompson <span id="id4">[<a class="reference internal" href="zreferences.html#id87" title="John G Kemeny, Oskar Morgenstern, and Gerald L Thompson. A generalization of the von neumann model of an expanding economy. Econometrica, Journal of the Econometric Society, pages 115–135, 1956.">Kemeny <em>et al.</em>, 1956</a>]</span>进行了推广。</p>
<p>我们关注的要素包括最大扩张率（<span class="math notranslate nohighlight">\(\alpha\)</span>）、利息因子（<span class="math notranslate nohighlight">\(β\)</span>）、最优强度（<span class="math notranslate nohighlight">\(x\)</span>）和价格（<span class="math notranslate nohighlight">\(p\)</span>）。</p>
<p>除了观察约翰·冯·诺依曼这位伟大思想家如何构建均衡增长中的价格和数量向量模型外，本讲还将展示如何有效地运用以下重要工具：</p>
<ul class="simple">
<li><p>零和双人博弈</p></li>
<li><p>线性规划</p></li>
<li><p>Perron-Frobenius定理</p></li>
</ul>
<p>让我们从一些导入开始：</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">mpl</span>
<span class="n">FONTPATH</span> <span class="o">=</span> <span class="s2">&quot;fonts/SourceHanSerifSC-SemiBold.otf&quot;</span>
<span class="n">mpl</span><span class="o">.</span><span class="n">font_manager</span><span class="o">.</span><span class="n">fontManager</span><span class="o">.</span><span class="n">addfont</span><span class="p">(</span><span class="n">FONTPATH</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;font.family&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Source Han Serif SC&#39;</span><span class="p">]</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">fsolve</span><span class="p">,</span> <span class="n">linprog</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">textwrap</span><span class="w"> </span><span class="kn">import</span> <span class="n">dedent</span>

<span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>以下代码提供了<code class="docutils literal notranslate"><span class="pre">Neumann</span></code>类</p>
<div class="cell tag_collapse-20 docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">Neumann</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    该类描述了Kemeny等人(1956, ECTA)和Gale(1960, 第9.5章)讨论的广义冯·诺依曼增长模型：</span>

<span class="sd">    设：</span>
<span class="sd">    n ... 商品数量</span>
<span class="sd">    m ... 生产活动数量</span>
<span class="sd">    A ... 投入矩阵，维度为m×n</span>
<span class="sd">        a_{i,j} - 活动i消耗的商品j的数量</span>
<span class="sd">    B ... 产出矩阵，维度为m×n</span>
<span class="sd">        b_{i,j} - 活动i生产的商品j的数量</span>

<span class="sd">    x ... 强度向量(m维向量)，具有非负分量</span>
<span class="sd">        x&#39;B - 商品的产出向量</span>
<span class="sd">        x&#39;A - 商品的消耗向量</span>
<span class="sd">    p ... 价格向量(n维向量)，具有非负分量</span>
<span class="sd">        Bp - 每个活动的收入向量</span>
<span class="sd">        Ap - 每个活动的成本向量</span>

<span class="sd">    A和B的元素都非负。此外，我们假设：</span>
<span class="sd">    (1) 假设I(每种被消耗的商品都会被生产)：</span>
<span class="sd">        对所有j，b_{.,j} &gt; 0，即至少有一个元素严格为正</span>
<span class="sd">    (2) 假设II(没有免费午餐)：</span>
<span class="sd">        对所有i，a_{i,.} &gt; 0，即至少有一个元素严格为正</span>

<span class="sd">    参数</span>
<span class="sd">    ----------</span>
<span class="sd">    A : array_like或标量(float)</span>
<span class="sd">        状态转移方程的一部分。应为 `m x n` 矩阵</span>
<span class="sd">    B : array_like或标量(float)</span>
<span class="sd">        状态转移方程的一部分。应为 `m x n` 矩阵</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert</span><span class="p">,</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># 检查(A, B)是否满足基本假设</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s1">&#39;投入和产出矩阵必须具有相同的维度！&#39;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s1">&#39;投入和产出矩阵必须只包含非负元素！&#39;</span>

        <span class="c1"># (1) 检查是否满足假设I：</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">AI</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">AI</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># (2) 检查是否满足假设II：</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">AII</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">AII</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">me</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        广义冯·诺依曼扩张模型：</span>
<span class="s2">          - 商品数量              : </span><span class="si">{n}</span>
<span class="s2">          - 生产活动数量          : </span><span class="si">{m}</span>

<span class="s2">        假设：</span>
<span class="s2">          - AI:  B的每一列都有正元素    : </span><span class="si">{AI}</span>
<span class="s2">          - AII: A的每一行都有正元素    : </span><span class="si">{AII}</span>

<span class="s2">        &quot;&quot;&quot;</span>
        <span class="c1"># 不可约的                                       : {irr}</span>
        <span class="k">return</span> <span class="n">dedent</span><span class="p">(</span><span class="n">me</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span>
                                <span class="n">AI</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">AI</span><span class="p">,</span> <span class="n">AII</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">AII</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        将类数组对象(列表的列表、浮点数等)转换为规范的2D NumPy数组</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        计算alpha(扩张率)和beta(利息因子)的简单上下界。</span>
<span class="sd">        参见Gale(1960)定理9.8的证明</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span>

        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">α</span><span class="p">:</span> <span class="p">((</span><span class="n">B</span> <span class="o">-</span> <span class="n">α</span> <span class="o">*</span> <span class="n">A</span><span class="p">)</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">g</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">β</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span> <span class="o">@</span> <span class="p">(</span><span class="n">B</span> <span class="o">-</span> <span class="n">β</span> <span class="o">*</span> <span class="n">A</span><span class="p">))</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

        <span class="n">UB</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>  <span class="c1"># α, β的上界</span>
        <span class="n">LB</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>  <span class="c1"># α, β的下界</span>

        <span class="k">return</span> <span class="n">LB</span><span class="p">,</span> <span class="n">UB</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">zerosum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">γ</span><span class="p">,</span> <span class="n">dual</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        给定gamma，计算由矩阵定义的两人零和博弈的值和最优策略</span>

<span class="sd">                M(gamma) = B - gamma * A</span>

<span class="sd">        行玩家最大化，列玩家最小化</span>

<span class="sd">        零和博弈作为线性规划(原问题 --&gt; α)</span>

<span class="sd">            max (0&#39;, 1) @ (x&#39;, v)</span>
<span class="sd">            约束条件</span>
<span class="sd">            [-M&#39;, ones(n, 1)] @ (x&#39;, v)&#39; &lt;= 0</span>
<span class="sd">            (x&#39;, v) @ (ones(m, 1), 0) = 1</span>
<span class="sd">            (x&#39;, v) &gt;= (0&#39;, -inf)</span>

<span class="sd">        零和博弈作为线性规划(对偶问题 --&gt; beta)</span>

<span class="sd">            min (0&#39;, 1) @ (p&#39;, u)</span>
<span class="sd">            约束条件</span>
<span class="sd">            [M, -ones(m, 1)] @ (p&#39;, u)&#39; &lt;= 0</span>
<span class="sd">            (p&#39;, u) @ (ones(n, 1), 0) = 1</span>
<span class="sd">            (p&#39;, u) &gt;= (0&#39;, -inf)</span>

<span class="sd">        输出：</span>
<span class="sd">        --------</span>
<span class="sd">        value: 标量</span>
<span class="sd">            零和博弈的值</span>

<span class="sd">        strategy: 向量</span>
<span class="sd">            如果dual = False，则为强度向量</span>
<span class="sd">            如果dual = True，则为价格向量</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">B</span> <span class="o">-</span> <span class="n">γ</span> <span class="o">*</span> <span class="n">A</span>

        <span class="k">if</span> <span class="n">dual</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="c1"># 用原始线性规划求解（详情参见上面的描述）</span>
            <span class="c1"># (1) 定义待求解问题的目标函数（linprog 默认求最小值，因此这里取负号）</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># (2) 添加约束：</span>
            <span class="c1"># ... 非负约束</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)])</span>
            <span class="c1"># ... 不等式约束</span>
            <span class="n">A_iq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="o">-</span><span class="n">M</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))])</span>
            <span class="n">b_iq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="c1"># ... 归一化</span>
            <span class="n">A_eq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">b_eq</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">res</span> <span class="o">=</span> <span class="n">linprog</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">A_ub</span><span class="o">=</span><span class="n">A_iq</span><span class="p">,</span> <span class="n">b_ub</span><span class="o">=</span><span class="n">b_iq</span><span class="p">,</span> <span class="n">A_eq</span><span class="o">=</span><span class="n">A_eq</span><span class="p">,</span> <span class="n">b_eq</span><span class="o">=</span><span class="n">b_eq</span><span class="p">,</span>
                          <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 用对偶线性规划求解（详情参见上面的描述）</span>
            <span class="c1"># (1) 定义待求解问题的目标函数（linprog 默认求最小值，因此这里取负号）</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="mi">1</span><span class="p">])</span>

            <span class="c1"># (2) 添加约束：</span>
            <span class="c1"># ... 非负约束</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)])</span>
            <span class="c1"># ... 不等式约束</span>
            <span class="n">A_iq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">M</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">))])</span>
            <span class="n">b_iq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="c1"># ... 归一化</span>
            <span class="n">A_eq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">b_eq</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">res</span> <span class="o">=</span> <span class="n">linprog</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">A_ub</span><span class="o">=</span><span class="n">A_iq</span><span class="p">,</span> <span class="n">b_ub</span><span class="o">=</span><span class="n">b_iq</span><span class="p">,</span> <span class="n">A_eq</span><span class="o">=</span><span class="n">A_eq</span><span class="p">,</span> <span class="n">b_eq</span><span class="o">=</span><span class="n">b_eq</span><span class="p">,</span>
                          <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>

        <span class="c1"># 提取所需的量</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">strategy</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">value</span><span class="p">,</span> <span class="n">strategy</span>


    <span class="k">def</span><span class="w"> </span><span class="nf">expansion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">maxit</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        这里使用的算法来自Hamburger-Thompson-Weil(1967, ECTA)。</span>
<span class="sd">        它基于简单的二分法，并利用了这样一个思想：对于给定的γ(= α或β)，</span>
<span class="sd">        矩阵&quot;M = B - γ * A&quot;定义了一个两人零和博弈，其中最优策略是</span>
<span class="sd">        (归一化的)强度和价格向量。</span>

<span class="sd">        输出：</span>
<span class="sd">        --------</span>
<span class="sd">        alpha: 标量</span>
<span class="sd">            最优扩张率</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">LB</span><span class="p">,</span> <span class="n">UB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">()</span>

        <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxit</span><span class="p">):</span>

            <span class="n">γ</span> <span class="o">=</span> <span class="p">(</span><span class="n">LB</span> <span class="o">+</span> <span class="n">UB</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">ZS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">γ</span><span class="o">=</span><span class="n">γ</span><span class="p">)</span>
            <span class="n">V</span> <span class="o">=</span> <span class="n">ZS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>     <span class="c1"># γ对应的博弈值</span>

            <span class="k">if</span> <span class="n">V</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">LB</span> <span class="o">=</span> <span class="n">γ</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">UB</span> <span class="o">=</span> <span class="n">γ</span>

            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">UB</span> <span class="o">-</span> <span class="n">LB</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="n">γ</span> <span class="o">=</span> <span class="p">(</span><span class="n">UB</span> <span class="o">+</span> <span class="n">LB</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">γ</span><span class="o">=</span><span class="n">γ</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">γ</span><span class="o">=</span><span class="n">γ</span><span class="p">,</span> <span class="n">dual</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">break</span>

        <span class="k">return</span> <span class="n">γ</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">interest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">maxit</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        这里使用的算法来自Hamburger-Thompson-Weil(1967, ECTA)。</span>
<span class="sd">        它基于简单的二分法，并利用了这样一个思想：对于给定的γ(= α或β)，</span>
<span class="sd">        矩阵&quot;M = B - γ * A&quot;定义了一个两人零和博弈，其中最优策略是</span>
<span class="sd">        (归一化的)强度和价格向量。</span>

<span class="sd">        输出：</span>
<span class="sd">        --------</span>
<span class="sd">        beta: 标量</span>
<span class="sd">            最优利率</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">LB</span><span class="p">,</span> <span class="n">UB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">()</span>

        <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxit</span><span class="p">):</span>
            <span class="n">γ</span> <span class="o">=</span> <span class="p">(</span><span class="n">LB</span> <span class="o">+</span> <span class="n">UB</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">ZS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">γ</span><span class="o">=</span><span class="n">γ</span><span class="p">,</span> <span class="n">dual</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">V</span> <span class="o">=</span> <span class="n">ZS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">V</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">LB</span> <span class="o">=</span> <span class="n">γ</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">UB</span> <span class="o">=</span> <span class="n">γ</span>

            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">UB</span> <span class="o">-</span> <span class="n">LB</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="n">γ</span> <span class="o">=</span> <span class="p">(</span><span class="n">UB</span> <span class="o">+</span> <span class="n">LB</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">γ</span><span class="o">=</span><span class="n">γ</span><span class="p">,</span> <span class="n">dual</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">γ</span><span class="o">=</span><span class="n">γ</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">break</span>

        <span class="k">return</span> <span class="n">γ</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span>
</pre></div>
</div>
</div>
</div>
<section id="id5">
<h2><a class="toc-backref" href="#id28" role="doc-backlink"><span class="section-number">33.1. </span>符号表示</a><a class="headerlink" href="#id5" title="Link to this heading">#</a></h2>
<p>我们使用以下符号表示。</p>
<p><span class="math notranslate nohighlight">\(\mathbf{0}\)</span> 表示零向量。</p>
<p>对于一个 <span class="math notranslate nohighlight">\(n\)</span> 维向量，如果对所有 <span class="math notranslate nohighlight">\(i=1,2,\dots,n\)</span> 都有 <span class="math notranslate nohighlight">\(x_i&gt;0\)</span>，我们称之为<strong>正向量</strong>，记作 <span class="math notranslate nohighlight">\(x\gg \mathbf{0}\)</span>。</p>
<p>如果对所有 <span class="math notranslate nohighlight">\(i=1,2,\dots,n\)</span> 都有 <span class="math notranslate nohighlight">\(x_i\geq 0\)</span>，我们称之为<strong>非负向量</strong>，记作 <span class="math notranslate nohighlight">\(x\geq \mathbf{0}\)</span>。</p>
<p>如果 <span class="math notranslate nohighlight">\(x\geq \mathbf{0}\)</span> 且 <span class="math notranslate nohighlight">\(x\neq \mathbf{0}\)</span>，我们称之为<strong>半正向量</strong>，记作 <span class="math notranslate nohighlight">\(x &gt; \mathbf{0}\)</span>。</p>
<p>对于两个可比向量 <span class="math notranslate nohighlight">\(x\)</span> 和 <span class="math notranslate nohighlight">\(y\)</span>，<span class="math notranslate nohighlight">\(x\gg y\)</span>、<span class="math notranslate nohighlight">\(x\geq y\)</span> 和 <span class="math notranslate nohighlight">\(x&gt; y\)</span> 分别表示 <span class="math notranslate nohighlight">\(x-y\gg \mathbf{0}\)</span>、<span class="math notranslate nohighlight">\(x-y \geq \mathbf{0}\)</span> 和 <span class="math notranslate nohighlight">\(x-y &gt; \mathbf{0}\)</span>。</p>
<p>本讲中所有向量均为列向量；<span class="math notranslate nohighlight">\(x^{T}\)</span> 表示 <span class="math notranslate nohighlight">\(x\)</span> 的转置（即行向量）。</p>
<p>用 <span class="math notranslate nohighlight">\(\iota_n\)</span> 表示由 <span class="math notranslate nohighlight">\(n\)</span> 个1组成的列向量，即 <span class="math notranslate nohighlight">\(\iota_n = (1,1,\dots,1)^T\)</span>。</p>
<p>用 <span class="math notranslate nohighlight">\(e^i\)</span> 表示一个（任意维度的）向量，除第 <span class="math notranslate nohighlight">\(i\)</span> 个位置为1外，其余位置均为0。</p>
<p>我们用大写字母表示矩阵。对于任意矩阵 <span class="math notranslate nohighlight">\(A\)</span>，<span class="math notranslate nohighlight">\(a_{i,j}\)</span> 表示其第 <span class="math notranslate nohighlight">\(i\)</span> 行、第 <span class="math notranslate nohighlight">\(j\)</span> 列的元素。</p>
<p><span class="math notranslate nohighlight">\(a_{\cdot j}\)</span> 和 <span class="math notranslate nohighlight">\(a_{i\cdot}\)</span> 分别表示矩阵 <span class="math notranslate nohighlight">\(A\)</span> 的第 <span class="math notranslate nohighlight">\(j\)</span> 列和第 <span class="math notranslate nohighlight">\(i\)</span> 行。</p>
</section>
<section id="id6">
<h2><a class="toc-backref" href="#id29" role="doc-backlink"><span class="section-number">33.2. </span>模型要素和假设</a><a class="headerlink" href="#id6" title="Link to this heading">#</a></h2>
<p>一对 <span class="math notranslate nohighlight">\(m\times n\)</span> 非负矩阵 <span class="math notranslate nohighlight">\((A,B)\)</span> 定义了一个经济体。</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(m\)</span> 是<em>活动</em>（或部门）的数量</p></li>
<li><p><span class="math notranslate nohighlight">\(n\)</span> 是<em>商品</em>（生产和/或消费）的数量</p></li>
<li><p><span class="math notranslate nohighlight">\(A\)</span> 被称为<em>投入矩阵</em>；<span class="math notranslate nohighlight">\(a_{i,j}\)</span> 表示活动 <span class="math notranslate nohighlight">\(i\)</span> 消耗的商品 <span class="math notranslate nohighlight">\(j\)</span> 的数量</p></li>
<li><p><span class="math notranslate nohighlight">\(B\)</span> 被称为<em>产出矩阵</em>；<span class="math notranslate nohighlight">\(b_{i,j}\)</span> 表示活动 <span class="math notranslate nohighlight">\(i\)</span> 生产的商品 <span class="math notranslate nohighlight">\(j\)</span> 的数量</p></li>
</ul>
<p>两个关键假设限制经济 <span class="math notranslate nohighlight">\((A,B)\)</span>：</p>
<div class="proof assumption admonition" id="assumption1">
<p class="admonition-title"><span class="caption-number">假设 33.1 </span> (每种被消费的商品也都被生产。)</p>
<section class="assumption-content" id="proof-content">
<div class="math notranslate nohighlight">
\[  b_{.,j} &gt; \mathbf{0}\hspace{5mm}\forall j=1,2,\dots,n\]</div>
</section>
</div><div class="proof assumption admonition" id="assumption2">
<p class="admonition-title"><span class="caption-number">假设 33.2 </span> (没有免费午餐)</p>
<section class="assumption-content" id="proof-content">
<div class="math notranslate nohighlight">
\[  a_{i,.} &gt; \mathbf{0}\hspace{5mm}\forall i=1,2,\dots,m\]</div>
</section>
</div><p>半正<em>强度</em> <span class="math notranslate nohighlight">\(m\)</span> 维向量 <span class="math notranslate nohighlight">\(x\)</span> 表示活动的运行水平。</p>
<p>因此，</p>
<ul class="simple">
<li><p>向量 <span class="math notranslate nohighlight">\(x^TA\)</span> 表示<em>生产中使用的商品总量</em></p></li>
<li><p>向量 <span class="math notranslate nohighlight">\(x^TB\)</span> 表示<em>总产出</em></p></li>
</ul>
<p>如果存在一个非负强度向量 <span class="math notranslate nohighlight">\(x \geq 0\)</span> 使得 <span class="math notranslate nohighlight">\(x^T B &gt; x^TA\)</span>，则称经济体 <span class="math notranslate nohighlight">\((A,B)\)</span> 是<em>生产性的</em>。</p>
<p>半正 <span class="math notranslate nohighlight">\(n\)</span> 维向量 <span class="math notranslate nohighlight">\(p\)</span> 包含了分配给 <span class="math notranslate nohighlight">\(n\)</span> 种商品的价格。</p>
<p>向量 <span class="math notranslate nohighlight">\(p\)</span> 决定了<em>成本</em>和<em>收入</em>向量</p>
<ul class="simple">
<li><p>向量 <span class="math notranslate nohighlight">\(Ap\)</span> 表示各项活动的<em>成本</em></p></li>
<li><p>向量 <span class="math notranslate nohighlight">\(Bp\)</span> 表示各项活动的<em>收入</em></p></li>
</ul>
<p>投入-产出对 <span class="math notranslate nohighlight">\((A,B)\)</span> 的一个性质被称为<strong>不可约性</strong>（或不可分解性），它决定了一个经济系统能否被分解为多个“子经济体”。</p>
<div class="proof definition admonition" id="definition-2">
<p class="admonition-title"><span class="caption-number">定义 33.1 </span></p>
<section class="definition-content" id="proof-content">
<p>对于经济体 <span class="math notranslate nohighlight">\((A,B)\)</span>，如果存在商品的一个子集 <span class="math notranslate nohighlight">\(S \subset \{1,2,\dots,n\}\)</span>，在不消耗集合 <span class="math notranslate nohighlight">\(S\)</span> 以外商品的情况下就可以生产 <span class="math notranslate nohighlight">\(S\)</span> 中的每种商品，那么称 <span class="math notranslate nohighlight">\(S\)</span> 是一个<em>独立子集</em>。</p>
<p>形式上，如果集合 <span class="math notranslate nohighlight">\(S\)</span> 满足以下条件，则称其为独立的：<span class="math notranslate nohighlight">\(\exists T\subset \{1,2,\dots,m\}\)</span>（活动的一个子集），使得对于所有 <span class="math notranslate nohighlight">\(i\in T\)</span> 和 <span class="math notranslate nohighlight">\(j\in S^c\)</span>，有 <span class="math notranslate nohighlight">\(a_{i,j}=0\)</span>，且对于所有 <span class="math notranslate nohighlight">\(j\in S\)</span>，<span class="math notranslate nohighlight">\(\exists i\in T\)</span> 使得 <span class="math notranslate nohighlight">\(b_{i,j}&gt;0\)</span>。</p>
<p>如果不存在真独立子集，则称该经济是<strong>不可约的</strong>。</p>
</section>
</div><p>我们研究两个例子，都来自Gale的著作第9.6章 <span id="id7">[<a class="reference internal" href="zreferences.html#id89" title="David Gale. The theory of linear economic models. University of Chicago press, 1989.">Gale, 1989</a>]</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># (1) 不可约的(A, B)例子：α_0 = β_0</span>
<span class="n">A1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>

<span class="n">B1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

<span class="c1"># (2) 可约的(A, B)例子：β_0 &lt; α_0</span>
<span class="n">A2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>

<span class="n">B2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
</pre></div>
</div>
</div>
</div>
<p>下面的代码设置了我们的第一个诺伊曼经济的实例</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n1</span> <span class="o">=</span> <span class="n">Neumann</span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">B1</span><span class="p">)</span>
<span class="n">n1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>广义冯·诺依曼扩张模型：
  - 商品数量              : 4
  - 生产活动数量          : 3

假设：
  - AI:  B的每一列都有正元素    : True
  - AII: A的每一行都有正元素    : True
</pre></div>
</div>
</div>
</div>
<p>这是第二个诺伊曼经济的实例</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n2</span> <span class="o">=</span> <span class="n">Neumann</span><span class="p">(</span><span class="n">A2</span><span class="p">,</span> <span class="n">B2</span><span class="p">)</span>
<span class="n">n2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>广义冯·诺依曼扩张模型：
  - 商品数量              : 6
  - 生产活动数量          : 5

假设：
  - AI:  B的每一列都有正元素    : True
  - AII: A的每一行都有正元素    : True
</pre></div>
</div>
</div>
</div>
</section>
<section id="id8">
<h2><a class="toc-backref" href="#id30" role="doc-backlink"><span class="section-number">33.3. </span>动态解释</a><a class="headerlink" href="#id8" title="Link to this heading">#</a></h2>
<p>现在给上述模型的所有对象附加一个时间指标 <span class="math notranslate nohighlight">\(t\)</span>，将经济体视为一个动态系统，并考虑以下序列：</p>
<div class="math notranslate nohighlight">
\[
\{(A_t,B_t)\}_{t\geq 0}, \hspace{1cm}\{x_t\}_{t\geq 0},\hspace{1cm} \{p_t\}_{t\geq 0}
\]</div>
<p>一个有趣的特殊情况是保持技术过程不变，仅研究商品数量和价格的动态变化。</p>
<p>因此，在本讲座的剩余部分，我们假设对所有 <span class="math notranslate nohighlight">\(t\geq 0\)</span> 都有 <span class="math notranslate nohighlight">\((A_t,B_t)=(A,B)\)</span>。</p>
<p>动态解释中一个关键因素是生产的时间安排。</p>
<p>我们假设生产（投入品的消耗）发生在 <span class="math notranslate nohighlight">\(t\)</span> 期，而相应的产出在 <span class="math notranslate nohighlight">\(t+1\)</span> 期实现，即在 <span class="math notranslate nohighlight">\(t\)</span> 期消耗 <span class="math notranslate nohighlight">\(x_{t}^TA\)</span> 将在 <span class="math notranslate nohighlight">\(t+1\)</span> 期产生 <span class="math notranslate nohighlight">\(x^T_{t}B\)</span> 数量的产出。</p>
<p>这一时序约定意味着以下可行性条件：</p>
<div class="math notranslate nohighlight">
\[
\begin{aligned}
x^T_{t}B \geq x^T_{t+1} A \hspace{1cm}\forall t\geq 1
\end{aligned}
\]</div>
<p>这表明今天消耗的商品不能超过昨天生产的数量。</p>
<p>因此，<span class="math notranslate nohighlight">\(Ap_t\)</span> 表示第 <span class="math notranslate nohighlight">\(t\)</span> 期的生产成本，而 <span class="math notranslate nohighlight">\(Bp_t\)</span> 表示第 <span class="math notranslate nohighlight">\(t+1\)</span> 期的收入。</p>
<section id="id9">
<h3><span class="section-number">33.3.1. </span>平衡增长<a class="headerlink" href="#id9" title="Link to this heading">#</a></h3>
<p>我们按照约翰·冯·诺依曼的方法来研究“平衡增长”。</p>
<p>让 <span class="math notranslate nohighlight">\(./\)</span>表示两个向量的逐元素除法，让 <span class="math notranslate nohighlight">\(\alpha &gt;0\)</span> 为一个标量。</p>
<p>那么<strong>平衡增长</strong>指的是如下情形：</p>
<div class="math notranslate nohighlight">
\[
x_{t+1}./x_t = \alpha , \quad \forall t \geq 0
\]</div>
<p>在平衡增长下，<span class="math notranslate nohighlight">\(x\)</span> 的运动规律显然是 <span class="math notranslate nohighlight">\(x_{t+1}=\alpha x_t\)</span>，因此我们可以将可行性约束重写为：</p>
<div class="math notranslate nohighlight">
\[
x^T_{t}B \geq \alpha x^T_t A \hspace{1cm}\forall t
\]</div>
<p>类似地，将 <span class="math notranslate nohighlight">\(\beta\in\mathbb{R}\)</span> 定义为每单位时间的<strong>利息因子</strong>。</p>
<p>我们假设，通过在“模型外”投资始终可以获得等于常数利息因子 <span class="math notranslate nohighlight">\(\beta\)</span> 的总回报。</p>
<p>基于该假设，一个无套利条件对价格序列提出了如下的（无利润）限制：</p>
<div class="math notranslate nohighlight">
\[
\beta Ap_{t} \geq B p_{t} \hspace{1cm}\forall t
\]</div>
<p>这表明生产的回报不能超过外部投资机会所提供的回报（这里我们比较第<span class="math notranslate nohighlight">\(t+1\)</span>期的价值）。</p>
<p>平衡增长假设使我们可以省略时间下标，并完全基于时不变的增长率 <span class="math notranslate nohighlight">\(\alpha\)</span> 和利息因子 <span class="math notranslate nohighlight">\(\beta\)</span> 进行分析。</p>
</section>
</section>
<section id="id10">
<h2><a class="toc-backref" href="#id31" role="doc-backlink"><span class="section-number">33.4. </span>对偶性</a><a class="headerlink" href="#id10" title="Link to this heading">#</a></h2>
<p>经济系统的技术特征和价值特征之间存在一个值得注意的的对偶关系，将下面两个问题联系在一起：</p>
<div class="proof definition admonition" id="definition-3">
<p class="admonition-title"><span class="caption-number">定义 33.2 </span></p>
<section class="definition-content" id="proof-content">
<p>经济体 <span class="math notranslate nohighlight">\((A,B)\)</span> 的<strong>技术扩张问题</strong>（technological expansion problem, TEP）是找到一个半正 <span class="math notranslate nohighlight">\(m\)</span> 维向量 <span class="math notranslate nohighlight">\(x&gt;0\)</span> 和一个实数 <span class="math notranslate nohighlight">\(\alpha\in\mathbb{R}\)</span>，使其满足</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
    &amp;\max_{\alpha} \hspace{2mm} \alpha\\
    \text{使得 }\hspace{2mm} &amp; x^\top B \geq \alpha x^\top A
    \end{aligned}
\end{split}\]</div>
</section>
</div><p>David Gale的著作中的定理9.3 <span id="id11">[<a class="reference internal" href="zreferences.html#id89" title="David Gale. The theory of linear economic models. University of Chicago press, 1989.">Gale, 1989</a>]</span>指出，如果假设I和II都满足，那么<span class="math notranslate nohighlight">\(\alpha\)</span>的最大值存在且为正数。</p>
<p>这个最大值被称为<em>技术扩张率</em>，用<span class="math notranslate nohighlight">\(\alpha_0\)</span>表示。相应的强度向量<span class="math notranslate nohighlight">\(x_0\)</span>被称为<em>最优强度向量</em>。</p>
<div class="proof definition admonition" id="definition-4">
<p class="admonition-title"><span class="caption-number">定义 33.3 </span></p>
<section class="definition-content" id="proof-content">
<p><span class="math notranslate nohighlight">\((A,B)\)</span> 的经济扩张问题（economic expansion problem, EEP）是要找到一个半正 <span class="math notranslate nohighlight">\(n\)</span> 维向量 <span class="math notranslate nohighlight">\(p&gt;0\)</span> 和一个实数 <span class="math notranslate nohighlight">\(\beta\in\mathbb{R}\)</span>，使其满足</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
    &amp;\min_{\beta} \hspace{2mm} \beta\\
    \text{使得 }\hspace{2mm} &amp; Bp \leq \beta Ap
\end{aligned}
\end{split}\]</div>
</section>
</div><p><a class="reference internal" href="#assumption1">假设 33.1</a> 和 <a class="reference internal" href="#assumption2">假设 33.2</a>意味着存在一个最小值 <span class="math notranslate nohighlight">\(\beta_0&gt;0\)</span>，称为<em>经济扩张率</em>。</p>
<p>相应的价格向量<span class="math notranslate nohighlight">\(p_0\)</span>是<em>最优价格向量</em>。</p>
<p>由于<em>技术扩张</em>问题和<em>经济扩张问题</em>中的目标函数都是线性齐次的，<span class="math notranslate nohighlight">\(x_0\)</span> 和 <span class="math notranslate nohighlight">\(p_0\)</span> 的最优性仅由一个正的比例因子来定义。</p>
<p>为了方便（并强调与零和博弈的密切联系），我们将向量 <span class="math notranslate nohighlight">\(x_0\)</span> 和 <span class="math notranslate nohighlight">\(p_0\)</span> 都归一化为单位长度。</p>
<p>标准对偶性论证（参见 (Gale, 1960) <span id="id12">[<a class="reference internal" href="zreferences.html#id89" title="David Gale. The theory of linear economic models. University of Chicago press, 1989.">Gale, 1989</a>]</span> 中的引理9.4）表明，在<a class="reference internal" href="#assumption1">假设 33.1</a> 和 <a class="reference internal" href="#assumption2">假设 33.2</a>下，<span class="math notranslate nohighlight">\(\beta_0\leq \alpha_0\)</span>。</p>
<p>但要推导出 <span class="math notranslate nohighlight">\(\beta_0\geq \alpha_0\)</span>，<a class="reference internal" href="#assumption1">假设 33.1</a> 和 <a class="reference internal" href="#assumption2">假设 33.2</a>是不够的。</p>
<p>因此，冯·诺依曼 <span id="id13">[<a class="reference internal" href="zreferences.html#id84" title="John von Neumann. Uber ein okonomsiches gleichungssystem und eine verallgemeinering des browerschen fixpunktsatzes. In Erge. Math. Kolloq., volume 8, 73–83. 1937.">von Neumann, 1937</a>]</span> 继续证明了以下连接TEP和EEP的重要“对偶性”结果。</p>
<div class="proof theorem admonition" id="theorem1">
<p class="admonition-title"><span class="caption-number">定理 33.1 </span> (冯·诺依曼)</p>
<section class="theorem-content" id="proof-content">
<p>如果经济体 <span class="math notranslate nohighlight">\((A,B)\)</span> 满足<a class="reference internal" href="#assumption1">假设 33.1</a> 和 <a class="reference internal" href="#assumption2">假设 33.2</a>，则存在 <span class="math notranslate nohighlight">\(\left(\gamma^{*}, x_0, p_0\right)\)</span>，其中 <span class="math notranslate nohighlight">\(\gamma^{*}\in[\beta_0, \alpha_0]\subset\mathbb{R}\)</span>，<span class="math notranslate nohighlight">\(x_0&gt;0\)</span> 是一个 <span class="math notranslate nohighlight">\(m\)</span> 维向量，<span class="math notranslate nohighlight">\(p_0&gt;0\)</span> 是一个 <span class="math notranslate nohighlight">\(n\)</span> 维向量，且以下套利关系成立</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
x_0^\top B &amp;\geq \gamma^{* } x_0^\top A \\
Bp_0 &amp;\leq \gamma^{* } Ap_0 \\
x_0^\top \left(B-\gamma^{* } A\right)p_0 &amp;= 0
\end{aligned}
\end{split}\]</div>
</section>
</div><div class="proof admonition" id="proof">
<p>Proof. （概要）
<a class="reference internal" href="#assumption1">假设 33.1</a> 和 <a class="reference internal" href="#assumption2">假设 33.2</a>意味着存在 <span class="math notranslate nohighlight">\((\alpha_0, x_0)\)</span> 和 <span class="math notranslate nohighlight">\((\beta_0, p_0)\)</span> 分别解决TEP和EEP。</p>
<p>如果 <span class="math notranslate nohighlight">\(\gamma^*&gt;\alpha_0\)</span>，根据 <span class="math notranslate nohighlight">\(\alpha_0\)</span> 的定义，不可能存在半正向量 <span class="math notranslate nohighlight">\(x\)</span> 满足<span class="math notranslate nohighlight">\(x^T B \geq \gamma^{* } x^T A\)</span>。</p>
<p>类似地，如果 <span class="math notranslate nohighlight">\(\gamma^*&lt;\beta_0\)</span>，不存在半正向量 <span class="math notranslate nohighlight">\(p\)</span> 满足 <span class="math notranslate nohighlight">\(Bp \leq \gamma^{* } Ap\)</span>。令 <span class="math notranslate nohighlight">\(\gamma^{* }\in[\beta_0, \alpha_0]\)</span>，则 <span class="math notranslate nohighlight">\(x_0^T B \geq \alpha_0 x_0^T A \geq \gamma^{* } x_0^T A\)</span>。</p>
<p>此外，<span class="math notranslate nohighlight">\(Bp_0\leq \beta_0 A p_0\leq \gamma^* A p_0\)</span>。这两个不等式意味着<span class="math notranslate nohighlight">\(x_0\left(B - \gamma^{* } A\right)p_0 = 0\)</span>。</p>
</div>
<p>这里常数<span class="math notranslate nohighlight">\(\gamma^{*}\)</span>既是扩张因子也是利息因子（但不一定是最优的）。</p>
<p>我们已经遇到并讨论了前两个不等式，它们分别表示可行性条件和无利润条件。</p>
<p>此外，等式<span class="math notranslate nohighlight">\(x_0^T\left(B-\gamma^{* } A\right)p_0 = 0\)</span>简洁地表达了以下要求：如果任何商品的增长率大于<span class="math notranslate nohighlight">\(\gamma^{*}\)</span>（即<em>供过于求</em>），那么其价格必须为零；如果任何生产活动带来负利润，则该活动必须停止。</p>
<p>因此，<a class="reference internal" href="#theorem1">定理 33.1</a>中所述的条件包含了所有均衡条件。</p>
<p>所以<a class="reference internal" href="#theorem1">定理 33.1</a>本质上表明，在<a class="reference internal" href="#assumption1">假设 33.1</a> 和 <a class="reference internal" href="#assumption2">假设 33.2</a>下，总是存在具有平衡增长的均衡 <span class="math notranslate nohighlight">\(\left(\gamma^{*}, x_0, p_0\right)\)</span>。</p>
<p>注意，<a class="reference internal" href="#theorem1">定理 33.1</a>并未说明均衡的唯一性。事实上，它并不排除 <span class="math notranslate nohighlight">\(x_0^TBp_0 = 0\)</span> 的（平凡）情况，即没有产生任何有价值的产出。</p>
<p>为了排除这种无趣的情况，Kemeny、Morgenstern和Thompson <span id="id14">[<a class="reference internal" href="zreferences.html#id87" title="John G Kemeny, Oskar Morgenstern, and Gerald L Thompson. A generalization of the von neumann model of an expanding economy. Econometrica, Journal of the Econometric Society, pages 115–135, 1956.">Kemeny <em>et al.</em>, 1956</a>]</span>增加了一个额外要求</p>
<div class="math notranslate nohighlight">
\[
x^T_0 B p_0 &gt; 0
\]</div>
<p>并将满足该条件的均衡称为<em>经济解</em>。</p>
<p>他们证明，这个额外条件不影响均衡的存在性，同时显著减少了（相关的）解的数量。</p>
</section>
<section id="id15">
<h2><a class="toc-backref" href="#id32" role="doc-backlink"><span class="section-number">33.5. </span>作为零和双人博弈的解释</a><a class="headerlink" href="#id15" title="Link to this heading">#</a></h2>
<p>为了计算均衡 <span class="math notranslate nohighlight">\((\gamma^{*}, x_0, p_0)\)</span>，我们遵循 Hamburger、Thompson 和 Weil (1967) 提出的算法，基于这样一个关键洞察：（伴随平衡增长的）均衡可以看作是一个特殊的双人零和博弈的解。</p>
<p>首先，我们引入一些符号。</p>
<p>考虑 <span class="math notranslate nohighlight">\(m\times n\)</span> 矩阵 <span class="math notranslate nohighlight">\(C\)</span> 作为支付矩阵，其中的元素表示从列玩家（<strong>最小化</strong>方）向行玩家（<strong>最大化</strong>方）支付的收益，并假设玩家可以使用混合策略。因此，</p>
<ul class="simple">
<li><p>行玩家选择 <span class="math notranslate nohighlight">\(m\)</span> 维向量 <span class="math notranslate nohighlight">\(x &gt; \mathbf{0}\)</span>，满足 <span class="math notranslate nohighlight">\(\iota_m^T x = 1\)</span></p></li>
<li><p>列玩家选择 <span class="math notranslate nohighlight">\(n\)</span> 维向量 <span class="math notranslate nohighlight">\(p &gt; \mathbf{0}\)</span>，满足 <span class="math notranslate nohighlight">\(\iota_n^T p = 1\)</span></p></li>
</ul>
<div class="proof definition admonition" id="definition-6">
<p class="admonition-title"><span class="caption-number">定义 33.4 </span></p>
<section class="definition-content" id="proof-content">
<p><span class="math notranslate nohighlight">\(m\times n\)</span> 矩阵博弈 <span class="math notranslate nohighlight">\(C\)</span> 在混合策略中有<em>解</em> <span class="math notranslate nohighlight">\((x^*, p^*, V(C))\)</span>，如果</p>
<div class="math notranslate nohighlight">
\[
\begin{aligned}
(x^* )^\top C e^j \geq V(C)\quad \forall j\in\{1, \dots, n\}\quad \quad
\text{and}\quad\quad (e^i)^\top C p^* \leq V(C)\quad \forall i\in\{1, \dots, m\}
\end{aligned}
\]</div>
<p>数值 <span class="math notranslate nohighlight">\(V(C)\)</span> 被称为博弈的<em>值</em>。</p>
</section>
</div><p>从上述定义可以清楚地看出，值 <span class="math notranslate nohighlight">\(V(C)\)</span> 有两种解释：</p>
<ul class="simple">
<li><p>通过采用适当的混合策略，最大化玩家可以确保至少获得 <span class="math notranslate nohighlight">\(V(C)\)</span>（无论列玩家如何选择）</p></li>
<li><p>通过采用适当的混合策略，最小化玩家可以确保最大化玩家获得的不会超过 <span class="math notranslate nohighlight">\(V(C)\)</span>（无论最大化玩家如何选择）</p></li>
</ul>
<p>Nash (1951) 的一个著名定理告诉我们，任何<em>有限</em>的双人零和博弈总是存在混合策略纳什均衡。</p>
<p>此外，冯·诺依曼的最小最大值定理 <span id="id16">[<a class="reference internal" href="zreferences.html#id85" title="John von Neumann. Zur theorie der gesellschaftsspiele. Mathematische annalen, 100(1):295–320, 1928.">von Neumann, 1928</a>]</span> 表明</p>
<div class="math notranslate nohighlight">
\[
V(C) = \max_x \min_p \hspace{2mm} x^T C p = \min_p \max_x \hspace{2mm} x^T C p = (x^*)^T C p^*
\]</div>
<section id="lp">
<h3><span class="section-number">33.5.1. </span>与线性规划(LP)的联系<a class="headerlink" href="#lp" title="Link to this heading">#</a></h3>
<p>有限双人零和博弈的纳什均衡可以通过解一个线性规划问题得到。</p>
<p>为了说明这一点，我们引入以下符号</p>
<ul class="simple">
<li><p>对于固定的 <span class="math notranslate nohighlight">\(x\)</span>，令 <span class="math notranslate nohighlight">\(v\)</span> 为最小化问题的值：<span class="math notranslate nohighlight">\(v \equiv \min_p x^T C p = \min_j x^T C e^j\)</span></p></li>
<li><p>对于固定的 <span class="math notranslate nohighlight">\(p\)</span>，令 <span class="math notranslate nohighlight">\(u\)</span> 为最大化问题的值：<span class="math notranslate nohighlight">\(u \equiv \max_x x^T C p = \max_i (e^i)^T C p\)</span></p></li>
</ul>
<p>那么，从最大化玩家角度来看的<em>最大最小问题</em>可以写成<em>原始</em>线性规划问题</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
V(C) = &amp; \max \hspace{2mm} v \\
\text{使得 } \hspace{2mm} v \iota_n^T &amp;\leq x^T C  \\
x &amp;\geq \mathbf{0} \\
\iota_n^T x &amp; = 1
\end{aligned}
\end{split}\]</div>
<p>而从最小化玩家角度来看的<em>最小最大问题</em>是<em>对偶</em>线性规划问题</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
V(C) = &amp;\min \hspace{2mm} u \\
\text{使得 } \hspace{2mm}u \iota_m &amp;\geq Cp  \\
p &amp;\geq \mathbf{0} \\
\iota_m^T p &amp; = 1
\end{aligned}
\end{split}\]</div>
<p>Hamburger、Thompson和Weil <span id="id17">[<a class="reference internal" href="zreferences.html#id88" title="Michael J Hamburger, Gerald L Thompson, and Roman L Weil. Computation of expansion rates for the generalized von neumann model of an expanding economy. Econometrica, Journal of the Econometric Society, pages 542–547, 1967.">Hamburger <em>et al.</em>, 1967</a>]</span> 将经济的投入产出对视为双人零和博弈的收益矩阵。</p>
<p>使用这种解释，他们将<a class="reference internal" href="#assumption1">假设 33.1</a> 和 <a class="reference internal" href="#assumption2">假设 33.2</a>重述如下</p>
<div class="math notranslate nohighlight">
\[
V(-A) &lt; 0\quad\quad \text{和}\quad\quad V(B)&gt;0
\]</div>
<div class="proof admonition" id="proof">
<p>Proof. （概要）</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\Rightarrow\)</span> <span class="math notranslate nohighlight">\(V(B)&gt;0\)</span> 意味着<span class="math notranslate nohighlight">\(x_0^T B \gg \mathbf{0}\)</span>，其中 <span class="math notranslate nohighlight">\(x_0\)</span> 是最大化向量。由于 <span class="math notranslate nohighlight">\(B\)</span> 是非负的，这要求 <span class="math notranslate nohighlight">\(B\)</span> 的每一列至少有一个正项，这就是假设I。</p></li>
<li><p><span class="math notranslate nohighlight">\(\Leftarrow\)</span> 从假设I和事实 <span class="math notranslate nohighlight">\(p&gt;\mathbf{0}\)</span> 可知，<span class="math notranslate nohighlight">\(Bp &gt; \mathbf{0}\)</span>。这意味着最大化玩家总能选择 <span class="math notranslate nohighlight">\(x\)</span>
使得 <span class="math notranslate nohighlight">\(x^TBp&gt;0\)</span>，因此必然有<span class="math notranslate nohighlight">\(V(B)&gt;0\)</span>。</p></li>
</ul>
</div>
<p>为了用特定的双人零和博弈重述<a class="reference internal" href="#theorem1">定理 33.1</a>，我们定义一个矩阵，对于 <span class="math notranslate nohighlight">\(\gamma\in\mathbb{R}\)</span></p>
<div class="math notranslate nohighlight">
\[
M(\gamma) \equiv B - \gamma A
\]</div>
<p>对于固定的 <span class="math notranslate nohighlight">\(\gamma\)</span>，将 <span class="math notranslate nohighlight">\(M(\gamma)\)</span> 视为一个矩阵博弈，</p>
<p>计算博弈的解意味着</p>
<ul class="simple">
<li><p>如果 <span class="math notranslate nohighlight">\(\gamma &gt; \alpha_0\)</span>，那么对于所有 <span class="math notranslate nohighlight">\(x&gt;0\)</span>，存在 <span class="math notranslate nohighlight">\(j\in\{1, \dots, n\}\)</span>，使得 <span class="math notranslate nohighlight">\([x^T M(\gamma)]_j &lt; 0\)</span>，这意味着 <span class="math notranslate nohighlight">\(V(M(\gamma)) &lt; 0\)</span>。</p></li>
<li><p>如果 <span class="math notranslate nohighlight">\(\gamma &lt; \beta_0\)</span>，那么对于所有 <span class="math notranslate nohighlight">\(p&gt;0\)</span>，存在 <span class="math notranslate nohighlight">\(i\in\{1, \dots, m\}\)</span>，使得 <span class="math notranslate nohighlight">\([M(\gamma)p]_i &gt; 0\)</span>，这意味着 <span class="math notranslate nohighlight">\(V(M(\gamma)) &gt; 0\)</span>。</p></li>
<li><p>如果 <span class="math notranslate nohighlight">\(\gamma \in \{\beta_0, \alpha_0\}\)</span>，那么（根据<a class="reference internal" href="#theorem1">定理 33.1</a>）最优强度和价格向量 <span class="math notranslate nohighlight">\(x_0\)</span> 和 <span class="math notranslate nohighlight">\(p_0\)</span> 满足
$<span class="math notranslate nohighlight">\(
x_0^T M(\gamma) \geq \mathbf{0}^T \quad \quad \text{和}\quad\quad M(\gamma) p_0 \leq \mathbf{0}
\)</span>$</p></li>
</ul>
<p>也就是说，<span class="math notranslate nohighlight">\((x_0, p_0, 0)\)</span> 是博弈 <span class="math notranslate nohighlight">\(M(\gamma)\)</span> 的解，因此 <span class="math notranslate nohighlight">\(V\left(M(\beta_0)\right) = V\left(M(\alpha_0)\right) = 0\)</span>。</p>
<ul class="simple">
<li><p>如果 <span class="math notranslate nohighlight">\(\beta_0 &lt; \alpha_0\)</span> 且 <span class="math notranslate nohighlight">\(\gamma \in (\beta_0, \alpha_0)\)</span>，那么 <span class="math notranslate nohighlight">\(V(M(\gamma)) = 0\)</span>。</p></li>
</ul>
<p>此外，如果 <span class="math notranslate nohighlight">\(x'\)</span> 是在 <span class="math notranslate nohighlight">\(\gamma'\in(\beta_0, \alpha_0)\)</span> 时博弈 <span class="math notranslate nohighlight">\(M(\gamma')\)</span> 中最大化玩家的最优策略且 <span class="math notranslate nohighlight">\(p''\)</span> 对于 <span class="math notranslate nohighlight">\(M(\gamma'')\)</span> 中的最小化玩家来说是最优的，其中 <span class="math notranslate nohighlight">\(\gamma''\in(\beta_0, \gamma')\)</span>，那么 <span class="math notranslate nohighlight">\((x', p'', 0)\)</span> 对于所有 <span class="math notranslate nohighlight">\(\gamma\in (\gamma'', \gamma')\)</span> 都是 <span class="math notranslate nohighlight">\(M(\gamma)\)</span> 的解。</p>
<div class="proof admonition" id="proof">
<p>Proof. （概要）
如果 <span class="math notranslate nohighlight">\(x'\)</span> 对于游戏 <span class="math notranslate nohighlight">\(M(\gamma')\)</span> 中的最大化玩家是最优的，那么 <span class="math notranslate nohighlight">\((x')^T M(\gamma')\geq \mathbf{0}^T\)</span>，因此对于所有 <span class="math notranslate nohighlight">\(\gamma&lt;\gamma'\)</span>，</p>
<div class="math notranslate nohighlight">
\[
(x')^T M(\gamma) = (x')^T M(\gamma') + (x')^T(\gamma' - \gamma)A \geq \mathbf{0}^T
\]</div>
<p>因此 <span class="math notranslate nohighlight">\(V(M(\gamma))\geq 0\)</span>。如果 <span class="math notranslate nohighlight">\(p''\)</span> 对于游戏 <span class="math notranslate nohighlight">\(M(\gamma'')\)</span> 中的最小化玩家是最优的，那么 <span class="math notranslate nohighlight">\(M(\gamma)p \leq \mathbf{0}\)</span>，因此对于所有 <span class="math notranslate nohighlight">\(\gamma''&lt;\gamma\)</span>：</p>
<div class="math notranslate nohighlight">
\[
M(\gamma)p'' = M(\gamma'') + (\gamma'' - \gamma)Ap'' \leq \mathbf{0}
\]</div>
<p>因此 <span class="math notranslate nohighlight">\(V(M(\gamma))\leq 0\)</span>。</p>
</div>
<p>从上述论证中可以清楚地看出，<span class="math notranslate nohighlight">\(\beta_0\)</span>、<span class="math notranslate nohighlight">\(\alpha_0\)</span> 是使得 <span class="math notranslate nohighlight">\(V(M(\gamma))=0\)</span> 的最小和最大的 <span class="math notranslate nohighlight">\(\gamma\)</span> 值。</p>
<p>此外，Hamburger等人<span id="id18">[<a class="reference internal" href="zreferences.html#id88" title="Michael J Hamburger, Gerald L Thompson, and Roman L Weil. Computation of expansion rates for the generalized von neumann model of an expanding economy. Econometrica, Journal of the Econometric Society, pages 542–547, 1967.">Hamburger <em>et al.</em>, 1967</a>]</span>证明了函数 <span class="math notranslate nohighlight">\(\gamma \mapsto V(M(\gamma))\)</span> 是连续的且关于 <span class="math notranslate nohighlight">\(\gamma\)</span> 单调递减的。</p>
<p>这启发了一种算法来计算给定投入-产出对 <span class="math notranslate nohighlight">\((A, B)\)</span> 的 <span class="math notranslate nohighlight">\((\alpha_0, x_0)\)</span> 和 <span class="math notranslate nohighlight">\((\beta_0, p_0)\)</span>。</p>
</section>
<section id="id19">
<h3><span class="section-number">33.5.2. </span>算法<a class="headerlink" href="#id19" title="Link to this heading">#</a></h3>
<p>Hamburger、Thompson和Weil <span id="id20">[<a class="reference internal" href="zreferences.html#id88" title="Michael J Hamburger, Gerald L Thompson, and Roman L Weil. Computation of expansion rates for the generalized von neumann model of an expanding economy. Econometrica, Journal of the Econometric Society, pages 542–547, 1967.">Hamburger <em>et al.</em>, 1967</a>]</span>提出了一个简单的二分算法来找到函数 <span class="math notranslate nohighlight">\(\gamma \mapsto V(M(\gamma))\)</span> 的最小和最大根（即<span class="math notranslate nohighlight">\(\beta_0\)</span>和<span class="math notranslate nohighlight">\(\alpha_0\)</span>）。</p>
<section id="id21">
<h4><span class="section-number">33.5.2.1. </span>第1步<a class="headerlink" href="#id21" title="Link to this heading">#</a></h4>
<p>首先，注意到我们可以很容易地为 <span class="math notranslate nohighlight">\(\alpha_0\)</span> 和 <span class="math notranslate nohighlight">\(\beta_0\)</span> 找到平凡的上下界。</p>
<ul class="simple">
<li><p>TEP要求 <span class="math notranslate nohighlight">\(x^T(B-\alpha A)\geq \mathbf{0}^T\)</span> 且 <span class="math notranslate nohighlight">\(x &gt; \mathbf{0}\)</span>，所以如果 <span class="math notranslate nohighlight">\(\alpha\)</span> 大到使得 <span class="math notranslate nohighlight">\(\max_i\{[(B-\alpha A)\iota_n]_i\} &lt; 0\)</span>，那么TEP将不再有解。</p></li>
</ul>
<p>相应地，令 <strong><code class="docutils literal notranslate"><span class="pre">UB</span></code></strong> 为满足 <span class="math notranslate nohighlight">\(\max_i\{[(B-\alpha^{*} A)\iota_n]_i\} = 0\)</span> 的 <span class="math notranslate nohighlight">\(\alpha^{*}\)</span>。</p>
<ul class="simple">
<li><p>类似于上界，如果 <span class="math notranslate nohighlight">\(\beta\)</span> 低到使得 <span class="math notranslate nohighlight">\(\min_j\{[\iota^T_m(B-\beta A)]_j\}&gt;0\)</span>，那么EEP将没有解。因此我们可以定义 <strong><code class="docutils literal notranslate"><span class="pre">LB</span></code></strong> 为满足 <span class="math notranslate nohighlight">\(\min_j\{[\iota^T_m(B-\beta^{*} A)]_j\}=0\)</span> 的 <span class="math notranslate nohighlight">\(\beta^{*}\)</span>。</p></li>
</ul>
<p><em>bounds</em> 方法为我们计算了这些平凡的上下界。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n1</span><span class="o">.</span><span class="n">bounds</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(1.0, 2.0)
</pre></div>
</div>
</div>
</div>
</section>
<section id="id22">
<h4><span class="section-number">33.5.2.2. </span>第2步<a class="headerlink" href="#id22" title="Link to this heading">#</a></h4>
<p>计算 <span class="math notranslate nohighlight">\(\alpha_0\)</span> 和 <span class="math notranslate nohighlight">\(\beta_0\)</span></p>
<ul class="simple">
<li><p>求解 <span class="math notranslate nohighlight">\(\alpha_0\)</span></p>
<ol class="arabic simple">
<li><p>固定 <span class="math notranslate nohighlight">\(\gamma = \frac{UB + LB}{2}\)</span> 并计算与 <span class="math notranslate nohighlight">\(M(\gamma)\)</span>
相关的双人零和博弈的解。我们可以使用原始或对偶线性规划问题。</p></li>
<li><p>如果 <span class="math notranslate nohighlight">\(V(M(\gamma)) \geq 0\)</span>，则令 <span class="math notranslate nohighlight">\(LB = \gamma\)</span>，
否则令 <span class="math notranslate nohighlight">\(UB = \gamma\)</span>。</p></li>
<li><p>重复步骤1和2，直到 <span class="math notranslate nohighlight">\(|UB - LB| &lt; \epsilon\)</span>。</p></li>
</ol>
</li>
<li><p>求解 <span class="math notranslate nohighlight">\(\beta_0\)</span></p>
<ol class="arabic simple">
<li><p>固定 <span class="math notranslate nohighlight">\(\gamma = \frac{UB + LB}{2}\)</span> 并计算与 <span class="math notranslate nohighlight">\(M(\gamma)\)</span>
相关的双人零和博弈的解。我们可以使用原始或对偶
线性规划问题。</p></li>
<li><p>如果 <span class="math notranslate nohighlight">\(V(M(\gamma)) &gt; 0\)</span>，则令 <span class="math notranslate nohighlight">\(LB = \gamma\)</span>，
否则令 <span class="math notranslate nohighlight">\(UB = \gamma\)</span>。</p></li>
<li><p>重复步骤1和2，直到 <span class="math notranslate nohighlight">\(|UB - LB| &lt; \epsilon\)</span>。</p></li>
</ol>
</li>
<li><p><em>存在性</em>：由于 <span class="math notranslate nohighlight">\(V(M(LB))&gt;0\)</span> 且 <span class="math notranslate nohighlight">\(V(M(UB))&lt;0\)</span>，并且
<span class="math notranslate nohighlight">\(V(M(\cdot))\)</span> 是连续的非增函数，因此在
<span class="math notranslate nohighlight">\([LB, UB]\)</span> 区间内至少存在一个 <span class="math notranslate nohighlight">\(\gamma\)</span>，使得 <span class="math notranslate nohighlight">\(V(M(\gamma))=0\)</span>。</p></li>
</ul>
<p><em>zerosum</em>方法会计算给定 <span class="math notranslate nohighlight">\(\gamma\)</span> 时的博弈值和最优策略。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">γ</span> <span class="o">=</span> <span class="mi">2</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;博弈在 γ = </span><span class="si">{</span><span class="n">γ</span><span class="si">}</span><span class="s1"> 时的值&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">n1</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">γ</span><span class="o">=</span><span class="n">γ</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;强度向量（来自原问题）&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">n1</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">γ</span><span class="o">=</span><span class="n">γ</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;价格向量（来自对偶问题）&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">n1</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">γ</span><span class="o">=</span><span class="n">γ</span><span class="p">,</span> <span class="n">dual</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>博弈在 γ = 2 时的值
-0.24
强度向量（来自原问题）
[0.32 0.28 0.4 ]
价格向量（来自对偶问题）
[0.4  0.32 0.28 0.  ]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">numb_grid</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">γ_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">,</span> <span class="n">numb_grid</span><span class="p">)</span>

<span class="n">value_ex1_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">n1</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">γ</span><span class="o">=</span><span class="n">γ_grid</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numb_grid</span><span class="p">)])</span>
<span class="n">value_ex2_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">n2</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">γ</span><span class="o">=</span><span class="n">γ_grid</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numb_grid</span><span class="p">)])</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;函数 $V(M(\gamma))$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="p">(</span><span class="n">value_ex1_grid</span><span class="p">,</span> <span class="n">value_ex2_grid</span><span class="p">),</span>
                          <span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">γ_grid</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;示例 </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">xlabel</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$\gamma$&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">bounds</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;下界&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">bounds</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;上界&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/9896ff379a2d316e638f0988db2b3deefdac3dc181eb2594a360d08e00287d39.png" src="_images/9896ff379a2d316e638f0988db2b3deefdac3dc181eb2594a360d08e00287d39.png" />
</div>
</div>
<p><em>expansion</em>方法使用二分算法求解 <span class="math notranslate nohighlight">\(\alpha_0\)</span>（并使用原始线性规划问题求解 <span class="math notranslate nohighlight">\(x_0\)</span>）</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">α_0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">n1</span><span class="o">.</span><span class="n">expansion</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;α_0 = </span><span class="si">{</span><span class="n">α_0</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;x_0 = </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;对偶问题得到的相应p值 = </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>α_0 = 1.2599210478365421
x_0 = [0.33 0.26 0.41]
对偶问题得到的相应p值 = [0.41 0.33 0.26 0.  ]
</pre></div>
</div>
</div>
</div>
<p><em>interest</em> 方法使用二分算法求解 <span class="math notranslate nohighlight">\(\beta_0\)</span> (并使用对偶线性规划问题求解 <span class="math notranslate nohighlight">\(p_0\)</span>)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">β_0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">n1</span><span class="o">.</span><span class="n">interest</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;β_0 = </span><span class="si">{</span><span class="n">β_0</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;p_0 = </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The corresponding x from the primal = </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>β_0 = 1.2599210478365421
p_0 = [0.41 0.33 0.26 0.  ]
The corresponding x from the primal = [0.33 0.26 0.41]
</pre></div>
</div>
</div>
</div>
<p>当然，当 <span class="math notranslate nohighlight">\(\gamma^*\)</span> 唯一时，我们使用哪种方法都无所谓 —— 两种方法都可行。</p>
<p>特别是，如下所示，在 <span class="math notranslate nohighlight">\((A,B)\)</span> 不可约的情况下（如例1），<span class="math notranslate nohighlight">\(V(M(\gamma))\)</span> 的最大根和最小根必然相同，这意味着一个“完全对偶”的结果 ，即 <span class="math notranslate nohighlight">\(\alpha_0 = \beta_0 = \gamma^*\)</span>，因此扩张（和利息）率 <span class="math notranslate nohighlight">\(\gamma^*\)</span> 是唯一的。</p>
</section>
</section>
<section id="id23">
<h3><span class="section-number">33.5.3. </span>唯一性和不可约性<a class="headerlink" href="#id23" title="Link to this heading">#</a></h3>
<p>作为说明，让我们首先计算例2中可约投入-产出对 <span class="math notranslate nohighlight">\((A, B)\)</span> 的 <span class="math notranslate nohighlight">\(V(M(\cdot))\)</span> 的最大根和最小根</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">α_0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">n2</span><span class="o">.</span><span class="n">expansion</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;α_0 = </span><span class="si">{</span><span class="n">α_0</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;x_0 = </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The corresponding p from the dual = </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>α_0 = 1.259921052493155
x_0 = [5.27e-10 0.00e+00 3.27e-01 2.60e-01 4.13e-01]
The corresponding p from the dual = [0.   0.21 0.33 0.26 0.21 0.  ]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">β_0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">n2</span><span class="o">.</span><span class="n">interest</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;β_0 = </span><span class="si">{</span><span class="n">β_0</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;p_0 = </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;对偶问题得到的原问题解为 = </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>β_0 = 1.0000000009313226
p_0 = [ 5.00e-01  5.00e-01 -1.55e-09 -1.24e-09 -9.31e-10  0.00e+00]
对偶问题得到的原问题解为 = [-0.    0.    0.25  0.25  0.5 ]
</pre></div>
</div>
</div>
</div>
<p>如我们所见，当<span class="math notranslate nohighlight">\((A,B)\)</span>可约时，二分法算法找到的根可能不同，因此可能存在多个使得博弈<span class="math notranslate nohighlight">\(M(\gamma^*)\)</span>的值为零的 <span class="math notranslate nohighlight">\(\gamma^*\)</span>（见上图）。</p>
<p>事实上，虽然冯·诺依曼定理保证了均衡的存在性，但假设I和II并不足以保证唯一性。尽管如此，Kemeny等人(1967)证明了经济解的数量至多是有限的，这意味着只有有限个 <span class="math notranslate nohighlight">\(\gamma^*\)</span> 满足 <span class="math notranslate nohighlight">\(V(M(\gamma^*)) = 0\)</span> 和 <span class="math notranslate nohighlight">\(x_0^TBp_0 &gt; 0\)</span>，并且对于每个这样的 <span class="math notranslate nohighlight">\(\gamma^*_i\)</span>，都存在一个经济体的自包含部分（子经济体），在均衡状态下可以以扩张系数 <span class="math notranslate nohighlight">\(\gamma^*_i\)</span> 独立扩张。</p>
<p>以下定理（参见Gale <span id="id24">[<a class="reference internal" href="zreferences.html#id89" title="David Gale. The theory of linear economic models. University of Chicago press, 1989.">Gale, 1989</a>]</span>中的定理9.10）断言，施加不可约性条件足以保证 <span class="math notranslate nohighlight">\((\gamma^*, x_0, p_0)\)</span> 的唯一性。</p>
<div class="proof theorem admonition" id="theorem2">
<p class="admonition-title"><span class="caption-number">定理 33.2 </span></p>
<section class="theorem-content" id="proof-content">
<p>采用<a class="reference internal" href="#theorem1">定理 33.1</a>的条件。如果经济体 <span class="math notranslate nohighlight">\((A,B)\)</span> 不可约，则 <span class="math notranslate nohighlight">\(\gamma^*=\alpha_0=\beta_0\)</span>。</p>
</section>
</div></section>
<section id="id25">
<h3><span class="section-number">33.5.4. </span>特殊情况<a class="headerlink" href="#id25" title="Link to this heading">#</a></h3>
<p>有一种特殊的 <span class="math notranslate nohighlight">\((A,B)\)</span> 允许我们通过引用非负矩阵的 Perron-Frobenius 定理来显著简化求解方法。</p>
<div class="proof definition admonition" id="definition-8">
<p class="admonition-title"><span class="caption-number">定义 33.5 </span></p>
<section class="definition-content" id="proof-content">
<p>如果一个经济体满足以下条件，我们称之为<em>简单</em>的：</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(n=m\)</span></p></li>
<li><p>每个生产活动恰好生产一种商品</p></li>
<li><p>每种商品恰好由一个生产活动生产</p></li>
</ul>
</section>
</div><p>这些假设意味着 <span class="math notranslate nohighlight">\(B=I_n\)</span>，即 <span class="math notranslate nohighlight">\(B\)</span> 可以写成单位矩阵（可能需要重新排列其行和列）。</p>
<p>简单模型具有以下特殊性质（参见Gale <span id="id26">[<a class="reference internal" href="zreferences.html#id89" title="David Gale. The theory of linear economic models. University of Chicago press, 1989.">Gale, 1989</a>]</span> 中的定理 9.11）：如果 <span class="math notranslate nohighlight">\(x_0\)</span> 和 <span class="math notranslate nohighlight">\(\alpha_0&gt;0\)</span> 是 <span class="math notranslate nohighlight">\((A,I_n)\)</span> 的 TEP 的解，那么</p>
<div class="math notranslate nohighlight">
\[
x_0^T = \alpha_0 x_0^T A\hspace{1cm}\Leftrightarrow\hspace{1cm}x_0^T
A=\left(\frac{1}{\alpha_0}\right)x_0^T
\]</div>
<p>后者表明 <span class="math notranslate nohighlight">\(1/\alpha_0\)</span> 是 <span class="math notranslate nohighlight">\(A\)</span> 的一个正特征值，而 <span class="math notranslate nohighlight">\(x_0\)</span> 是相应的非负左特征向量。</p>
<p><strong>Perron和Frobenius</strong>的经典结果表明：任意非负矩阵都存在一个非负的特征值–特征向量对。</p>
<p>此外，如果 <span class="math notranslate nohighlight">\(A\)</span> 是不可约的，则最优强度向量 <span class="math notranslate nohighlight">\(x_0\)</span> 是正的，并且除了一个正的比例因子之外是唯一的。</p>
<p>假设 <span class="math notranslate nohighlight">\(A\)</span> 是可约的，具有 <span class="math notranslate nohighlight">\(k\)</span> 个不可约子集 <span class="math notranslate nohighlight">\(S_1,\dots,S_k\)</span>。令 <span class="math notranslate nohighlight">\(A_i\)</span> 为对应于 <span class="math notranslate nohighlight">\(S_i\)</span> 的子矩阵，令 <span class="math notranslate nohighlight">\(\alpha_i\)</span> 和 <span class="math notranslate nohighlight">\(\beta_i\)</span> 分别为相关的扩张因子和利息因子，那么我们有</p>
<div class="math notranslate nohighlight">
\[
\alpha_0 = \max_i \{\alpha_i\}\hspace{1cm}\text{和}\hspace{1cm}\beta_0 = \min_i \{\beta_i\}
\]</div>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                    </div>
                    
                </main> <!-- .page__content -->
                


                <footer class="qe-page__footer">

                    <p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><img src="https://licensebuttons.net/l/by-sa/4.0/80x15.png"></a></p>

                    <p>Creative Commons License &ndash; This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International.</p>

                    <p>A theme by <a href="https://quantecon.org">QuantEcon</a></p>

                </footer> <!-- .page__footer -->

            </div> <!-- .page -->

            

            
            <div class="qe-sidebar bd-sidebar inactive" id="site-navigation">

                <div class="qe-sidebar__header">


                    Contents

                </div>

                <nav class="qe-sidebar__nav" id="qe-sidebar-nav" aria-label="Main navigation">
                    <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  基础工具
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="sir_model.html">
   1. 新冠病毒建模
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="linear_algebra.html">
   2. 线性代数
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="qr_decomp.html">
   3. QR分解
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="eig_circulant.html">
   4. 循环矩阵
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="svd_intro.html">
   5. 奇异值分解
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="var_dmd.html">
   6. 向量自回归和动态模态分解
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="newton_method.html">
   7. 使用牛顿法求解经济模型
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  基础统计学
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="prob_matrix.html">
   8. 基础概率论与矩阵
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="stats_examples.html">
   9. 一些概率分布
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lln_clt.html">
   10. 大数定律 和 中心极限定理
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="prob_meaning.html">
   11. 概率的两种含义
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="multi_hyper.html">
   12. 多元超几何分布
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="multivariate_normal.html">
   13. 多元正态分布
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="hoist_failure.html">
   14. 故障树不确定性
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="back_prop.html">
   15. 人工神经网络简介
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="rand_resp.html">
   16. 随机化回应调查
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="util_rand_resp.html">
   17. 随机回答的期望效用
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  贝叶斯定律
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="bayes_nonconj.html">
   18. 非共轭先验
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ar1_bayes.html">
   19. AR(1)参数的后验分布
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ar1_turningpts.html">
   20. 预测 AR(1) 过程
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  统计与信息论
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="divergence_measures.html">
   21. 统计散度度量
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="likelihood_ratio_process.html">
   22. 似然比过程
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="likelihood_ratio_process_2.html">
   23. 异质信念与金融市场
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="likelihood_var.html">
   24. VAR模型的似然过程
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="imp_sample.html">
   25. 似然比过程的均值
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="wald_friedman.html">
   26. 让弥尔顿·弗里德曼困惑的问题
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="wald_friedman_2.html">
   27. 用贝叶斯方法解决弗里德曼和瓦尔德问题
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="exchangeable.html">
   28. 可交换性和贝叶斯更新
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="likelihood_bayes.html">
   29. 似然比过程和贝叶斯学习
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mix_model.html">
   30. 错误模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="navy_captain.html">
   31. 贝叶斯与频率主义决策规则的比较
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  线性规划
 </span>
</p>
<ul class="current nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="opt_transport.html">
   32. 最优传输
  </a>
 </li>
 <li class="toctree-l1 current active active">
  <a class="current reference internal" href="#">
   33. 冯·诺依曼增长模型（及其推广）
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  动态系统导论
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="finite_markov.html">
   34. 有限马尔可夫链
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="inventory_dynamics.html">
   35. 库存动态
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="linear_models.html">
   36. 线性状态空间模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="samuelson.html">
   37. 萨缪尔森乘数-加速器模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="kesten_processes.html">
   38. Kesten过程与企业动态
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="wealth_dynamics.html">
   39. 财富分布动态
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="kalman.html">
   40. 初见卡尔曼滤波器
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="kalman_2.html">
   41. 卡尔曼滤波器进阶
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  搜索
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="mccall_model.html">
   42. 工作搜寻 I: McCall搜寻模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mccall_model_with_separation.html">
   43. 工作搜寻 II：搜寻与离职
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mccall_fitted_vfi.html">
   44. 工作搜寻 III: 拟合值函数迭代
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mccall_correlated.html">
   45. 工作搜寻 IV：相关工资报价
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="career.html">
   46. 工作搜寻 V：职业选择建模
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="jv.html">
   47. 工作搜寻 VI：在职搜索
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mccall_q.html">
   48. 工作搜寻 VII：McCall劳动者的Q学习
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="odu.html">
   49. 工作搜寻 VII: 带学习的搜索
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  消费、储蓄与资本
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="cass_koopmans_1.html">
   50. Cass-Koopmans模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cass_koopmans_2.html">
   51. Cass-Koopmans竞争均衡
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cass_fiscal.html">
   52. 带扭曲性税收的Cass-Koopmans模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cass_fiscal_2.html">
   53. 带扭曲性税收的双国模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ak2.html">
   54. 代际交叠模型中的转型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cake_eating_problem.html">
   55. 吃蛋糕问题 I：最优储蓄导论
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cake_eating_numerical.html">
   56. 吃蛋糕问题 II：数值方法
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="optgrowth.html">
   57. 最优增长 I：随机最优增长模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="optgrowth_fast.html">
   58. 最优增长 II：使用Numba加速代码
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="coleman_policy_iter.html">
   59. 最优增长 III：时间迭代
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="egm_policy_iter.html">
   60. 最优增长 IV：内生网格法
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ifp.html">
   61. 收入波动问题 I：基本模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ifp_advanced.html">
   62. 收入波动问题 II：资产随机收益
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  LQ控制
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="lqcontrol.html">
   63. LQ控制：基础
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lagrangian_lqdp.html">
   64. LQ控制的拉格朗日方法
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cross_product_trick.html">
   65. 消除交叉项
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="perm_income.html">
   66. 永久收入模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="perm_income_cons.html">
   67. 永久收入 II：线性二次方法
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lq_inventories.html">
   68. 通过库存实现生产平滑
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  多主体模型
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="lake_model.html">
   69. 就业与失业的湖泊模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="rational_expectations.html">
   70. 理性预期均衡
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="re_with_feedback.html">
   71. 线性理性预期模型中的稳定性
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="markov_perf.html">
   72. 马尔可夫完美均衡
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="uncertainty_traps.html">
   73. 不确定性陷阱
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="aiyagari.html">
   74. 艾亚加里模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ak_aiyagari.html">
   75. 长寿、异质性个体、世代交叠模型
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  资产定价与金融
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="markov_asset.html">
   76. 资产定价：有限状态模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ge_arrow.html">
   77. 带有阿罗证券的竞争均衡
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="harrison_kreps.html">
   78. 异质信念与泡沫
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  数据与实证
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="pandas_panel.html">
   79. 用Pandas处理面板数据
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ols.html">
   80. Python线性回归
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mle.html">
   81. 最大似然估计
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  拍卖
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="two_auctions.html">
   82. 一价和二价拍卖
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="house_auction.html">
   83. 多种商品分配机制
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  其他
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="troubleshooting.html">
   84. 故障排除
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="zreferences.html">
   85. 参考文献
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="status.html">
   86. 执行统计
  </a>
 </li>
</ul>

                </nav>

                <div class="qe-sidebar__footer">

                </div>

            </div> <!-- .sidebar -->
            
        </div> <!-- .main -->

        <div class="qe-toolbar">

            <div class="qe-toolbar__inner">

                <ul class="qe-toolbar__main">
                    <li data-tippy-content="Table of Contents" class="btn__sidebar"><i data-feather="menu"></i></li>
                    <li data-tippy-content="Home"><a href="intro.html"><i data-feather="home"></i></a></li>
                    <li class="btn__qelogo"><a href="https://quantecon.org" title=""><span class="show-for-sr">QuantEcon</span></a></li>
                </ul>

                <ul class="qe-toolbar__links">
                    <li class="btn__search">
                        <form action="search.html" method="get">
                            <input type="search" class="form-control" name="q" id="search-input" placeholder="Search..." aria-label="Search..." autocomplete="off" accesskey="k">
                            <i data-feather="search" id="search-icon"></i>
                        </form>
                    </li>
                    <li data-tippy-content="Fullscreen" class="btn__fullscreen"><i data-feather="maximize"></i></li>
                    <li data-tippy-content="Increase font size" class="btn__plus"><i data-feather="plus-circle"></i></li>
                    <li data-tippy-content="Decrease font size" class="btn__minus"><i data-feather="minus-circle"></i></li>
                    <li data-tippy-content="Change contrast" class="btn__contrast"><i data-feather="sunset"></i></li>
                    <li data-tippy-content="Download Notebook"><a href="/_notebooks/von_neumann_model.ipynb" download><i data-feather="download-cloud"></i></a></li>
                    <li class="settings-button" id="settingsButton"><div data-tippy-content="Launch Notebook"><i data-feather="play-circle"></i></div></li>
                        <li data-tippy-content="Download PDF" onClick="window.print()"><i data-feather="file"></i></li>
                    <!--
                    # Enable if looking for link to specific document hosted on GitHub
                    <li data-tippy-content="View Source"><a target="_blank" href="https://github.com/QuantEcon/lecture-python.myst/von_neumann_model.md" download><i data-feather="github"></i></a></li>
                    -->
                    <li data-tippy-content="View Source"><a target="_blank" href="https://github.com/QuantEcon/lecture-python.myst" download><i data-feather="github"></i></a></li>
                </ul>

            </div>

        </div> <!-- .toolbar -->
        <div id="downloadPDFModal" style="display: none;">
            <ul class="pdf-options" style="display: block;">
                <li class="download-pdf-book" onClick="window.print()">
                    <p>Lecture (PDF)</p>
                </li>
                <li class="download-pdf-file">
                    <a href="" download><p>Book (PDF)</p></a>
                </li>
            </ul>
        </div>
        <div id="settingsModal" style="display: none;">
            <p class="modal-title"> Notebook Launcher </p>
            <div class="modal-desc">
            <p>
                Choose public or private cloud service for "Launch" button.
            </p>
            </div>
            <p class="modal-subtitle">Select a server</p>
            <ul class="modal-servers">
            <li class="active launcher-public">
                <span class="label">Public</span>
                <select id="launcher-public-input">
                
                    <option value="https://colab.research.google.com/github/QuantEcon/lecture-python.zh-cn.notebooks/blob/main/von_neumann_model.ipynb">Colab</option>
                
                </select>
                <i class="fas fa-check-circle"></i>
            </li>
            <li class="launcher-private">
                <span class="label">Private</span>
                <input type="text" id="launcher-private-input" data-repourl="https://github.com/QuantEcon/lecture-python.zh-cn.notebooks" data-urlpath="tree/lecture-python.zh-cn.notebooks/von_neumann_model.ipynb" data-branch=main>
                <i class="fas fa-check-circle"></i>
            </li>
            </ul>
            <p class="launch"><a href="https://colab.research.google.com/github/QuantEcon/lecture-python.zh-cn.notebooks/blob/main/von_neumann_model.ipynb" id="advancedLaunchButton" target="_blank">Launch Notebook</a></p>
            <script>
                // QuantEcon Notebook Launcher
                const launcherTypeElements = document.querySelectorAll('#settingsModal .modal-servers li');
                // Highlight the server type if previous selection exists
                if (typeof localStorage.launcherType !== 'undefined') {
                  for (var i = 0; i < launcherTypeElements.length; i++) {
                    launcherTypeElements[i].classList.remove('active');
                    if ( launcherTypeElements[i].classList.contains(localStorage.launcherType) ) {
                      launcherTypeElements[i].classList.add('active');
                    }
                  }
                }
                // Highlight server type on click and set local storage value
                for (var i = 0; i < launcherTypeElements.length; i++) {
                  launcherTypeElements[i].addEventListener('click', function() {
                    for (var j = 0; j < launcherTypeElements.length; j++) {
                      launcherTypeElements[j].classList.remove('active');
                    }
                    this.classList.add('active');
                    if ( this.classList.contains('launcher-private') ) {
                      localStorage.launcherType = 'launcher-private';
                    } else if ( this.classList.contains('launcher-public') ) {
                      localStorage.launcherType = 'launcher-public';
                    }
                    setLaunchServer();
                  })
                }
                const launcherPublic = document.getElementById('launcher-public-input');
                const launcherPrivate = document.getElementById('launcher-private-input');
                const pageName = "von_neumann_model";
                const repoURL = "https://github.com/QuantEcon/lecture-python.zh-cn.notebooks";
                const urlPath = "tree/lecture-python.zh-cn.notebooks/von_neumann_model.ipynb";
                const branch = "main"
                const launchNotebookLink = document.getElementById('advancedLaunchButton');

                // Highlight public server option if previous selection exists
                if (typeof localStorage.launcherPublic !== 'undefined') {
                  launcherPublic.value = localStorage.launcherPublic;
                }
                // Update local storage upon public server selection
                launcherPublic.addEventListener('change', (event) => {
                  setLaunchServer();
                });
                // Populate private server input if previous entry exists
                if (typeof localStorage.launcherPrivate !== 'undefined') {
                  launcherPrivate.value = localStorage.launcherPrivate;
                }
                // Update local storage when a private server is entered
                launcherPrivate.addEventListener('input', (event) => {
                  setLaunchServer();
                });

                // Function to update the "Launch Notebook" link href
                function setLaunchServer() {
                  launchNotebookLink.removeAttribute("style")
                  if ( localStorage.launcherType == 'launcher-private' ) {
                    let repoPrefix = "/user-redirect/git-pull?repo=" + repoURL + "&branch=" + branch + "&urlpath=" + urlPath;
                    launcherPrivateValue = launcherPrivate.value
                    if (!launcherPrivateValue) {
                        launchNotebookLink.removeAttribute("href")
                        launchNotebookLink.style.background = "grey"
                        return
                    }
                    localStorage.launcherPrivate = launcherPrivateValue;
                    privateServer = localStorage.launcherPrivate.replace(/\/$/, "")
                    if (!privateServer.includes("http")) {
                        privateServer = "http://" + privateServer
                    }
                    launchNotebookLinkURL = privateServer + repoPrefix;
                  } else if ( localStorage.launcherType == 'launcher-public' ) {
                    launcherPublicValue = launcherPublic.options[launcherPublic.selectedIndex].value;
                    localStorage.launcherPublic = launcherPublicValue;
                    launchNotebookLinkURL = localStorage.launcherPublic;
                  }
                  if (launchNotebookLinkURL) launchNotebookLink.href = launchNotebookLinkURL;
                }
                // Check if user has previously selected a server
                if ( (typeof localStorage.launcherPrivate !== 'undefined') || (typeof localStorage.launcherPublic !== 'undefined') ) {
                  setLaunchServer();
                }
                </script>

        </div>

    </div> <!-- .wrapper-->
  </body>
</html>