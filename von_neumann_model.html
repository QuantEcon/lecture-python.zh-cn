

<!DOCTYPE html>


<html lang="en" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>18. 冯·诺依曼增长模型（及其推广） &#8212; Python中级数量经济学</title>
    <script src="https://unpkg.com/@popperjs/core@2.9.2/dist/umd/popper.min.js"></script>
    <script src="https://unpkg.com/tippy.js@6.3.1/dist/tippy-bundle.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
    
        <script>
            MathJax = {
            loader: {load: ['[tex]/boldsymbol', '[tex]/textmacros']},
            tex: {
                packages: {'[+]': ['boldsymbol', 'textmacros']},
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                processEscapes: true,
                macros: {
                    "argmax" : "arg\\,max",
                    "argmin" : "arg\\,min",
                    "col"    : "col",
                    "Span"   :  "span",
                    "epsilon": "\\varepsilon",
                    "EE": "\\mathbb{E}",
                    "PP": "\\mathbb{P}",
                    "RR": "\\mathbb{R}",
                    "NN": "\\mathbb{N}",
                    "ZZ": "\\mathbb{Z}",
                    "aA": "\\mathcal{A}",
                    "bB": "\\mathcal{B}",
                    "cC": "\\mathcal{C}",
                    "dD": "\\mathcal{D}",
                    "eE": "\\mathcal{E}",
                    "fF": "\\mathcal{F}",
                    "gG": "\\mathcal{G}",
                    "hH": "\\mathcal{H}",
                }
            },
            svg: {
                fontCache: 'global',
                scale: 0.92,
                displayAlign: "center",
            },
            };
        </script>
    
    
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/quantecon-book-theme.css?digest=bd0785fbb14d8d2bd4d9ae501d79ed8d3bc089ec" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/exercise.css" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-design.5ea377869091fd0449014c60fc090103.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>


    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/scripts/quantecon-book-theme.js?digest=d9faaf6c4b57726f74ba012412af1f5681bdff87"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js"></script>
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-J0SMYR4SG3"></script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-J0SMYR4SG3');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"argmax": "arg\\,max", "argmin": "arg\\,min"}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'von_neumann_model';</script>
    <link rel="canonical" href="https://python.quantecon-zh-cn.org/von_neumann_model.html" />
    <link rel="shortcut icon" href="_static/lectures-favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="19. 有限马尔可夫链" href="finite_markov.html" />
    <link rel="prev" title="17. 最优传输" href="opt_transport.html" />

<!-- Normal Meta Tags -->
<meta name="author" context="Thomas J. Sargent &amp; John Stachurski" />
<meta name="keywords" content="Python, QuantEcon, Quantitative Economics, Economics, Sloan, Alfred P. Sloan Foundation, Tom J. Sargent, John Stachurski" />
<meta name="description" content=本课程是由托马斯·萨金特（Thomas J. Sargent）和约翰·斯塔胡斯基（John Stachurski）设计和编写的数量经济建模讲座。 />

<!-- Twitter tags -->
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@quantecon" />
<meta name="twitter:title" content="冯·诺依曼增长模型（及其推广）"/>
<meta name="twitter:description" content="本课程是由托马斯·萨金特（Thomas J. Sargent）和约翰·斯塔胡斯基（John Stachurski）设计和编写的数量经济建模讲座。">
<meta name="twitter:creator" content="@quantecon">
<meta name="twitter:image" content="https://assets.quantecon.org/img/qe-twitter-logo.png">

<!-- Opengraph tags -->
<meta property="og:title" content="冯·诺依曼增长模型（及其推广）" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://python.quantecon-zh-cn.org/von_neumann_model.html" />
<meta property="og:image" content="https://assets.quantecon.org/img/qe-og-logo.png" />
<meta property="og:description" content="本课程是由托马斯·萨金特（Thomas J. Sargent）和约翰·斯塔胡斯基（John Stachurski）设计和编写的数量经济建模讲座。" />
<meta property="og:site_name" content="Python中级数量经济学" />
<meta name="theme-color" content="#ffffff" />

  </head>
<body>

<!-- Override QuantEcon theme colors -->

    <span id="top"></span>

    <div class="qe-wrapper">

        <div class="qe-main">

            <div class="qe-page" id=von_neumann_model>

                <div class="qe-page__toc">

                    <div class="inner">

                        
                        <div class="qe-page__toc-header">
                            On this page
                        </div>


                        <nav id="bd-toc-nav" class="qe-page__toc-nav">
                            <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">18.1. 符号表示</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">18.2. 模型要素和假设</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">18.3. 动态解释</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">18.3.1. 平衡增长</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">18.4. 对偶性</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id15">18.5. 作为零和双人博弈的解释</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#lp">18.5.1. 与线性规划(LP)的联系</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id19">18.5.2. 算法</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id21">18.5.2.1. 第1步</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id22">18.5.2.2. 步骤 2</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id23">18.5.3. 唯一性和不可约性</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id25">18.5.4. 特殊情况</a></li>
</ul>
</li>
</ul>
                            <p class="logo">
                                
                                    
                                    <a href=https://quantecon.org><img src="_static/qe-logo-large.png" class="logo logo-img" alt="logo"></a>
                                    
                                    
                                
                            </p>

                            <p class="powered">Powered by <a href="https://jupyterbook.org/">Jupyter Book</a></p>

                        </nav>

                        <div class="qe-page__toc-footer">
                            
                            
                            <p><a href="#top"><strong>Back to top</strong></a></p>
                        </div>

                    </div>

                </div>

                <div class="qe-page__header">

                    <div class="qe-page__header-copy">

                        <p class="qe-page__header-heading"><a href="intro.html">Python中级数量经济学</a></p>

                        <p class="qe-page__header-subheading">冯·诺依曼增长模型（及其推广）</p>

                    </div>
                    <!-- length 2, since its a string and empty dict has length 2 - {} -->
                        <p class="qe-page__header-authors" font-size="18">
                            
                                
                                    <a href="http://www.tomsargent.com/" target="_blank"><span>托马斯·萨金特（Thomas J. Sargent）</span></a>
                                
                            
                                
                                    and <a href="https://johnstachurski.net/" target="_blank"><span>约翰·斯塔胡斯基（John Stachurski）</span></a>
                                
                            
                        </p>


                </div> <!-- .page__header -->



                
                <main class="qe-page__content" role="main">
                    
                    <div>
                        
  <section class="tex2jax_ignore mathjax_ignore" id="index-0">
<span id="id1"></span><h1><a class="toc-backref" href="#id27"><span class="section-number">18. </span>冯·诺依曼增长模型（及其推广）</a><a class="headerlink" href="#index-0" title="Permalink to this heading">#</a></h1>
<div class="contents topic" id="id2">
<p class="topic-title">目录</p>
<ul class="simple">
<li><p><a class="reference internal" href="#index-0" id="id27">冯·诺依曼增长模型（及其推广）</a></p>
<ul>
<li><p><a class="reference internal" href="#id5" id="id28">符号表示</a></p></li>
<li><p><a class="reference internal" href="#id6" id="id29">模型要素和假设</a></p></li>
<li><p><a class="reference internal" href="#id8" id="id30">动态解释</a></p></li>
<li><p><a class="reference internal" href="#id10" id="id31">对偶性</a></p></li>
<li><p><a class="reference internal" href="#id15" id="id32">作为零和双人博弈的解释</a></p></li>
</ul>
</li>
</ul>
</div>
<p>本讲座使用<code class="docutils literal notranslate"><span class="pre">Neumann</span></code>类来计算约翰·冯·诺依曼<span id="id3">[<a class="reference internal" href="zreferences.html#id76" title="John von Neumann. Uber ein okonomsiches gleichungssystem und eine verallgemeinering des browerschen fixpunktsatzes. In Erge. Math. Kolloq., volume 8, 73–83. 1937.">von Neumann, 1937</a>]</span>提出的线性增长模型的关键要素，该模型后来被Kemeny、Morgenstern和Thompson <span id="id4">[<a class="reference internal" href="zreferences.html#id79" title="John G Kemeny, Oskar Morgenstern, and Gerald L Thompson. A generalization of the von neumann model of an expanding economy. Econometrica, Journal of the Econometric Society, pages 115–135, 1956.">Kemeny <em>et al.</em>, 1956</a>]</span>进行了推广。</p>
<p>我们关注的要素包括最大扩张率（<span class="math notranslate nohighlight">\(\alpha\)</span>）、利息因子（<span class="math notranslate nohighlight">\(β\)</span>）、最优强度（<span class="math notranslate nohighlight">\(x\)</span>）和价格（<span class="math notranslate nohighlight">\(p\)</span>）。</p>
<p>除了观察约翰·冯·诺依曼这位伟大思想家如何构建均衡增长中的价格和数量向量模型外，本讲还将展示如何有效地运用以下重要工具：</p>
<ul class="simple">
<li><p>零和双人博弈</p></li>
<li><p>线性规划</p></li>
<li><p>Perron-Frobenius定理</p></li>
</ul>
<p>让我们先从导入包开始：</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
<span class="n">FONTPATH</span> <span class="o">=</span> <span class="s2">&quot;fonts/SourceHanSerifSC-SemiBold.otf&quot;</span>
<span class="n">mpl</span><span class="o">.</span><span class="n">font_manager</span><span class="o">.</span><span class="n">fontManager</span><span class="o">.</span><span class="n">addfont</span><span class="p">(</span><span class="n">FONTPATH</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;font.family&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Source Han Serif SC&#39;</span><span class="p">]</span>

<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">fsolve</span><span class="p">,</span> <span class="n">linprog</span>
<span class="kn">from</span> <span class="nn">textwrap</span> <span class="kn">import</span> <span class="n">dedent</span>

<span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">precision</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>以下代码提供了<code class="docutils literal notranslate"><span class="pre">Neumann</span></code>类</p>
<div class="cell tag_collapse-20 docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Neumann</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    该类描述了Kemeny等人(1956, ECTA)和Gale(1960, 第9.5章)讨论的广义冯·诺依曼增长模型：</span>

<span class="sd">    设：</span>
<span class="sd">    n ... 商品数量</span>
<span class="sd">    m ... 生产活动数量</span>
<span class="sd">    A ... 投入矩阵，维度为m×n</span>
<span class="sd">        a_{i,j} - 活动i消耗的商品j的数量</span>
<span class="sd">    B ... 产出矩阵，维度为m×n</span>
<span class="sd">        b_{i,j} - 活动i生产的商品j的数量</span>

<span class="sd">    x ... 强度向量(m维向量)，具有非负分量</span>
<span class="sd">        x&#39;B - 生产的商品向量</span>
<span class="sd">        x&#39;A - 消耗的商品向量</span>
<span class="sd">    p ... 价格向量(n维向量)，具有非负分量</span>
<span class="sd">        Bp - 每个活动的收入向量</span>
<span class="sd">        Ap - 每个活动的成本</span>

<span class="sd">    A和B都具有非负分量。此外，我们假设：</span>
<span class="sd">    (1) 假设I(每种被消耗的商品都会被生产)：</span>
<span class="sd">        对所有j，b_{.,j} &gt; 0，即至少有一个分量严格为正</span>
<span class="sd">    (2) 假设II(没有免费午餐)：</span>
<span class="sd">        对所有i，a_{i,.} &gt; 0，即至少有一个分量严格为正</span>

<span class="sd">    参数</span>
<span class="sd">    ----------</span>
<span class="sd">    A : array_like或标量(float)</span>
<span class="sd">        状态转移方程的一部分。应为`n x n`</span>
<span class="sd">    B : array_like或标量(float)</span>
<span class="sd">        状态转移方程的一部分。应为`n x k`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert</span><span class="p">,</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># 检查(A, B)是否满足基本假设</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s1">&#39;输入和输出矩阵必须具有相同的维度！&#39;</span>
        <span class="k">assert</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s1">&#39;输入和输出矩阵必须只包含非负分量！&#39;</span>

        <span class="c1"># (1) 检查是否满足假设I：</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">AI</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">AI</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># (2) 检查是否满足假设II：</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">AII</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">AII</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">me</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        广义冯·诺依曼扩张模型：</span>
<span class="s2">          - 商品数量              : </span><span class="si">{n}</span>
<span class="s2">          - 生产活动数量          : </span><span class="si">{m}</span>

<span class="s2">        假设：</span>
<span class="s2">          - AI:  B的每一列都有正分量    : </span><span class="si">{AI}</span>
<span class="s2">          - AII: A的每一行都有正分量    : </span><span class="si">{AII}</span>

<span class="s2">        &quot;&quot;&quot;</span>
        <span class="c1"># 不可约的                                       : {irr}</span>
        <span class="k">return</span> <span class="n">dedent</span><span class="p">(</span><span class="n">me</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span>
                                <span class="n">AI</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">AI</span><span class="p">,</span> <span class="n">AII</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">AII</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        将类数组对象(列表的列表、浮点数等)转换为</span>
<span class="sd">        规范的2D NumPy数组</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>


    <span class="k">def</span> <span class="nf">bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        计算alpha(扩张率)和beta(利息因子)的简单上下界。</span>
<span class="sd">        参见Gale(1960)定理9.8的证明</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span>

        <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">α</span><span class="p">:</span> <span class="p">((</span><span class="n">B</span> <span class="o">-</span> <span class="n">α</span> <span class="o">*</span> <span class="n">A</span><span class="p">)</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">g</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">β</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span> <span class="o">@</span> <span class="p">(</span><span class="n">B</span> <span class="o">-</span> <span class="n">β</span> <span class="o">*</span> <span class="n">A</span><span class="p">))</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

        <span class="n">UB</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>  <span class="c1"># α, β的上界</span>
        <span class="n">LB</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>  <span class="c1"># α, β的下界</span>

        <span class="k">return</span> <span class="n">LB</span><span class="p">,</span> <span class="n">UB</span>


    <span class="k">def</span> <span class="nf">zerosum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">γ</span><span class="p">,</span> <span class="n">dual</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        给定gamma，计算由矩阵定义的两人零和博弈的值和最优策略</span>

<span class="sd">                M(gamma) = B - gamma * A</span>

<span class="sd">        行玩家最大化，列玩家最小化</span>

<span class="sd">        零和博弈作为线性规划(原问题 --&gt; α)</span>

<span class="sd">            max (0&#39;, 1) @ (x&#39;, v)</span>
<span class="sd">            约束条件</span>
<span class="sd">            [-M&#39;, ones(n, 1)] @ (x&#39;, v)&#39; &lt;= 0</span>
<span class="sd">            (x&#39;, v) @ (ones(m, 1), 0) = 1</span>
<span class="sd">            (x&#39;, v) &gt;= (0&#39;, -inf)</span>

<span class="sd">        零和博弈作为线性规划(对偶问题 --&gt; beta)</span>

<span class="sd">            min (0&#39;, 1) @ (p&#39;, u)</span>
<span class="sd">            约束条件</span>
<span class="sd">            [M, -ones(m, 1)] @ (p&#39;, u)&#39; &lt;= 0</span>
<span class="sd">            (p&#39;, u) @ (ones(n, 1), 0) = 1</span>
<span class="sd">            (p&#39;, u) &gt;= (0&#39;, -inf)</span>

<span class="sd">        输出：</span>
<span class="sd">        --------</span>
<span class="sd">        value: 标量</span>
<span class="sd">            零和博弈的值</span>

<span class="sd">        strategy: 向量</span>
<span class="sd">            如果dual = False，则为强度向量</span>
<span class="sd">            如果dual = True，则为价格向量</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">B</span> <span class="o">-</span> <span class="n">γ</span> <span class="o">*</span> <span class="n">A</span>

        <span class="k">if</span> <span class="n">dual</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="c1"># 求解原问题线性规划(详见描述)</span>
            <span class="c1"># (1) 定义v的最大化问题(linprog最小化)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># (2) 添加约束：</span>
            <span class="c1"># ... 非负约束</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)])</span>
            <span class="c1"># ... 不等式约束</span>
            <span class="n">A_iq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="o">-</span><span class="n">M</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))])</span>
            <span class="n">b_iq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="c1"># ... 归一化</span>
            <span class="n">A_eq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">b_eq</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">res</span> <span class="o">=</span> <span class="n">linprog</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">A_ub</span><span class="o">=</span><span class="n">A_iq</span><span class="p">,</span> <span class="n">b_ub</span><span class="o">=</span><span class="n">b_iq</span><span class="p">,</span> <span class="n">A_eq</span><span class="o">=</span><span class="n">A_eq</span><span class="p">,</span> <span class="n">b_eq</span><span class="o">=</span><span class="n">b_eq</span><span class="p">,</span>
                          <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 求解对偶线性规划(详见描述)</span>
            <span class="c1"># (1) 定义v的最大化问题(linprog最小化)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="mi">1</span><span class="p">])</span>

            <span class="c1"># (2) 添加约束：</span>
            <span class="c1"># ... 非负约束</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)])</span>
            <span class="c1"># ... 不等式约束</span>
            <span class="n">A_iq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">M</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">))])</span>
            <span class="n">b_iq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="c1"># ... 归一化</span>
            <span class="n">A_eq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">b_eq</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">res</span> <span class="o">=</span> <span class="n">linprog</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">A_ub</span><span class="o">=</span><span class="n">A_iq</span><span class="p">,</span> <span class="n">b_ub</span><span class="o">=</span><span class="n">b_iq</span><span class="p">,</span> <span class="n">A_eq</span><span class="o">=</span><span class="n">A_eq</span><span class="p">,</span> <span class="n">b_eq</span><span class="o">=</span><span class="n">b_eq</span><span class="p">,</span>
                          <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">message</span><span class="p">)</span>

        <span class="c1"># 提取所需的量</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">strategy</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">value</span><span class="p">,</span> <span class="n">strategy</span>


    <span class="k">def</span> <span class="nf">expansion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">maxit</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        这里使用的算法在Hamburger-Thompson-Weil(1967, ECTA)中有描述。</span>
<span class="sd">        它基于简单的二分法，并利用了这样一个思想：对于给定的γ(= α或β)，</span>
<span class="sd">        矩阵&quot;M = B - γ * A&quot;定义了一个两人零和博弈，其中最优策略是</span>
<span class="sd">        (归一化的)强度和价格向量。</span>

<span class="sd">        输出：</span>
<span class="sd">        --------</span>
<span class="sd">        alpha: 标量</span>
<span class="sd">            最优扩张率</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">LB</span><span class="p">,</span> <span class="n">UB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">()</span>

        <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxit</span><span class="p">):</span>

            <span class="n">γ</span> <span class="o">=</span> <span class="p">(</span><span class="n">LB</span> <span class="o">+</span> <span class="n">UB</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">ZS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">γ</span><span class="o">=</span><span class="n">γ</span><span class="p">)</span>
            <span class="n">V</span> <span class="o">=</span> <span class="n">ZS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>     <span class="c1"># γ对应的博弈值</span>

            <span class="k">if</span> <span class="n">V</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">LB</span> <span class="o">=</span> <span class="n">γ</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">UB</span> <span class="o">=</span> <span class="n">γ</span>

            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">UB</span> <span class="o">-</span> <span class="n">LB</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="n">γ</span> <span class="o">=</span> <span class="p">(</span><span class="n">UB</span> <span class="o">+</span> <span class="n">LB</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">γ</span><span class="o">=</span><span class="n">γ</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">γ</span><span class="o">=</span><span class="n">γ</span><span class="p">,</span> <span class="n">dual</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">break</span>

        <span class="k">return</span> <span class="n">γ</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span>

    <span class="k">def</span> <span class="nf">interest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">maxit</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        这里使用的算法在Hamburger-Thompson-Weil(1967, ECTA)中有描述。</span>
<span class="sd">        它基于简单的二分法，并利用了这样一个思想：对于给定的gamma(= alpha或beta)，</span>
<span class="sd">        矩阵&quot;M = B - γ * A&quot;定义了一个两人零和博弈，其中最优策略是</span>
<span class="sd">        (归一化的)强度和价格向量</span>

<span class="sd">        输出：</span>
<span class="sd">        --------</span>
<span class="sd">        beta: 标量</span>
<span class="sd">            最优利率</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">LB</span><span class="p">,</span> <span class="n">UB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span><span class="p">()</span>

        <span class="k">for</span> <span class="nb">iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxit</span><span class="p">):</span>
            <span class="n">γ</span> <span class="o">=</span> <span class="p">(</span><span class="n">LB</span> <span class="o">+</span> <span class="n">UB</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">ZS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">γ</span><span class="o">=</span><span class="n">γ</span><span class="p">,</span> <span class="n">dual</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">V</span> <span class="o">=</span> <span class="n">ZS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">V</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">LB</span> <span class="o">=</span> <span class="n">γ</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">UB</span> <span class="o">=</span> <span class="n">γ</span>

            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">UB</span> <span class="o">-</span> <span class="n">LB</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
                <span class="n">γ</span> <span class="o">=</span> <span class="p">(</span><span class="n">UB</span> <span class="o">+</span> <span class="n">LB</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">γ</span><span class="o">=</span><span class="n">γ</span><span class="p">,</span> <span class="n">dual</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">γ</span><span class="o">=</span><span class="n">γ</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">break</span>

        <span class="k">return</span> <span class="n">γ</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span>
</pre></div>
</div>
</div>
</div>
<section id="id5">
<h2><a class="toc-backref" href="#id28"><span class="section-number">18.1. </span>符号表示</a><a class="headerlink" href="#id5" title="Permalink to this heading">#</a></h2>
<p>我们使用以下符号表示。</p>
<p><span class="math notranslate nohighlight">\(\mathbf{0}\)</span> 表示零向量。</p>
<p>对于一个 <span class="math notranslate nohighlight">\(n\)</span> 维向量，如果对所有 <span class="math notranslate nohighlight">\(i=1,2,\dots,n\)</span> 都有 <span class="math notranslate nohighlight">\(x_i&gt;0\)</span>，我们称之为正向量，记作 <span class="math notranslate nohighlight">\(x\gg \mathbf{0}\)</span>。</p>
<p>如果对所有 <span class="math notranslate nohighlight">\(i=1,2,\dots,n\)</span> 都有 <span class="math notranslate nohighlight">\(x_i\geq 0\)</span>，我们称之为非负向量，记作 <span class="math notranslate nohighlight">\(x\geq \mathbf{0}\)</span>。</p>
<p>如果 <span class="math notranslate nohighlight">\(x\geq \mathbf{0}\)</span> 且 <span class="math notranslate nohighlight">\(x\neq \mathbf{0}\)</span>，我们称之为半正向量，记作 <span class="math notranslate nohighlight">\(x &gt; \mathbf{0}\)</span>。</p>
<p>对于两个可比向量 <span class="math notranslate nohighlight">\(x\)</span> 和 <span class="math notranslate nohighlight">\(y\)</span>，<span class="math notranslate nohighlight">\(x\gg y\)</span>、<span class="math notranslate nohighlight">\(x\geq y\)</span> 和 <span class="math notranslate nohighlight">\(x&gt; y\)</span> 分别表示 <span class="math notranslate nohighlight">\(x-y\gg \mathbf{0}\)</span>、<span class="math notranslate nohighlight">\(x-y \geq \mathbf{0}\)</span> 和 <span class="math notranslate nohighlight">\(x-y &gt; \mathbf{0}\)</span>。</p>
<p>本讲中所有向量均为列向量；<span class="math notranslate nohighlight">\(x^{T}\)</span> 表示 <span class="math notranslate nohighlight">\(x\)</span> 的转置（即行向量）。</p>
<p>用 <span class="math notranslate nohighlight">\(\iota_n\)</span> 表示由 <span class="math notranslate nohighlight">\(n\)</span> 个1组成的列向量，即 <span class="math notranslate nohighlight">\(\iota_n = (1,1,\dots,1)^T\)</span>。</p>
<p>用 <span class="math notranslate nohighlight">\(e^i\)</span> 表示一个（任意大小的）向量，除第 <span class="math notranslate nohighlight">\(i\)</span> 个位置为1外，其余位置均为0。</p>
<p>我们用大写字母表示矩阵。对于任意矩阵 <span class="math notranslate nohighlight">\(A\)</span>，<span class="math notranslate nohighlight">\(a_{i,j}\)</span> 表示其第 <span class="math notranslate nohighlight">\(i\)</span> 行</p>
<p>行和第 <span class="math notranslate nohighlight">\(j\)</span> 列。</p>
<p><span class="math notranslate nohighlight">\(a_{\cdot j}\)</span> 和 <span class="math notranslate nohighlight">\(a_{i\cdot}\)</span> 分别表示矩阵 <span class="math notranslate nohighlight">\(A\)</span> 的第 <span class="math notranslate nohighlight">\(j\)</span> 列和第 <span class="math notranslate nohighlight">\(i\)</span> 行。</p>
</section>
<section id="id6">
<h2><a class="toc-backref" href="#id29"><span class="section-number">18.2. </span>模型要素和假设</a><a class="headerlink" href="#id6" title="Permalink to this heading">#</a></h2>
<p>一对 <span class="math notranslate nohighlight">\(m\times n\)</span> 非负矩阵 <span class="math notranslate nohighlight">\((A,B)\)</span> 定义了一个经济。</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(m\)</span> 是<em>活动</em>（或部门）的数量</p></li>
<li><p><span class="math notranslate nohighlight">\(n\)</span> 是<em>商品</em>（生产和/或消费）的数量</p></li>
<li><p><span class="math notranslate nohighlight">\(A\)</span> 被称为<em>投入矩阵</em>；<span class="math notranslate nohighlight">\(a_{i,j}\)</span> 表示活动 <span class="math notranslate nohighlight">\(i\)</span> 消耗的商品 <span class="math notranslate nohighlight">\(j\)</span> 的数量</p></li>
<li><p><span class="math notranslate nohighlight">\(B\)</span> 被称为<em>产出矩阵</em>；<span class="math notranslate nohighlight">\(b_{i,j}\)</span> 表示活动 <span class="math notranslate nohighlight">\(i\)</span> 生产的商品 <span class="math notranslate nohighlight">\(j\)</span> 的数量</p></li>
</ul>
<p>两个关键假设限制经济 <span class="math notranslate nohighlight">\((A,B)\)</span>：</p>
<ul>
<li><p><strong>假设 I：</strong>（每种被消费的商品也都被生产）</p>
<div class="math notranslate nohighlight">
\[
  b_{.,j} &gt; \mathbf{0}\hspace{5mm}\forall j=1,2,\dots,n
  \]</div>
</li>
<li><p><strong>假设 II：</strong>（没有免费午餐）</p>
<div class="math notranslate nohighlight">
\[
  a_{i,.} &gt; \mathbf{0}\hspace{5mm}\forall i=1,2,\dots,m
  \]</div>
</li>
</ul>
<p>半正<em>强度</em> <span class="math notranslate nohighlight">\(m\)</span> 维向量 <span class="math notranslate nohighlight">\(x\)</span> 表示活动的运行水平。</p>
<p>因此，</p>
<ul class="simple">
<li><p>向量 <span class="math notranslate nohighlight">\(x^TA\)</span> 表示<em>生产中使用的商品总量</em></p></li>
<li><p>向量 <span class="math notranslate nohighlight">\(x^TB\)</span> 表示<em>总产出</em></p></li>
</ul>
<p>如果存在一个非负强度向量 <span class="math notranslate nohighlight">\(x \geq 0\)</span> 使得 <span class="math notranslate nohighlight">\(x^T B &gt; x^TA\)</span>，则称经济 <span class="math notranslate nohighlight">\((A,B)\)</span> 是<em>生产性的</em>。</p>
<p>半正 <span class="math notranslate nohighlight">\(n\)</span> 维向量 <span class="math notranslate nohighlight">\(p\)</span> 包含了分配给 <span class="math notranslate nohighlight">\(n\)</span> 种商品的价格。</p>
<p>向量 <span class="math notranslate nohighlight">\(p\)</span> 意味着<em>成本</em>和<em>收入</em>向量</p>
<ul class="simple">
<li><p>向量 <span class="math notranslate nohighlight">\(Ap\)</span> 表示活动向量的<em>成本</em></p></li>
<li><p>向量 <span class="math notranslate nohighlight">\(Bp\)</span> 表示活动向量的<em>收入</em></p></li>
</ul>
<p>满足度或称为<em>不可约性</em>（或不可分解性）的投入产出对 <span class="math notranslate nohighlight">\((A,B)\)</span> 的一个性质决定了一个经济是否可以被分解为多个”子经济”。</p>
<p><strong>定义：</strong> 对于经济 <span class="math notranslate nohighlight">\((A,B)\)</span>，如果可以在不消耗 <span class="math notranslate nohighlight">\(S\)</span> 以外商品的情况下生产 <span class="math notranslate nohighlight">\(S\)</span> 中的每种商品，则称商品集合 <span class="math notranslate nohighlight">\(S\subset \{1,2,\dots,n\}\)</span> 为<em>独立子集</em>。形式上，如果集合 <span class="math notranslate nohighlight">\(S\)</span> 满足以下条件，则称其为独立的：</p>
<p><span class="math notranslate nohighlight">\(\exists T\subset \{1,2,\dots,m\}\)</span>（活动的一个子集），使得
对于所有 <span class="math notranslate nohighlight">\(i\in T\)</span> 和 <span class="math notranslate nohighlight">\(j\in S^c\)</span>，有 <span class="math notranslate nohighlight">\(a_{i,j}=0\)</span>，且
对于所有 <span class="math notranslate nohighlight">\(j\in S\)</span>，<span class="math notranslate nohighlight">\(\exists i\in T\)</span> 使得 <span class="math notranslate nohighlight">\(b_{i,j}&gt;0\)</span>。
如果不存在真独立子集，则称该经济是<strong>不可约的</strong>。</p>
<p>我们研究两个例子，都来自Gale的著作第9.6章 <span id="id7">[<a class="reference internal" href="zreferences.html#id81" title="David Gale. The theory of linear economic models. University of Chicago press, 1989.">Gale, 1989</a>]</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># (1) 不可约的(A, B)例子：α_0 = β_0</span>
<span class="n">A1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>

<span class="n">B1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

<span class="c1"># (2) 可约的(A, B)例子：β_0 &lt; α_0</span>
<span class="n">A2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>

<span class="n">B2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
</pre></div>
</div>
</div>
</div>
<p>以下代码设置我们的第一个诺伊曼经济或<code class="docutils literal notranslate"><span class="pre">Neumann</span></code>实例</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n1</span> <span class="o">=</span> <span class="n">Neumann</span><span class="p">(</span><span class="n">A1</span><span class="p">,</span> <span class="n">B1</span><span class="p">)</span>
<span class="n">n1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>广义冯·诺依曼扩张模型：
  - 商品数量              : 4
  - 生产活动数量          : 3

假设：
  - AI:  B的每一列都有正分量    : True
  - AII: A的每一行都有正分量    : True
</pre></div>
</div>
</div>
</div>
<p>这是第二个诺伊曼经济的实例</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n2</span> <span class="o">=</span> <span class="n">Neumann</span><span class="p">(</span><span class="n">A2</span><span class="p">,</span> <span class="n">B2</span><span class="p">)</span>
<span class="n">n2</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>广义冯·诺依曼扩张模型：
  - 商品数量              : 6
  - 生产活动数量          : 5

假设：
  - AI:  B的每一列都有正分量    : True
  - AII: A的每一行都有正分量    : True
</pre></div>
</div>
</div>
</div>
</section>
<section id="id8">
<h2><a class="toc-backref" href="#id30"><span class="section-number">18.3. </span>动态解释</a><a class="headerlink" href="#id8" title="Permalink to this heading">#</a></h2>
<p>将时间指标 <span class="math notranslate nohighlight">\(t\)</span> 附加到前述对象上，将经济视为一个动态系统，并研究以下序列</p>
<div class="math notranslate nohighlight">
\[
\{(A_t,B_t)\}_{t\geq 0}, \hspace{1cm}\{x_t\}_{t\geq 0},\hspace{1cm} \{p_t\}_{t\geq 0}
\]</div>
<p>一个有趣的特殊情况是保持技术过程不变，仅研究数量和价格的动态变化。</p>
<p>因此，在本讲座的剩余部分，我们假设对所有 <span class="math notranslate nohighlight">\(t\geq 0\)</span> 都有 <span class="math notranslate nohighlight">\((A_t,B_t)=(A,B)\)</span>。</p>
<p>动态解释的一个关键要素涉及生产的时间安排。</p>
<p>我们假设生产（投入品的消耗）发生在 <span class="math notranslate nohighlight">\(t\)</span> 期，而相应的产出在 <span class="math notranslate nohighlight">\(t+1\)</span> 期实现，即在 <span class="math notranslate nohighlight">\(t\)</span> 期消耗 <span class="math notranslate nohighlight">\(x_{t}^TA\)</span> 将在 <span class="math notranslate nohighlight">\(t+1\)</span> 期产生 <span class="math notranslate nohighlight">\(x^T_{t}B\)</span> 数量的产出。</p>
<p>这些时间约定意味着以下可行性条件：</p>
<div class="math notranslate nohighlight">
\[
\begin{aligned}
x^T_{t}B \geq x^T_{t+1} A \hspace{1cm}\forall t\geq 1
\end{aligned}
\]</div>
<p>这表明今天使用的商品不能超过昨天生产的数量。</p>
<p>因此，<span class="math notranslate nohighlight">\(Ap_t\)</span> 表示第 <span class="math notranslate nohighlight">\(t\)</span> 期的生产成本，而 <span class="math notranslate nohighlight">\(Bp_t\)</span> 表示第 <span class="math notranslate nohighlight">\(t+1\)</span> 期的收入。</p>
<section id="id9">
<h3><span class="section-number">18.3.1. </span>平衡增长<a class="headerlink" href="#id9" title="Permalink to this heading">#</a></h3>
<p>我们遵循约翰·冯·诺依曼的方法来研究”平衡增长”。</p>
<p>让 <span class="math notranslate nohighlight">\(./\)</span>表示两个向量的逐元素除法，让 <span class="math notranslate nohighlight">\(\alpha &gt;0\)</span> 为一个标量。</p>
<p>那么<em>平衡增长</em>是一种满足以下条件的情况：</p>
<div class="math notranslate nohighlight">
\[
x_{t+1}./x_t = \alpha , \quad \forall t \geq 0
\]</div>
<p>在平衡增长下，<span class="math notranslate nohighlight">\(x\)</span> 的运动规律显然是 <span class="math notranslate nohighlight">\(x_{t+1}=\alpha x_t\)</span>，因此我们可以将可行性约束重写为：</p>
<div class="math notranslate nohighlight">
\[
x^T_{t}B \geq \alpha x^T_t A \hspace{1cm}\forall t
\]</div>
<p>同样地，将 <span class="math notranslate nohighlight">\(\beta\in\mathbb{R}\)</span> 定义为每单位时间的<strong>利息因子</strong>。</p>
<p>我们假设始终可以通过在”模型外”投资获得等于常数利息因子 <span class="math notranslate nohighlight">\(\beta\)</span> 的总回报。</p>
<p>在这个关于外部投资机会的假设下，一个</p>
<p>无套利条件产生以下（无利润）价格序列限制：</p>
<div class="math notranslate nohighlight">
\[
\beta Ap_{t} \geq B p_{t} \hspace{1cm}\forall t
\]</div>
<p>这表明生产的回报不能超过外部投资机会所提供的回报（这里我们比较第<span class="math notranslate nohighlight">\(t+1\)</span>期的价值）。</p>
<p>平衡增长假设使我们可以省略时间下标，并完全基于时间不变的增长率<span class="math notranslate nohighlight">\(\alpha\)</span>和利息因子<span class="math notranslate nohighlight">\(\beta\)</span>进行分析。</p>
</section>
</section>
<section id="id10">
<h2><a class="toc-backref" href="#id31"><span class="section-number">18.4. </span>对偶性</a><a class="headerlink" href="#id10" title="Permalink to this heading">#</a></h2>
<p>两个问题通过经济的技术特征和估值特征之间存在着一个显著的对偶关系：</p>
<p><strong>定义：</strong> 经济<span class="math notranslate nohighlight">\((A,B)\)</span>的<em>技术扩张问题</em>（TEP）是找到一个半正<span class="math notranslate nohighlight">\(m\)</span>维向量<span class="math notranslate nohighlight">\(x&gt;0\)</span>和一个实数<span class="math notranslate nohighlight">\(\alpha\in\mathbb{R}\)</span>，使其满足</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
    &amp;\max_{\alpha} \hspace{2mm} \alpha\\
    &amp;\text{s.t. }\hspace{2mm}x^T B \geq \alpha x^T A
    \end{aligned}
\end{split}\]</div>
<p>David Gale的著作中的定理9.3 <span id="id11">[<a class="reference internal" href="zreferences.html#id81" title="David Gale. The theory of linear economic models. University of Chicago press, 1989.">Gale, 1989</a>]</span>指出，如果假设I和II都满足，那么<span class="math notranslate nohighlight">\(\alpha\)</span>的最大值存在且为正数。</p>
<p>这个最大值被称为<em>技术扩张率</em>，用<span class="math notranslate nohighlight">\(\alpha_0\)</span>表示。相应的强度向量<span class="math notranslate nohighlight">\(x_0\)</span>被称为<em>最优强度向量</em>。</p>
<p><strong>定义：</strong> <span class="math notranslate nohighlight">\((A,B)\)</span>的经济扩张问题（EEP）是要找到一个半正<span class="math notranslate nohighlight">\(n\)</span>维向量<span class="math notranslate nohighlight">\(p&gt;0\)</span>和一个实数<span class="math notranslate nohighlight">\(\beta\in\mathbb{R}\)</span>，使其满足</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
    &amp;\min_{\beta} \hspace{2mm} \beta\\
    &amp;\text{s.t. }\hspace{2mm}Bp \leq \beta Ap
    \end{aligned}
\end{split}\]</div>
<p>假设I和II意味着存在一个最小值<span class="math notranslate nohighlight">\(\beta_0&gt;0\)</span>，称为<em>经济扩张率</em>。</p>
<p>相应的价格向量<span class="math notranslate nohighlight">\(p_0\)</span>是<em>最优价格向量</em>。</p>
<p>由于<em>技术扩张</em>问题和<em>经济扩张问题</em>中的目标函数都是线性齐次的，</p>
<p><span class="math notranslate nohighlight">\(x_0\)</span> 和 <span class="math notranslate nohighlight">\(p_0\)</span> 的最优性仅由一个正的比例因子来定义。</p>
<p>为了方便（并强调与零和博弈的密切联系），我们将向量 <span class="math notranslate nohighlight">\(x_0\)</span> 和 <span class="math notranslate nohighlight">\(p_0\)</span> 都归一化为单位长度。</p>
<p>标准对偶性论证（参见 (Gale, 1960) <span id="id12">[<a class="reference internal" href="zreferences.html#id81" title="David Gale. The theory of linear economic models. University of Chicago press, 1989.">Gale, 1989</a>]</span> 中的引理9.4）表明，在假设I和II下，<span class="math notranslate nohighlight">\(\beta_0\leq \alpha_0\)</span>。</p>
<p>但要推导出 <span class="math notranslate nohighlight">\(\beta_0\geq \alpha_0\)</span>，假设I和II是不够的。</p>
<p>因此，冯·诺依曼 <span id="id13">[<a class="reference internal" href="zreferences.html#id76" title="John von Neumann. Uber ein okonomsiches gleichungssystem und eine verallgemeinering des browerschen fixpunktsatzes. In Erge. Math. Kolloq., volume 8, 73–83. 1937.">von Neumann, 1937</a>]</span> 继续证明了以下连接TEP和EEP的重要”对偶性”结果。</p>
<p><strong>定理1（冯·诺依曼）：</strong> 如果经济 <span class="math notranslate nohighlight">\((A,B)\)</span> 满足假设I和II，则存在 <span class="math notranslate nohighlight">\(\left(\gamma^{*}, x_0, p_0\right)\)</span>，其中 <span class="math notranslate nohighlight">\(\gamma^{*}\in[\beta_0, \alpha_0]\subset\mathbb{R}\)</span>，<span class="math notranslate nohighlight">\(x_0&gt;0\)</span> 是一个 <span class="math notranslate nohighlight">\(m\)</span> 维向量，<span class="math notranslate nohighlight">\(p_0&gt;0\)</span> 是一个 <span class="math notranslate nohighlight">\(n\)</span> 维向量，且以下套利关系成立</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}
\begin{aligned}
x_0^T B &amp;\geq \gamma^{* } x_0^T A \\
Bp_0 &amp;\leq \gamma^{* } Ap_0 \\
x_0^T\left(B-\gamma^{* } A\right)p_0 &amp;= 0\end{split}\\\end{aligned}
\end{aligned}\end{align} \]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>证明（概要）：</em> 假设I和II意味着存在<span class="math notranslate nohighlight">\((\alpha_0, x_0)\)</span>和<span class="math notranslate nohighlight">\((\beta_0, p_0)\)</span>分别解决TEP和EEP。如果<span class="math notranslate nohighlight">\(\gamma^*&gt;\alpha_0\)</span>，根据<span class="math notranslate nohighlight">\(\alpha_0\)</span>的定义，不可能存在半正向量<span class="math notranslate nohighlight">\(x\)</span>满足<span class="math notranslate nohighlight">\(x^T B \geq \gamma^{* } x^T A\)</span>。类似地，如果<span class="math notranslate nohighlight">\(\gamma^*&lt;\beta_0\)</span>，不存在半正向量<span class="math notranslate nohighlight">\(p\)</span>满足<span class="math notranslate nohighlight">\(Bp \leq \gamma^{* } Ap\)</span>。令<span class="math notranslate nohighlight">\(\gamma^{* }\in[\beta_0, \alpha_0]\)</span>，则<span class="math notranslate nohighlight">\(x_0^T B \geq \alpha_0 x_0^T A \geq \gamma^{* } x_0^T A\)</span>。此外，<span class="math notranslate nohighlight">\(Bp_0\leq \beta_0 A p_0\leq \gamma^* A p_0\)</span>。这两个不等式意味着<span class="math notranslate nohighlight">\(x_0\left(B - \gamma^{* } A\right)p_0 = 0\)</span>。</p>
</div>
<p>这里常数<span class="math notranslate nohighlight">\(\gamma^{*}\)</span>既是扩张因子也是利息因子（不一定是最优的）。</p>
<p>我们已经遇到并讨论了前两个表示可行性和无利润条件的不等式。</p>
<p>此外，等式<span class="math notranslate nohighlight">\(x_0^T\left(B-\gamma^{* } A\right)p_0 = 0\)</span>简洁地表达了</p>
<p>如果任何商品的增长率大于<span class="math notranslate nohighlight">\(\gamma^{*}\)</span>（即<em>供过于求</em>），那么其价格必须为零；如果任何生产活动产生负利润，则该活动必须停止。</p>
<p>因此，定理I中所述的条件包含了所有均衡条件。</p>
<p>所以定理I本质上表明，在假设I和II下，总是存在具有平衡增长的均衡<span class="math notranslate nohighlight">\(\left(\gamma^{*}, x_0, p_0\right)\)</span>。</p>
<p>注意，定理I并未说明均衡的唯一性。事实上，它并不排除<span class="math notranslate nohighlight">\(x_0^TBp_0 = 0\)</span>的（平凡）情况，即没有产生任何有价值的产出。</p>
<p>为了排除这些无关紧要的情况，Kemeny、Morgenstern和Thompson <span id="id14">[<a class="reference internal" href="zreferences.html#id79" title="John G Kemeny, Oskar Morgenstern, and Gerald L Thompson. A generalization of the von neumann model of an expanding economy. Econometrica, Journal of the Econometric Society, pages 115–135, 1956.">Kemeny <em>et al.</em>, 1956</a>]</span>增加了一个额外要求</p>
<div class="math notranslate nohighlight">
\[
x^T_0 B p_0 &gt; 0
\]</div>
<p>并将相关的均衡称为<em>经济解</em>。</p>
<p>他们证明了这个额外条件不影响均衡的存在性，同时显著减少了（相关）解的数量。</p>
</section>
<section id="id15">
<h2><a class="toc-backref" href="#id32"><span class="section-number">18.5. </span>作为零和双人博弈的解释</a><a class="headerlink" href="#id15" title="Permalink to this heading">#</a></h2>
<p>为了计算均衡 <span class="math notranslate nohighlight">\((\gamma^{*}, x_0, p_0)\)</span>，我们遵循 Hamburger、Thompson 和 Weil (1967) 提出的算法，基于这样一个关键洞察：均衡(伴随平衡增长)可以解决一个特定的零和双人博弈。
首先，我们引入一些符号。</p>
<p>考虑 <span class="math notranslate nohighlight">\(m\times n\)</span> 矩阵 <span class="math notranslate nohighlight">\(C\)</span> 作为支付矩阵，其中的元素表示从<strong>最小化</strong>的列玩家到<strong>最大化</strong>的行玩家的支付，并假设玩家可以使用混合策略。因此，</p>
<ul class="simple">
<li><p>行玩家选择 <span class="math notranslate nohighlight">\(m\)</span> 维向量 <span class="math notranslate nohighlight">\(x &gt; \mathbf{0}\)</span>，满足 <span class="math notranslate nohighlight">\(\iota_m^T x = 1\)</span></p></li>
<li><p>列玩家选择 <span class="math notranslate nohighlight">\(n\)</span> 维向量 <span class="math notranslate nohighlight">\(p &gt; \mathbf{0}\)</span>，满足 <span class="math notranslate nohighlight">\(\iota_n^T p = 1\)</span></p></li>
</ul>
<p><strong>定义：</strong> <span class="math notranslate nohighlight">\(m\times n\)</span> 矩阵博弈 <span class="math notranslate nohighlight">\(C\)</span> 在混合策略中有<em>解</em> <span class="math notranslate nohighlight">\((x^*, p^*, V(C))\)</span>，如果</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}
\begin{aligned}
(x^* )^T C e^j \geq V(C)\quad \forall j\in\{1, \dots, n\}\quad \quad\\\text{且}\quad\quad (e^i)^T C p^* \leq V(C)\quad \forall i\in\{1, \dots, m\}
\end{aligned}
\end{aligned}\end{align} \]</div>
<p>数值 <span class="math notranslate nohighlight">\(V(C)\)</span> 被称为博弈的<em>值</em>。</p>
<p>从上述定义可以清楚地看出，值 <span class="math notranslate nohighlight">\(V(C)\)</span> 有两种解释：</p>
<ul class="simple">
<li><p>通过采用适当的混合策略，最大化玩家可以确保至少获得 <span class="math notranslate nohighlight">\(V(C)\)</span>（无论列玩家如何选择）</p></li>
<li><p>通过采用适当的混合策略，最小化玩家可以确保最大化玩家获得的不会超过 <span class="math notranslate nohighlight">\(V(C)\)</span>（无论最大化玩家如何选择）</p></li>
</ul>
<p>Nash (1951) 的一个著名定理告诉我们，任何<em>有限</em>的双人零和博弈总是存在混合策略纳什均衡。</p>
<p>此外，冯·诺依曼的极小极大定理 <span id="id16">[<a class="reference internal" href="zreferences.html#id77" title="John von Neumann. Zur theorie der gesellschaftsspiele. Mathematische annalen, 100(1):295–320, 1928.">von Neumann, 1928</a>]</span> 表明</p>
<div class="math notranslate nohighlight">
\[
V(C) = \max_x \min_p \hspace{2mm} x^T C p = \min_p \max_x \hspace{2mm} x^T C p = (x^*)^T C p^*
\]</div>
<section id="lp">
<h3><span class="section-number">18.5.1. </span>与线性规划(LP)的联系<a class="headerlink" href="#lp" title="Permalink to this heading">#</a></h3>
<p>有限双人零和博弈的纳什均衡可以解决一个线性规划问题。</p>
<p>为了说明这一点，我们引入以下符号</p>
<ul class="simple">
<li><p>对于固定的 <span class="math notranslate nohighlight">\(x\)</span>，令 <span class="math notranslate nohighlight">\(v\)</span> 为最小化问题的值：<span class="math notranslate nohighlight">\(v \equiv \min_p x^T C p = \min_j x^T C e^j\)</span></p></li>
<li><p>对于固定的 <span class="math notranslate nohighlight">\(p\)</span>，令 <span class="math notranslate nohighlight">\(u\)</span> 为最大化问题的值：<span class="math notranslate nohighlight">\(u \equiv \max_x x^T C p = \max_i (e^i)^T C p\)</span></p></li>
</ul>
<p>那么，从最大化玩家角度来看的<em>最大最小问题</em>可以写成<em>原始</em>线性规划问题</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
V(C) = &amp; \max \hspace{2mm} v \\
\text{s.t. } \hspace{2mm} v \iota_n^T &amp;\leq x^T C  \\
x &amp;\geq \mathbf{0} \\
\iota_n^T x &amp; = 1
\end{aligned}
\end{split}\]</div>
<p>而从最小化玩家角度来看的<em>最小最大问题</em>是<em>对偶</em>线性规划问题</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
V(C) = &amp;\min \hspace{2mm} u \\
\text{s.t. } \hspace{2mm}u \iota_m &amp;\geq Cp  \\
p &amp;\geq \mathbf{0} \\
\iota_m^T p &amp; = 1
\end{aligned}
\end{split}\]</div>
<p>Hamburger、Thompson和Weil <span id="id17">[<a class="reference internal" href="zreferences.html#id80" title="Michael J Hamburger, Gerald L Thompson, and Roman L Weil. Computation of expansion rates for the generalized von neumann model of an expanding economy. Econometrica, Journal of the Econometric Society, pages 542–547, 1967.">Hamburger <em>et al.</em>, 1967</a>]</span> 将经济的投入产出对视为双人零和博弈的收益矩阵。</p>
<p>使用这种解释，他们将假设I和II重述如下</p>
<div class="math notranslate nohighlight">
\[
V(-A) &lt; 0\quad\quad \text{和}\quad\quad V(B)&gt;0
\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>证明（概要）</em>:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\Rightarrow\)</span> <span class="math notranslate nohighlight">\(V(B)&gt;0\)</span> 意味着
<span class="math notranslate nohighlight">\(x_0^T B \gg \mathbf{0}\)</span>，其中 <span class="math notranslate nohighlight">\(x_0\)</span> 是最大化
向量。由于 <span class="math notranslate nohighlight">\(B\)</span> 是非负的，这要求 <span class="math notranslate nohighlight">\(B\)</span> 的每一
列至少有一个正项，这就是假设I。</p></li>
<li><p><span class="math notranslate nohighlight">\(\Leftarrow\)</span> 从假设I和事实
<span class="math notranslate nohighlight">\(p&gt;\mathbf{0}\)</span> 可知，<span class="math notranslate nohighlight">\(Bp &gt; \mathbf{0}\)</span>。
这意味着最大化玩家总能选择 <span class="math notranslate nohighlight">\(x\)</span>
使得 <span class="math notranslate nohighlight">\(x^TBp&gt;0\)</span>，因此必然有
<span class="math notranslate nohighlight">\(V(B)&gt;0\)</span>。</p></li>
</ul>
</div>
<p>为了用特定的双人零和博弈重述定理I，我们定义一个矩阵，对于 <span class="math notranslate nohighlight">\(\gamma\in\mathbb{R}\)</span></p>
<div class="math notranslate nohighlight">
\[
M(\gamma) \equiv B - \gamma A
\]</div>
<p>对于固定的 <span class="math notranslate nohighlight">\(\gamma\)</span>，将 <span class="math notranslate nohighlight">\(M(\gamma)\)</span> 视为一个矩阵博弈，</p>
<p>计算博弈的解意味着</p>
<ul class="simple">
<li><p>如果 <span class="math notranslate nohighlight">\(\gamma &gt; \alpha_0\)</span>，那么对于所有 <span class="math notranslate nohighlight">\(x&gt;0\)</span>，存在
<span class="math notranslate nohighlight">\(j\in\{1, \dots, n\}\)</span>，使得
<span class="math notranslate nohighlight">\([x^T M(\gamma)]_j &lt; 0\)</span>，这意味着
<span class="math notranslate nohighlight">\(V(M(\gamma)) &lt; 0\)</span>。</p></li>
<li><p>如果 <span class="math notranslate nohighlight">\(\gamma &lt; \beta_0\)</span>，那么对于所有 <span class="math notranslate nohighlight">\(p&gt;0\)</span>，存在
<span class="math notranslate nohighlight">\(i\in\{1, \dots, m\}\)</span>，使得
<span class="math notranslate nohighlight">\([M(\gamma)p]_i &gt; 0\)</span>，这意味着 <span class="math notranslate nohighlight">\(V(M(\gamma)) &gt; 0\)</span>。</p></li>
<li><p>如果 <span class="math notranslate nohighlight">\(\gamma \in \{\beta_0, \alpha_0\}\)</span>，那么（根据定理I）最优
强度和价格向量 <span class="math notranslate nohighlight">\(x_0\)</span> 和 <span class="math notranslate nohighlight">\(p_0\)</span>
满足</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
\begin{aligned}
x_0^T M(\gamma) \geq \mathbf{0}^T \quad \quad \text{和}\quad\quad M(\gamma) p_0 \leq \mathbf{0}
\end{aligned}
\]</div>
<p>也就是说，<span class="math notranslate nohighlight">\((x_0, p_0, 0)\)</span> 是博弈
<span class="math notranslate nohighlight">\(M(\gamma)\)</span> 的解，因此
<span class="math notranslate nohighlight">\(V\left(M(\beta_0)\right) = V\left(M(\alpha_0)\right) = 0\)</span>。</p>
<ul class="simple">
<li><p>如果 <span class="math notranslate nohighlight">\(\beta_0 &lt; \alpha_0\)</span> 且
<span class="math notranslate nohighlight">\(\gamma \in (\beta_0, \alpha_0)\)</span>，那么 <span class="math notranslate nohighlight">\(V(M(\gamma)) = 0\)</span>。</p></li>
</ul>
<p>此外，如果 <span class="math notranslate nohighlight">\(x'\)</span> 是在
<span class="math notranslate nohighlight">\(\gamma'\in(\beta_0, \alpha_0)\)</span> 时博弈
<span class="math notranslate nohighlight">\(M(\gamma')\)</span> 中最大化玩家的最优策略且</p>
<p><span class="math notranslate nohighlight">\(p''\)</span> 对于 <span class="math notranslate nohighlight">\(M(\gamma'')\)</span> 中的最小化玩家来说是最优的，其中 <span class="math notranslate nohighlight">\(\gamma''\in(\beta_0, \gamma')\)</span>，那么 <span class="math notranslate nohighlight">\((x', p'', 0)\)</span> 对于所有 <span class="math notranslate nohighlight">\(\gamma\in (\gamma'', \gamma')\)</span> 都是 <span class="math notranslate nohighlight">\(M(\gamma)\)</span> 的解。</p>
<p><em>证明（概要）：</em> 如果 <span class="math notranslate nohighlight">\(x'\)</span> 对于游戏 <span class="math notranslate nohighlight">\(M(\gamma')\)</span> 中的最大化玩家是最优的，那么 <span class="math notranslate nohighlight">\((x')^T M(\gamma')\geq \mathbf{0}^T\)</span>，因此对于所有 <span class="math notranslate nohighlight">\(\gamma&lt;\gamma'\)</span>：</p>
<div class="math notranslate nohighlight">
\[
(x')^T M(\gamma) = (x')^T M(\gamma') + (x')^T(\gamma' - \gamma)A \geq \mathbf{0}^T
\]</div>
<p>因此 <span class="math notranslate nohighlight">\(V(M(\gamma))\geq 0\)</span>。如果 <span class="math notranslate nohighlight">\(p''\)</span> 对于游戏 <span class="math notranslate nohighlight">\(M(\gamma'')\)</span> 中的最小化玩家是最优的，那么 <span class="math notranslate nohighlight">\(M(\gamma)p \leq \mathbf{0}\)</span>，因此对于所有 <span class="math notranslate nohighlight">\(\gamma''&lt;\gamma\)</span>：</p>
<div class="math notranslate nohighlight">
\[
M(\gamma)p'' = M(\gamma'') + (\gamma'' - \gamma)Ap'' \leq \mathbf{0}
\]</div>
<p>因此 <span class="math notranslate nohighlight">\(V(M(\gamma))\leq 0\)</span>。</p>
<p>从上述论证中可以清楚地看出，<span class="math notranslate nohighlight">\(\beta_0\)</span>、<span class="math notranslate nohighlight">\(\alpha_0\)</span> 是使得 <span class="math notranslate nohighlight">\(V(M(\gamma))=0\)</span> 的最小和最大的 <span class="math notranslate nohighlight">\(\gamma\)</span> 值。</p>
<p>此外，Hamburger等人<span id="id18">[<a class="reference internal" href="zreferences.html#id80" title="Michael J Hamburger, Gerald L Thompson, and Roman L Weil. Computation of expansion rates for the generalized von neumann model of an expanding economy. Econometrica, Journal of the Econometric Society, pages 542–547, 1967.">Hamburger <em>et al.</em>, 1967</a>]</span>证明了函数 <span class="math notranslate nohighlight">\(\gamma \mapsto V(M(\gamma))\)</span> 是连续的且关于 <span class="math notranslate nohighlight">\(\gamma\)</span> 单调递减的。</p>
<p>这表明了一个算法来计算给定输入-输出对<span class="math notranslate nohighlight">\((A, B)\)</span>的<span class="math notranslate nohighlight">\((\alpha_0, x_0)\)</span>和<span class="math notranslate nohighlight">\((\beta_0, p_0)\)</span>。</p>
</section>
<section id="id19">
<h3><span class="section-number">18.5.2. </span>算法<a class="headerlink" href="#id19" title="Permalink to this heading">#</a></h3>
<p>Hamburger、Thompson和Weil <span id="id20">[<a class="reference internal" href="zreferences.html#id80" title="Michael J Hamburger, Gerald L Thompson, and Roman L Weil. Computation of expansion rates for the generalized von neumann model of an expanding economy. Econometrica, Journal of the Econometric Society, pages 542–547, 1967.">Hamburger <em>et al.</em>, 1967</a>]</span>提出了一个简单的二分法算法来找到函数<span class="math notranslate nohighlight">\(\gamma \mapsto V(M(\gamma))\)</span>的最小和最大根(即<span class="math notranslate nohighlight">\(\beta_0\)</span>和<span class="math notranslate nohighlight">\(\alpha_0\)</span>)。</p>
<section id="id21">
<h4><span class="section-number">18.5.2.1. </span>第1步<a class="headerlink" href="#id21" title="Permalink to this heading">#</a></h4>
<p>首先，注意到我们可以很容易地为<span class="math notranslate nohighlight">\(\alpha_0\)</span>和<span class="math notranslate nohighlight">\(\beta_0\)</span>找到简单的上下界。</p>
<ul class="simple">
<li><p>TEP要求<span class="math notranslate nohighlight">\(x^T(B-\alpha A)\geq \mathbf{0}^T\)</span>且<span class="math notranslate nohighlight">\(x &gt; \mathbf{0}\)</span>，所以如果<span class="math notranslate nohighlight">\(\alpha\)</span>大到使得<span class="math notranslate nohighlight">\(\max_i\{[(B-\alpha A)\iota_n]_i\} &lt; 0\)</span>，那么TEP将不再有解。</p></li>
</ul>
<p>相应地，令**<code class="docutils literal notranslate"><span class="pre">UB</span></code>**为满足<span class="math notranslate nohighlight">\(\max_i\{[(B-\alpha^{*} A)\iota_n]_i\} = 0\)</span>的<span class="math notranslate nohighlight">\(\alpha^{*}\)</span>。</p>
<ul class="simple">
<li><p>类似于上界，如果<span class="math notranslate nohighlight">\(\beta\)</span>低到使得<span class="math notranslate nohighlight">\(\min_j\{[\iota^T_m(B-\beta A)]_j\}&gt;0\)</span>，那么EEP将没有解，因此我们可以定义**<code class="docutils literal notranslate"><span class="pre">LB</span></code>**为满足<span class="math notranslate nohighlight">\(\min_j\{[\iota^T_m(B-\beta^{*} A)]_j\}=0\)</span>的<span class="math notranslate nohighlight">\(\beta^{*}\)</span>。</p></li>
</ul>
<p><em>bounds</em> 方法为我们计算这些基本边界</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n1</span><span class="o">.</span><span class="n">bounds</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(1.0, 2.0)
</pre></div>
</div>
</div>
</div>
</section>
<section id="id22">
<h4><span class="section-number">18.5.2.2. </span>步骤 2<a class="headerlink" href="#id22" title="Permalink to this heading">#</a></h4>
<p>计算 <span class="math notranslate nohighlight">\(\alpha_0\)</span> 和 <span class="math notranslate nohighlight">\(\beta_0\)</span></p>
<ul class="simple">
<li><p>求解 <span class="math notranslate nohighlight">\(\alpha_0\)</span></p>
<ol class="arabic simple">
<li><p>固定 <span class="math notranslate nohighlight">\(\gamma = \frac{UB + LB}{2}\)</span> 并计算与 <span class="math notranslate nohighlight">\(M(\gamma)\)</span>
相关的双人零和博弈的解。我们可以使用原始或对偶
线性规划问题。</p></li>
<li><p>如果 <span class="math notranslate nohighlight">\(V(M(\gamma)) \geq 0\)</span>，则令 <span class="math notranslate nohighlight">\(LB = \gamma\)</span>，
否则令 <span class="math notranslate nohighlight">\(UB = \gamma\)</span>。</p></li>
<li><p>重复步骤1和2，直到 <span class="math notranslate nohighlight">\(|UB - LB| &lt; \epsilon\)</span>。</p></li>
</ol>
</li>
<li><p>求解 <span class="math notranslate nohighlight">\(\beta_0\)</span></p>
<ol class="arabic simple">
<li><p>固定 <span class="math notranslate nohighlight">\(\gamma = \frac{UB + LB}{2}\)</span> 并计算与 <span class="math notranslate nohighlight">\(M(\gamma)\)</span>
相关的双人零和博弈的解。我们可以使用原始或对偶
线性规划问题。</p></li>
<li><p>如果 <span class="math notranslate nohighlight">\(V(M(\gamma)) &gt; 0\)</span>，则令 <span class="math notranslate nohighlight">\(LB = \gamma\)</span>，
否则令 <span class="math notranslate nohighlight">\(UB = \gamma\)</span>。</p></li>
<li><p>重复步骤1和2，直到 <span class="math notranslate nohighlight">\(|UB - LB| &lt; \epsilon\)</span>。</p></li>
</ol>
</li>
<li><p><em>存在性</em>：由于 <span class="math notranslate nohighlight">\(V(M(LB))&gt;0\)</span> 且 <span class="math notranslate nohighlight">\(V(M(UB))&lt;0\)</span>，并且
<span class="math notranslate nohighlight">\(V(M(\cdot))\)</span> 是连续的单调递减函数，因此在
<span class="math notranslate nohighlight">\([LB, UB]\)</span> 区间内至少存在一个 <span class="math notranslate nohighlight">\(\gamma\)</span>，使得 <span class="math notranslate nohighlight">\(V(M(\gamma))=0\)</span>。</p></li>
</ul>
<p><em>zerosum</em> 方法计算与给定 <span class="math notranslate nohighlight">\(\gamma\)</span> 相关的值和最优策略。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">γ</span> <span class="o">=</span> <span class="mi">2</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;游戏在 γ = </span><span class="si">{</span><span class="n">γ</span><span class="si">}</span><span class="s1"> 时的值&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">n1</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">γ</span><span class="o">=</span><span class="n">γ</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;强度向量（来自原问题）&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">n1</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">γ</span><span class="o">=</span><span class="n">γ</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;价格向量（来自对偶问题）&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">n1</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">γ</span><span class="o">=</span><span class="n">γ</span><span class="p">,</span> <span class="n">dual</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>游戏在 γ = 2 时的值
-0.24
强度向量（来自原问题）
[0.32 0.28 0.4 ]
价格向量（来自对偶问题）
[0.4  0.32 0.28 0.  ]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">numb_grid</span> <span class="o">=</span> <span class="mi">100</span>
<span class="n">γ_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">2.1</span><span class="p">,</span> <span class="n">numb_grid</span><span class="p">)</span>

<span class="n">value_ex1_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">n1</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">γ</span><span class="o">=</span><span class="n">γ_grid</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numb_grid</span><span class="p">)])</span>
<span class="n">value_ex2_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">n2</span><span class="o">.</span><span class="n">zerosum</span><span class="p">(</span><span class="n">γ</span><span class="o">=</span><span class="n">γ_grid</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numb_grid</span><span class="p">)])</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;函数 $V(M(\gamma))$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="p">(</span><span class="n">value_ex1_grid</span><span class="p">,</span> <span class="n">value_ex2_grid</span><span class="p">),</span>
                          <span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">γ_grid</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;示例 </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;$\gamma$&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">bounds</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;下界&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">N</span><span class="o">.</span><span class="n">bounds</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;上界&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;&gt;:15: SyntaxWarning: invalid escape sequence &#39;\g&#39;
&lt;&gt;:15: SyntaxWarning: invalid escape sequence &#39;\g&#39;
/tmp/ipykernel_12273/2817727682.py:15: SyntaxWarning: invalid escape sequence &#39;\g&#39;
  ax.set(title=f&#39;示例 {i}&#39;, xlabel=&#39;$\gamma$&#39;)
</pre></div>
</div>
<img alt="_images/4447e03d4efdf07b820f478cdd4bbbee9aed529f495a1ffbaf2cd5e06e377ddc.png" src="_images/4447e03d4efdf07b820f478cdd4bbbee9aed529f495a1ffbaf2cd5e06e377ddc.png" />
</div>
</div>
<p><em>扩展</em>方法实现了对<span class="math notranslate nohighlight">\(\alpha_0\)</span>的二分法算法（并使用原始LP问题求解<span class="math notranslate nohighlight">\(x_0\)</span>）</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">α_0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">n1</span><span class="o">.</span><span class="n">expansion</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;α_0 = </span><span class="si">{</span><span class="n">α_0</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;x_0 = </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;对偶问题得到的相应p值 = </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>α_0 = 1.2599210478365421
x_0 = [0.33 0.26 0.41]
对偶问题得到的相应p值 = [0.41 0.33 0.26 0.  ]
</pre></div>
</div>
</div>
</div>
<p><em>interest</em> 方法使用二分法算法求解 <span class="math notranslate nohighlight">\(\beta_0\)</span> (并使用对偶线性规划问题求解 <span class="math notranslate nohighlight">\(p_0\)</span>)</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">β_0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">n1</span><span class="o">.</span><span class="n">interest</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;β_0 = </span><span class="si">{</span><span class="n">β_0</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;p_0 = </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The corresponding x from the primal = </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>β_0 = 1.2599210478365421
p_0 = [0.41 0.33 0.26 0.  ]
The corresponding x from the primal = [0.33 0.26 0.41]
</pre></div>
</div>
</div>
</div>
<p>当然，当 <span class="math notranslate nohighlight">\(\gamma^*\)</span> 是唯一的时候，我们使用哪种方法都无所谓 – 两种方法都可行。</p>
<p>特别是，如下所示，在 <span class="math notranslate nohighlight">\((A,B)\)</span> 不可约的情况下（如例1所示），<span class="math notranslate nohighlight">\(V(M(\gamma))\)</span> 的最大根和最小根必然相同，这意味着存在”完全对偶”结果，即 <span class="math notranslate nohighlight">\(\alpha_0 = \beta_0 = \gamma^*\)</span>，因此扩张（和利息）率 <span class="math notranslate nohighlight">\(\gamma^*\)</span> 是唯一的。</p>
</section>
</section>
<section id="id23">
<h3><span class="section-number">18.5.3. </span>唯一性和不可约性<a class="headerlink" href="#id23" title="Permalink to this heading">#</a></h3>
<p>作为说明，让我们首先计算例2中可约输入输出对 <span class="math notranslate nohighlight">\((A, B)\)</span> 的 <span class="math notranslate nohighlight">\(V(M(\cdot))\)</span> 的最大根和最小根</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">α_0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">n2</span><span class="o">.</span><span class="n">expansion</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;α_0 = </span><span class="si">{</span><span class="n">α_0</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;x_0 = </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The corresponding p from the dual = </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>α_0 = 1.259921052493155
x_0 = [5.27e-10 0.00e+00 3.27e-01 2.60e-01 4.13e-01]
The corresponding p from the dual = [0.   0.21 0.33 0.26 0.21 0.  ]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">β_0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">n2</span><span class="o">.</span><span class="n">interest</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;β_0 = </span><span class="si">{</span><span class="n">β_0</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;p_0 = </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;对偶问题得到的原问题解为 = </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>β_0 = 1.0000000009313226
p_0 = [ 5.00e-01  5.00e-01 -1.55e-09 -1.24e-09 -9.31e-10  0.00e+00]
对偶问题得到的原问题解为 = [-0.    0.    0.25  0.25  0.5 ]
</pre></div>
</div>
</div>
</div>
<p>如我们所见，当<span class="math notranslate nohighlight">\((A,B)\)</span>可约时，二分法算法找到的根可能不同，因此可能存在多个使得博弈<span class="math notranslate nohighlight">\(M(\gamma^*)\)</span>的值为零的<span class="math notranslate nohighlight">\(\gamma^*\)</span>（见上图）。</p>
<p>事实上，虽然冯·诺依曼定理保证了均衡的存在性，但假设I和II并不足以保证唯一性。尽管如此，Kemeny等人(1967)证明了经济解的数量至多是有限的，这意味着只有有限个<span class="math notranslate nohighlight">\(\gamma^*\)</span>满足<span class="math notranslate nohighlight">\(V(M(\gamma^*)) = 0\)</span>和<span class="math notranslate nohighlight">\(x_0^TBp_0 &gt; 0\)</span>，并且对于每个这样的<span class="math notranslate nohighlight">\(\gamma^*_i\)</span>，都存在一个经济体的自包含部分（子经济体），在均衡状态下可以以扩张系数<span class="math notranslate nohighlight">\(\gamma^*_i\)</span>独立扩张。</p>
<p>以下定理（参见Gale <span id="id24">[<a class="reference internal" href="zreferences.html#id81" title="David Gale. The theory of linear economic models. University of Chicago press, 1989.">Gale, 1989</a>]</span>中的定理9.10）断言，施加不可约性条件足以保证<span class="math notranslate nohighlight">\((\gamma^*, x_0, p_0)\)</span>的唯一性。</p>
<p>**定理II：**采用定理1的条件。如果经济体</p>
<p><span class="math notranslate nohighlight">\((A,B)\)</span> 不可约，则 <span class="math notranslate nohighlight">\(\gamma^*=\alpha_0=\beta_0\)</span>。</p>
</section>
<section id="id25">
<h3><span class="section-number">18.5.4. </span>特殊情况<a class="headerlink" href="#id25" title="Permalink to this heading">#</a></h3>
<p>有一种特殊的 <span class="math notranslate nohighlight">\((A,B)\)</span> 允许我们通过引用非负矩阵的 Perron-Frobenius 定理来显著简化求解方法。</p>
<p><strong>定义：</strong> 如果一个经济满足以下条件，我们称之为<em>简单</em>经济：</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(n=m\)</span></p></li>
<li><p>每个生产活动恰好生产一种商品</p></li>
<li><p>每种商品恰好由一个生产活动生产</p></li>
</ul>
<p>这些假设意味着 <span class="math notranslate nohighlight">\(B=I_n\)</span>，即 <span class="math notranslate nohighlight">\(B\)</span> 可以写成单位矩阵（可能需要重新排列其行和列）。</p>
<p>简单模型具有以下特殊性质（Gale <span id="id26">[<a class="reference internal" href="zreferences.html#id81" title="David Gale. The theory of linear economic models. University of Chicago press, 1989.">Gale, 1989</a>]</span> 中的定理 9.11）：如果 <span class="math notranslate nohighlight">\(x_0\)</span> 和 <span class="math notranslate nohighlight">\(\alpha_0&gt;0\)</span> 是 <span class="math notranslate nohighlight">\((A,I_n)\)</span> 的 TEP 的解，那么</p>
<div class="math notranslate nohighlight">
\[
x_0^T = \alpha_0 x_0^T A\hspace{1cm}\Leftrightarrow\hspace{1cm}x_0^T
A=\left(\frac{1}{\alpha_0}\right)x_0^T
\]</div>
<p>后者表明 <span class="math notranslate nohighlight">\(1/\alpha_0\)</span> 是 <span class="math notranslate nohighlight">\(A\)</span> 的一个正特征值，而 <span class="math notranslate nohighlight">\(x_0\)</span> 是相应的非负左特征向量。</p>
<p><strong>Perron和Frobenius</strong>的经典结果表明，非负矩阵具有非负的特征值-特征向量对。</p>
<p>此外，如果<span class="math notranslate nohighlight">\(A\)</span>是不可约的，则最优强度向量<span class="math notranslate nohighlight">\(x_0\)</span>是正的，并且在乘以正标量的意义下是<em>唯一</em>的。</p>
<p>假设<span class="math notranslate nohighlight">\(A\)</span>是可约的，具有<span class="math notranslate nohighlight">\(k\)</span>个不可约子集<span class="math notranslate nohighlight">\(S_1,\dots,S_k\)</span>。令<span class="math notranslate nohighlight">\(A_i\)</span>为对应于<span class="math notranslate nohighlight">\(S_i\)</span>的子矩阵，令<span class="math notranslate nohighlight">\(\alpha_i\)</span>和<span class="math notranslate nohighlight">\(\beta_i\)</span>分别为相关的扩张因子和利息因子。那么我们有</p>
<div class="math notranslate nohighlight">
\[
\alpha_0 = \max_i \{\alpha_i\}\hspace{1cm}\text{和}\hspace{1cm}\beta_0 = \min_i \{\beta_i\}
\]</div>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                    </div>
                    
                </main> <!-- .page__content -->
                


                <footer class="qe-page__footer">

                    <p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><img src="https://licensebuttons.net/l/by-sa/4.0/80x15.png"></a></p>

                    <p>Creative Commons License &ndash; This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International.</p>

                    <p>A theme by <a href="https://quantecon.org">QuantEcon</a></p>

                </footer> <!-- .page__footer -->

            </div> <!-- .page -->

            

            
            <div class="qe-sidebar bd-sidebar inactive" id="site-navigation">

                <div class="qe-sidebar__header">


                    Contents

                </div>

                <nav class="qe-sidebar__nav" id="qe-sidebar-nav" aria-label="Main navigation">
                    <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  工具与技术
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="sir_model.html">
   1. 新冠病毒建模
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="linear_algebra.html">
   2. 线性代数
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="qr_decomp.html">
   3. QR分解
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="eig_circulant.html">
   4. 循环矩阵
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="svd_intro.html">
   5. 奇异值分解（SVD）
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="var_dmd.html">
   6. 向量自回归和动态模态分解
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="newton_method.html">
   7. 使用牛顿法求解经济模型
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  基础统计学
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="prob_matrix.html">
   8. 基础概率论与矩阵
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lln_clt.html">
   9. 大数定律 和 中心极限定理
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="prob_meaning.html">
   10. 概率的两种含义
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="multi_hyper.html">
   11. 多元超几何分布
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="multivariate_normal.html">
   12. 多元正态分布
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="hoist_failure.html">
   13. 故障树不确定性
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="back_prop.html">
   14. 人工神经网络简介
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="rand_resp.html">
   15. 随机化回应调查
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="util_rand_resp.html">
   16. 随机回答的期望效用
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  线性规划
 </span>
</p>
<ul class="current nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="opt_transport.html">
   17. 最优传输
  </a>
 </li>
 <li class="toctree-l1 current active active">
  <a class="current reference internal" href="#">
   18. 冯·诺依曼增长模型（及其推广）
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  动态系统导论
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="finite_markov.html">
   19. 有限马尔可夫链
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="inventory_dynamics.html">
   20. 库存动态
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="linear_models.html">
   21. 线性状态空间模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="samuelson.html">
   22. 萨缪尔森乘数-加速器模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="kesten_processes.html">
   23. Kesten过程与企业动态
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="wealth_dynamics.html">
   24. 财富分配动态
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="kalman.html">
   25. 卡尔曼滤波初探
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="kalman_2.html">
   26. 卡尔曼滤波器的另一个视角
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  搜索
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="mccall_model.html">
   27. 求职搜索 I: McCall搜寻模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mccall_model_with_separation.html">
   28. 求职搜索 II：搜寻与离职
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mccall_fitted_vfi.html">
   29. 求职搜索 III: 拟合值函数迭代
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mccall_correlated.html">
   30. 求职搜索 IV：相关工资报价
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="career.html">
   31. 求职搜索 V：职业选择建模
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="jv.html">
   32. 求职搜索 VI：在职搜索
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mccall_q.html">
   33. 求职搜索 VII：McCall劳动者的Q学习
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  消费、储蓄与资本
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="cass_koopmans_1.html">
   34. Cass-Koopmans模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cass_koopmans_2.html">
   35. Cass-Koopmans竞争均衡
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cass_fiscal.html">
   36. 带扭曲性税收的Cass-Koopmans模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ak2.html">
   37. 重叠世代模型中的转换
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cake_eating_problem.html">
   38. 蛋糕食用问题 I：最优储蓄导论
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cake_eating_numerical.html">
   39. 蛋糕食用问题 II：数值方法
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="optgrowth.html">
   40. 最优增长 I：随机最优增长模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="optgrowth_fast.html">
   41. 最优增长 II：使用Numba加速代码
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="coleman_policy_iter.html">
   42. 最优增长 III：时间迭代
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="egm_policy_iter.html">
   43. 最优增长 IV：内生网格法
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ifp.html">
   44. 收入波动问题 I：基本模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ifp_advanced.html">
   45. 收入波动问题 II：资产随机收益
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  贝叶斯定律
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="bayes_nonconj.html">
   46. 非共轭先验
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ar1_bayes.html">
   47. AR(1)参数的后验分布
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ar1_turningpts.html">
   48. 预测 AR(1) 过程
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  信息论
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="odu.html">
   49. 求职搜索 VII: 带学习的搜索
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="likelihood_ratio_process.html">
   50. 似然比过程
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="imp_sample.html">
   51. 计算似然比过程的均值
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="wald_friedman.html">
   52. 让弥尔顿·弗里德曼困惑的问题
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="exchangeable.html">
   53. 可交换性和贝叶斯更新
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="likelihood_bayes.html">
   54. 似然比过程和贝叶斯学习
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mix_model.html">
   55. 错误模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="navy_captain.html">
   56. 贝叶斯与频率主义决策规则的比较
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  LQ控制
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="lqcontrol.html">
   57. LQ控制：基础
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lagrangian_lqdp.html">
   58. LQ控制的拉格朗日方法
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cross_product_trick.html">
   59. 消除交叉项
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="perm_income.html">
   60. 永久收入模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="perm_income_cons.html">
   61. 永久收入 II：线性二次方法
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lq_inventories.html">
   62. 通过库存实现生产平滑
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  多主体模型
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="lake_model.html">
   63. 就业和失业的湖泊模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="rational_expectations.html">
   64. 理性预期均衡
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="re_with_feedback.html">
   65. 线性理性预期模型中的稳定性
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="markov_perf.html">
   66. 马尔可夫完美均衡
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="uncertainty_traps.html">
   67. 不确定性陷阱
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="aiyagari.html">
   68. 艾亚加里模型
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  资产定价与金融
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="markov_asset.html">
   69. 资产定价：有限状态模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ge_arrow.html">
   70. 带有阿罗证券的竞争均衡
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="harrison_kreps.html">
   71. 异质信念与泡沫
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  数据与实证
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="pandas_panel.html">
   72. 面板数据的Pandas使用
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ols.html">
   73. Python线性回归
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mle.html">
   74. 最大似然估计
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  拍卖
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="two_auctions.html">
   75. 一价和二价拍卖
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="house_auction.html">
   76. 多种商品分配机制
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  其他
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="troubleshooting.html">
   77. 故障排除
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="zreferences.html">
   78. 参考文献
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="status.html">
   79. 执行统计
  </a>
 </li>
</ul>

                </nav>

                <div class="qe-sidebar__footer">

                </div>

            </div> <!-- .sidebar -->
            
        </div> <!-- .main -->

        <div class="qe-toolbar">

            <div class="qe-toolbar__inner">

                <ul class="qe-toolbar__main">
                    <li data-tippy-content="Table of Contents" class="btn__sidebar"><i data-feather="menu"></i></li>
                    <li data-tippy-content="Home"><a href="intro.html"><i data-feather="home"></i></a></li>
                    <li class="btn__qelogo"><a href="https://quantecon.org" title=""><span class="show-for-sr">QuantEcon</span></a></li>
                </ul>

                <ul class="qe-toolbar__links">
                    <li class="btn__search">
                        <form action="search.html" method="get">
                            <input type="search" class="form-control" name="q" id="search-input" placeholder="Search..." aria-label="Search..." autocomplete="off" accesskey="k">
                            <i data-feather="search" id="search-icon"></i>
                        </form>
                    </li>
                    <li data-tippy-content="Fullscreen" class="btn__fullscreen"><i data-feather="maximize"></i></li>
                    <li data-tippy-content="Increase font size" class="btn__plus"><i data-feather="plus-circle"></i></li>
                    <li data-tippy-content="Decrease font size" class="btn__minus"><i data-feather="minus-circle"></i></li>
                    <li data-tippy-content="Change contrast" class="btn__contrast"><i data-feather="sunset"></i></li>
                    <li data-tippy-content="Download Notebook"><a href="/_notebooks/von_neumann_model.ipynb" download><i data-feather="download-cloud"></i></a></li>
                    <li class="settings-button" id="settingsButton"><div data-tippy-content="Launch Notebook"><i data-feather="play-circle"></i></div></li>
                        <li data-tippy-content="Download PDF" onClick="window.print()"><i data-feather="file"></i></li>
                    <!--
                    # Enable if looking for link to specific document hosted on GitHub
                    <li data-tippy-content="View Source"><a target="_blank" href="https://github.com/QuantEcon/lecture-python.myst/von_neumann_model.md" download><i data-feather="github"></i></a></li>
                    -->
                    <li data-tippy-content="View Source"><a target="_blank" href="https://github.com/QuantEcon/lecture-python.myst" download><i data-feather="github"></i></a></li>
                </ul>

            </div>

        </div> <!-- .toolbar -->
        <div id="downloadPDFModal" style="display: none;">
            <ul class="pdf-options" style="display: block;">
                <li class="download-pdf-book" onClick="window.print()">
                    <p>Lecture (PDF)</p>
                </li>
                <li class="download-pdf-file">
                    <a href="" download><p>Book (PDF)</p></a>
                </li>
            </ul>
        </div>
        <div id="settingsModal" style="display: none;">
            <p class="modal-title"> Notebook Launcher </p>
            <div class="modal-desc">
            <p>
                Choose public or private cloud service for "Launch" button.
            </p>
            </div>
            <p class="modal-subtitle">Select a server</p>
            <ul class="modal-servers">
            <li class="active launcher-public">
                <span class="label">Public</span>
                <select id="launcher-public-input">
                
                    <option value="https://colab.research.google.com/github/QuantEcon/lecture-python.zh-cn.notebooks/blob/main/von_neumann_model.ipynb">Colab</option>
                
                </select>
                <i class="fas fa-check-circle"></i>
            </li>
            <li class="launcher-private">
                <span class="label">Private</span>
                <input type="text" id="launcher-private-input" data-repourl="https://github.com/QuantEcon/lecture-python.zh-cn.notebooks" data-urlpath="tree/lecture-python.zh-cn.notebooks/von_neumann_model.ipynb" data-branch=main>
                <i class="fas fa-check-circle"></i>
            </li>
            </ul>
            <p class="launch"><a href="https://colab.research.google.com/github/QuantEcon/lecture-python.zh-cn.notebooks/blob/main/von_neumann_model.ipynb" id="advancedLaunchButton" target="_blank">Launch Notebook</a></p>
            <script>
                // QuantEcon Notebook Launcher
                const launcherTypeElements = document.querySelectorAll('#settingsModal .modal-servers li');
                // Highlight the server type if previous selection exists
                if (typeof localStorage.launcherType !== 'undefined') {
                  for (var i = 0; i < launcherTypeElements.length; i++) {
                    launcherTypeElements[i].classList.remove('active');
                    if ( launcherTypeElements[i].classList.contains(localStorage.launcherType) ) {
                      launcherTypeElements[i].classList.add('active');
                    }
                  }
                }
                // Highlight server type on click and set local storage value
                for (var i = 0; i < launcherTypeElements.length; i++) {
                  launcherTypeElements[i].addEventListener('click', function() {
                    for (var j = 0; j < launcherTypeElements.length; j++) {
                      launcherTypeElements[j].classList.remove('active');
                    }
                    this.classList.add('active');
                    if ( this.classList.contains('launcher-private') ) {
                      localStorage.launcherType = 'launcher-private';
                    } else if ( this.classList.contains('launcher-public') ) {
                      localStorage.launcherType = 'launcher-public';
                    }
                    setLaunchServer();
                  })
                }
                const launcherPublic = document.getElementById('launcher-public-input');
                const launcherPrivate = document.getElementById('launcher-private-input');
                const pageName = "von_neumann_model";
                const repoURL = "https://github.com/QuantEcon/lecture-python.zh-cn.notebooks";
                const urlPath = "tree/lecture-python.zh-cn.notebooks/von_neumann_model.ipynb";
                const branch = "main"
                const launchNotebookLink = document.getElementById('advancedLaunchButton');

                // Highlight public server option if previous selection exists
                if (typeof localStorage.launcherPublic !== 'undefined') {
                  launcherPublic.value = localStorage.launcherPublic;
                }
                // Update local storage upon public server selection
                launcherPublic.addEventListener('change', (event) => {
                  setLaunchServer();
                });
                // Populate private server input if previous entry exists
                if (typeof localStorage.launcherPrivate !== 'undefined') {
                  launcherPrivate.value = localStorage.launcherPrivate;
                }
                // Update local storage when a private server is entered
                launcherPrivate.addEventListener('input', (event) => {
                  setLaunchServer();
                });

                // Function to update the "Launch Notebook" link href
                function setLaunchServer() {
                  launchNotebookLink.removeAttribute("style")
                  if ( localStorage.launcherType == 'launcher-private' ) {
                    let repoPrefix = "/user-redirect/git-pull?repo=" + repoURL + "&branch=" + branch + "&urlpath=" + urlPath;
                    launcherPrivateValue = launcherPrivate.value
                    if (!launcherPrivateValue) {
                        launchNotebookLink.removeAttribute("href")
                        launchNotebookLink.style.background = "grey"
                        return
                    }
                    localStorage.launcherPrivate = launcherPrivateValue;
                    privateServer = localStorage.launcherPrivate.replace(/\/$/, "")
                    if (!privateServer.includes("http")) {
                        privateServer = "http://" + privateServer
                    }
                    launchNotebookLinkURL = privateServer + repoPrefix;
                  } else if ( localStorage.launcherType == 'launcher-public' ) {
                    launcherPublicValue = launcherPublic.options[launcherPublic.selectedIndex].value;
                    localStorage.launcherPublic = launcherPublicValue;
                    launchNotebookLinkURL = localStorage.launcherPublic;
                  }
                  if (launchNotebookLinkURL) launchNotebookLink.href = launchNotebookLinkURL;
                }
                // Check if user has previously selected a server
                if ( (typeof localStorage.launcherPrivate !== 'undefined') || (typeof localStorage.launcherPublic !== 'undefined') ) {
                  setLaunchServer();
                }
                </script>

        </div>

    </div> <!-- .wrapper-->
  </body>
</html>