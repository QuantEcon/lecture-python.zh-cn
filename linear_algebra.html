

<!DOCTYPE html>


<html lang="en" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>2. 线性代数 &#8212; Python中级数量经济学</title>
    <script src="https://unpkg.com/@popperjs/core@2.9.2/dist/umd/popper.min.js"></script>
    <script src="https://unpkg.com/tippy.js@6.3.1/dist/tippy-bundle.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
    
        <script>
            MathJax = {
            loader: {load: ['[tex]/boldsymbol', '[tex]/textmacros']},
            tex: {
                packages: {'[+]': ['boldsymbol', 'textmacros']},
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                processEscapes: true,
                macros: {
                    "argmax" : "arg\\,max",
                    "argmin" : "arg\\,min",
                    "col"    : "col",
                    "Span"   :  "span",
                    "epsilon": "\\varepsilon",
                    "EE": "\\mathbb{E}",
                    "PP": "\\mathbb{P}",
                    "RR": "\\mathbb{R}",
                    "NN": "\\mathbb{N}",
                    "ZZ": "\\mathbb{Z}",
                    "aA": "\\mathcal{A}",
                    "bB": "\\mathcal{B}",
                    "cC": "\\mathcal{C}",
                    "dD": "\\mathcal{D}",
                    "eE": "\\mathcal{E}",
                    "fF": "\\mathcal{F}",
                    "gG": "\\mathcal{G}",
                    "hH": "\\mathcal{H}",
                }
            },
            svg: {
                fontCache: 'global',
                scale: 0.92,
                displayAlign: "center",
            },
            };
        </script>
    
    
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/quantecon-book-theme.css?digest=bd0785fbb14d8d2bd4d9ae501d79ed8d3bc089ec" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/exercise.css" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-design.5ea377869091fd0449014c60fc090103.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>


    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/scripts/quantecon-book-theme.js?digest=d9faaf6c4b57726f74ba012412af1f5681bdff87"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js"></script>
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-J0SMYR4SG3"></script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-J0SMYR4SG3');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"argmax": "arg\\,max", "argmin": "arg\\,min"}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'linear_algebra';</script>
    <link rel="canonical" href="https://python.quantecon-zh-cn.org/linear_algebra.html" />
    <link rel="shortcut icon" href="_static/lectures-favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="3. QR分解" href="qr_decomp.html" />
    <link rel="prev" title="1. 新冠病毒建模" href="sir_model.html" />

<!-- Normal Meta Tags -->
<meta name="author" context="Thomas J. Sargent &amp; John Stachurski" />
<meta name="keywords" content="Python, QuantEcon, Quantitative Economics, Economics, Sloan, Alfred P. Sloan Foundation, Tom J. Sargent, John Stachurski" />
<meta name="description" content=本课程是由托马斯·萨金特（Thomas J. Sargent）和约翰·斯塔胡斯基（John Stachurski）设计和编写的数量经济建模讲座。 />

<!-- Twitter tags -->
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@quantecon" />
<meta name="twitter:title" content="线性代数"/>
<meta name="twitter:description" content="本课程是由托马斯·萨金特（Thomas J. Sargent）和约翰·斯塔胡斯基（John Stachurski）设计和编写的数量经济建模讲座。">
<meta name="twitter:creator" content="@quantecon">
<meta name="twitter:image" content="https://assets.quantecon.org/img/qe-twitter-logo.png">

<!-- Opengraph tags -->
<meta property="og:title" content="线性代数" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://python.quantecon-zh-cn.org/linear_algebra.html" />
<meta property="og:image" content="https://assets.quantecon.org/img/qe-og-logo.png" />
<meta property="og:description" content="本课程是由托马斯·萨金特（Thomas J. Sargent）和约翰·斯塔胡斯基（John Stachurski）设计和编写的数量经济建模讲座。" />
<meta property="og:site_name" content="Python中级数量经济学" />
<meta name="theme-color" content="#ffffff" />

  </head>
<body>

<!-- Override QuantEcon theme colors -->

    <span id="top"></span>

    <div class="qe-wrapper">

        <div class="qe-main">

            <div class="qe-page" id=linear_algebra>

                <div class="qe-page__toc">

                    <div class="inner">

                        
                        <div class="qe-page__toc-header">
                            On this page
                        </div>


                        <nav id="bd-toc-nav" class="qe-page__toc-nav">
                            <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">2.1. 概述</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">2.2. 向量</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">2.2.1. 向量运算</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">2.2.2. 内积和范数</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">2.2.3. 张成空间</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">2.2.3.1. 示例</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#la-li">2.2.4. 线性无关</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#la-unique-reps">2.2.5. 唯一表示</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">2.3. 矩阵</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">2.3.1. 矩阵运算</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#numpy">2.3.2. NumPy中的矩阵</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#la-linear-map">2.3.3. 矩阵作为映射</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id15">2.4. 求解方程组</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id16">2.4.1. 方阵的情况</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id17">2.4.1.1. 逆矩阵</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#id18">2.4.1.2. 行列式</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id19">2.4.2. 行数多于列数</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id20">2.4.3. 列数多于行数</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#scipy">2.4.4. 使用SciPy求解线性方程</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#la-eigen">2.5. 特征值和特征向量</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id22">2.5.1. 广义特征值</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id23">2.6. 进阶主题</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id24">2.6.1. 级数展开</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#la-mn">2.6.1.1. 矩阵范数</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#la-neumann">2.6.1.2. 诺伊曼定理</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#la-neumann-remarks">2.6.1.3. 谱半径</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id29">2.6.2. 正定矩阵</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#la-mcalc">2.6.3. 线性和二次型的求导</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id31">2.6.4. 延伸阅读</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id33">2.7. 练习</a></li>
</ul>
                            <p class="logo">
                                
                                    
                                    <a href=https://quantecon.org><img src="_static/qe-logo-large.png" class="logo logo-img" alt="logo"></a>
                                    
                                    
                                
                            </p>

                            <p class="powered">Powered by <a href="https://jupyterbook.org/">Jupyter Book</a></p>

                        </nav>

                        <div class="qe-page__toc-footer">
                            
                            
                            <p><a href="#top"><strong>Back to top</strong></a></p>
                        </div>

                    </div>

                </div>

                <div class="qe-page__header">

                    <div class="qe-page__header-copy">

                        <p class="qe-page__header-heading"><a href="intro.html">Python中级数量经济学</a></p>

                        <p class="qe-page__header-subheading">线性代数</p>

                    </div>
                    <!-- length 2, since its a string and empty dict has length 2 - {} -->
                        <p class="qe-page__header-authors" font-size="18">
                            
                                
                                    <a href="http://www.tomsargent.com/" target="_blank"><span>托马斯·萨金特（Thomas J. Sargent）</span></a>
                                
                            
                                
                                    and <a href="https://johnstachurski.net/" target="_blank"><span>约翰·斯塔胡斯基（John Stachurski）</span></a>
                                
                            
                        </p>


                </div> <!-- .page__header -->



                
                <main class="qe-page__content" role="main">
                    
                    <div>
                        
  <section class="tex2jax_ignore mathjax_ignore" id="id1">
<h1><a class="toc-backref" href="#id34"><span class="section-number">2. </span>线性代数</a><a class="headerlink" href="#id1" title="Permalink to this heading">#</a></h1>
<div class="contents topic" id="id2">
<span id="index-0"></span><p class="topic-title">目录</p>
<ul class="simple">
<li><p><a class="reference internal" href="#id1" id="id34">线性代数</a></p>
<ul>
<li><p><a class="reference internal" href="#id3" id="id35">概述</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id36">向量</a></p></li>
<li><p><a class="reference internal" href="#id11" id="id37">矩阵</a></p></li>
<li><p><a class="reference internal" href="#id15" id="id38">求解方程组</a></p></li>
<li><p><a class="reference internal" href="#la-eigen" id="id39">特征值和特征向量</a></p></li>
<li><p><a class="reference internal" href="#id23" id="id40">进阶主题</a></p></li>
<li><p><a class="reference internal" href="#id33" id="id41">练习</a></p></li>
</ul>
</li>
</ul>
</div>
<section id="id3">
<h2><a class="toc-backref" href="#id35"><span class="section-number">2.1. </span>概述</a><a class="headerlink" href="#id3" title="Permalink to this heading">#</a></h2>
<p>线性代数是经济学家最值得投入学习的应用数学分支之一。</p>
<p>例如，经济学和金融学中的许多应用问题都需要求解线性方程组，比如</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
    y_1 = a x_1 + b x_2 \\
    y_2 = c x_1 + d x_2
\end{aligned}
\end{split}\]</div>
<p>或者更一般地，</p>
<div class="math notranslate nohighlight" id="equation-la-se">
<span class="eqno">(2.1)<a class="headerlink" href="#equation-la-se" title="Permalink to this equation">#</a></span>\[ \begin{align}\begin{aligned}\begin{aligned}\\\begin{split}y_1 = a_{11} x_1 + a_{12} x_2 + \cdots + a_{1k} x_k \\
    \vdots  \\
    y_n = a_{n1} x_1 + a_{n2} x_2 + \cdots + a_{nk} x_k
\end{aligned}\end{split}\end{aligned}\end{align} \]</div>
<p>这里的目标是在已知 <span class="math notranslate nohighlight">\(a_{11}, \ldots, a_{nk}\)</span> 和 <span class="math notranslate nohighlight">\(y_1, \ldots, y_n\)</span> 的情况下，求解”未知数” <span class="math notranslate nohighlight">\(x_1, \ldots, x_k\)</span>。</p>
<p>在考虑这类问题时，我们首先必须考虑以下至少一些问题：</p>
<ul class="simple">
<li><p>解是否真的存在？</p></li>
<li><p>是否实际上存在多个解，如果是，我们应该如何解释它们？</p></li>
<li><p>如果不存在解，是否存在最佳的”近似”解？</p></li>
<li><p>如果解存在，我们应该如何计算它？</p></li>
</ul>
<p>这些都是线性代数所要解决的问题。</p>
<p>在本讲中，我们将介绍线性和矩阵代数的基础知识，包括理论和计算两个方面。</p>
<p>我们承认这与<a class="reference external" href="https://python-programming.quantecon.org/numpy.html">这篇讲座</a>有一些重叠，那里首次解释了NumPy数组的操作。</p>
<p>请注意，这节课比大多数课程更偏重理论，包含了我们在后续应用中将会用到的背景知识。</p>
<p>让我们先从一些导入语句开始：</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
<span class="n">FONTPATH</span> <span class="o">=</span> <span class="s2">&quot;fonts/SourceHanSerifSC-SemiBold.otf&quot;</span>
<span class="n">mpl</span><span class="o">.</span><span class="n">font_manager</span><span class="o">.</span><span class="n">fontManager</span><span class="o">.</span><span class="n">addfont</span><span class="p">(</span><span class="n">FONTPATH</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;font.family&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Source Han Serif SC&#39;</span><span class="p">]</span>

<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;figure.figsize&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1">#设置默认图形大小</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">inv</span><span class="p">,</span> <span class="n">solve</span><span class="p">,</span> <span class="n">det</span><span class="p">,</span> <span class="n">eig</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="id4">
<h2><a class="toc-backref" href="#id36"><span class="section-number">2.2. </span><span class="target" id="index-1"></span>向量</a><a class="headerlink" href="#id4" title="Permalink to this heading">#</a></h2>
<p id="index-2">长度为<span class="math notranslate nohighlight">\(n\)</span>的<em>向量</em>就是一个由<span class="math notranslate nohighlight">\(n\)</span>个数字组成的序列（或数组、元组），我们将其写作<span class="math notranslate nohighlight">\(x = (x_1, \ldots, x_n)\)</span>或<span class="math notranslate nohighlight">\(x = [x_1, \ldots, x_n]\)</span>。</p>
<p>我们可以根据需要将这些序列横向或纵向书写。</p>
<p>（稍后，当我们需要执行某些矩阵运算时，区分这两种写法将变得必要）</p>
<p>所有<span class="math notranslate nohighlight">\(n\)</span>维向量的集合用<span class="math notranslate nohighlight">\(\mathbb R^n\)</span>表示。</p>
<p>例如，<span class="math notranslate nohighlight">\(\mathbb R^2\)</span>是平面，而<span class="math notranslate nohighlight">\(\mathbb R^2\)</span>中的向量就是平面上的一个点。</p>
<p>传统上，向量在视觉上被表示为从原点指向某点的箭头。</p>
<p>下图以这种方式表示了三个向量</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="c1"># Set the axes through the origin</span>
<span class="k">for</span> <span class="n">spine</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;bottom&#39;</span><span class="p">]:</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="n">spine</span><span class="p">]</span><span class="o">.</span><span class="n">set_position</span><span class="p">(</span><span class="s1">&#39;zero&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">spine</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="s1">&#39;top&#39;</span><span class="p">]:</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="n">spine</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">ylim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
<span class="n">vecs</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mf">3.5</span><span class="p">))</span>
<span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vecs</span><span class="p">:</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                <span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span>
                <span class="n">shrink</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
                <span class="n">width</span><span class="o">=</span><span class="mf">0.5</span><span class="p">))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">1.1</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">1.1</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/a39b14f84ae6d44e1170b06e340da57cb75b068da249846ec2315d3a28261cb8.png" src="_images/a39b14f84ae6d44e1170b06e340da57cb75b068da249846ec2315d3a28261cb8.png" />
</div>
</div>
<section id="id5">
<h3><span class="section-number">2.2.1. </span>向量运算<a class="headerlink" href="#id5" title="Permalink to this heading">#</a></h3>
<p id="index-3">向量最常见的两种运算是加法和标量乘法，下面我们来介绍。</p>
<p>根据定义，当我们对两个向量进行加法运算时，我们是按元素逐个相加</p>
<div class="math notranslate nohighlight">
\[\begin{split}
x + y =
\begin{bmatrix}
    x_1 \\
    x_2 \\
    \vdots \\
    x_n
\end{bmatrix} +
\begin{bmatrix}
     y_1 \\
     y_2 \\
    \vdots \\
     y_n
\end{bmatrix} :=
\begin{bmatrix}
    x_1 + y_1 \\
    x_2 + y_2 \\
    \vdots \\
    x_n + y_n
\end{bmatrix}
\end{split}\]</div>
<p>标量乘法是一种将数字 <span class="math notranslate nohighlight">\(\gamma\)</span> 与向量 <span class="math notranslate nohighlight">\(x\)</span> 相乘的运算，得到</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\gamma x :=
\begin{bmatrix}
    \gamma x_1 \\
    \gamma x_2 \\
    \vdots \\
    \gamma x_n
\end{bmatrix}
\end{split}\]</div>
<p>下图展示了标量乘法</p>
<div class="cell tag_output_scroll docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="c1"># Set the axes through the origin</span>
<span class="k">for</span> <span class="n">spine</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;bottom&#39;</span><span class="p">]:</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="n">spine</span><span class="p">]</span><span class="o">.</span><span class="n">set_position</span><span class="p">(</span><span class="s1">&#39;zero&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">spine</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="s1">&#39;top&#39;</span><span class="p">]:</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="n">spine</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">ylim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span>
            <span class="n">shrink</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">width</span><span class="o">=</span><span class="mf">0.5</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.2</span><span class="p">,</span> <span class="s1">&#39;$x$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="s1">&#39;16&#39;</span><span class="p">)</span>


<span class="n">scalars</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">scalars</span><span class="p">:</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">x</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                <span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span>
                <span class="n">shrink</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                <span class="n">width</span><span class="o">=</span><span class="mf">0.5</span><span class="p">))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.4</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.2</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;$</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s1"> x$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="s1">&#39;16&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/e3a655666ae0445ef3d0cb087797de8e7a4393d6f4716ab21e59207eda5b97ca.png" src="_images/e3a655666ae0445ef3d0cb087797de8e7a4393d6f4716ab21e59207eda5b97ca.png" />
</div>
</div>
<p>在Python中，向量可以用列表或元组来表示，例如 <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">(2,</span> <span class="pre">4,</span> <span class="pre">6)</span></code>，但更常见的是用<a class="reference external" href="https://python-programming.quantecon.org/numpy.html#numpy-arrays">NumPy数组</a>来表示。</p>
<p>NumPy数组的一个优点是标量乘法和加法具有非常自然的语法</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>            <span class="c1"># 创建一个包含三个1的向量</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>   <span class="c1"># 将元组(2, 4, 6)转换为数组</span>
<span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([3., 5., 7.])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mi">4</span> <span class="o">*</span> <span class="n">x</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([4., 4., 4.])
</pre></div>
</div>
</div>
</div>
</section>
<section id="id6">
<h3><span class="section-number">2.2.2. </span>内积和范数<a class="headerlink" href="#id6" title="Permalink to this heading">#</a></h3>
<span class="target" id="index-4"></span><p id="index-5">向量 <span class="math notranslate nohighlight">\(x,y \in \mathbb R ^n\)</span> 的<em>内积</em>定义为</p>
<div class="math notranslate nohighlight">
\[
x' y := \sum_{i=1}^n x_i y_i
\]</div>
<p>如果两个向量的内积为零，则称这两个向量<em>正交</em>。</p>
<p>向量 <span class="math notranslate nohighlight">\(x\)</span> 的<em>范数</em>表示其”长度”（即其与零向量的距离），定义为</p>
<div class="math notranslate nohighlight">
\[
\| x \| := \sqrt{x' x} := \left( \sum_{i=1}^n x_i^2 \right)^{1/2}
\]</div>
<p>表达式 <span class="math notranslate nohighlight">\(\| x - y\|\)</span> 被理解为 <span class="math notranslate nohighlight">\(x\)</span> 和 <span class="math notranslate nohighlight">\(y\)</span> 之间的距离。</p>
<p>继续前面的例子，内积和范数可以按如下方式计算</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>          <span class="c1"># x和y的内积</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>12.0
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>  <span class="c1"># x的范数，第一种方法</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.7320508075688772
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>      <span class="c1"># x的范数，第二次计算</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1.7320508075688772
</pre></div>
</div>
</div>
</div>
</section>
<section id="id7">
<h3><span class="section-number">2.2.3. </span>张成空间<a class="headerlink" href="#id7" title="Permalink to this heading">#</a></h3>
<p id="index-6">给定<span class="math notranslate nohighlight">\(\mathbb R ^n\)</span>中的一组向量<span class="math notranslate nohighlight">\(A := \{a_1, \ldots, a_k\}\)</span>，我们自然会思考通过执行线性运算可以创建哪些新向量。</p>
<p>以这种方式创建的新向量被称为<span class="math notranslate nohighlight">\(A\)</span>的<em>线性组合</em>。</p>
<p>具体来说，如果<span class="math notranslate nohighlight">\(y \in \mathbb R ^n\)</span>是<span class="math notranslate nohighlight">\(A := \{a_1, \ldots, a_k\}\)</span>的线性组合，那么</p>
<div class="math notranslate nohighlight">
\[
y = \beta_1 a_1 + \cdots + \beta_k a_k
\text{ 其中 } \beta_1, \ldots, \beta_k \text{ 为某些标量}
\]</div>
<p>在这种情况下，值<span class="math notranslate nohighlight">\(\beta_1, \ldots, \beta_k\)</span>被称为线性组合的<em>系数</em>。</p>
<p><span class="math notranslate nohighlight">\(A\)</span>的所有线性组合构成的集合被称为<span class="math notranslate nohighlight">\(A\)</span>的<em>张成空间</em>。</p>
<p>下图显示了<span class="math notranslate nohighlight">\(\mathbb R ^3\)</span>中<span class="math notranslate nohighlight">\(A = \{a_1, a_2\}\)</span>的张成空间。</p>
<p>张成空间是一个通过这两个点和原点的二维平面。</p>
<div class="cell tag_output_scroll docutils container" id="la-3dvec">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>

<span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span>
<span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span>

<span class="n">α</span><span class="p">,</span> <span class="n">β</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span>

<span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlim</span><span class="o">=</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">),</span> <span class="n">ylim</span><span class="o">=</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">),</span> <span class="n">zlim</span><span class="o">=</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">),</span>
       <span class="n">xticks</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="n">yticks</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="n">zticks</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span>

<span class="n">gs</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">gs</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">gs</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">gs</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>


<span class="c1"># Fixed linear function, to generate a plane</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">α</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">β</span> <span class="o">*</span> <span class="n">y</span>

<span class="c1"># Vector locations, by coordinate</span>
<span class="n">x_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">y_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">))</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x_coords</span><span class="p">,</span> <span class="n">y_coords</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x_coords</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y_coords</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="sa">f</span><span class="s1">&#39;$a_</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1">$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>

<span class="c1"># Lines to vectors</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x_coords</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y_coords</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">x_coords</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y_coords</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="s1">&#39;b-&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">)</span>


<span class="c1"># Draw the plane</span>
<span class="n">grid_size</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">xr2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">)</span>
<span class="n">yr2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">,</span> <span class="n">grid_size</span><span class="p">)</span>
<span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xr2</span><span class="p">,</span> <span class="n">yr2</span><span class="p">)</span>
<span class="n">z2</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">z2</span><span class="p">,</span> <span class="n">rstride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cstride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">jet</span><span class="p">,</span>
                <span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">antialiased</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/260ff037431751cfd81fb2a74b5176aa9d7e24bf22e594f4ccade4aaacd7be6e.png" src="_images/260ff037431751cfd81fb2a74b5176aa9d7e24bf22e594f4ccade4aaacd7be6e.png" />
</div>
</div>
<section id="id8">
<h4><span class="section-number">2.2.3.1. </span>示例<a class="headerlink" href="#id8" title="Permalink to this heading">#</a></h4>
<p>如果 <span class="math notranslate nohighlight">\(A\)</span> 只包含一个向量 <span class="math notranslate nohighlight">\(a_1 \in \mathbb R ^2\)</span>，那么它的张成只是 <span class="math notranslate nohighlight">\(a_1\)</span> 的标量倍数，即通过 <span class="math notranslate nohighlight">\(a_1\)</span> 和原点的唯一直线。</p>
<p>如果 <span class="math notranslate nohighlight">\(A = \{e_1, e_2, e_3\}\)</span> 由 <span class="math notranslate nohighlight">\(\mathbb R ^3\)</span> 的<em>标准基向量</em>组成，即</p>
<div class="math notranslate nohighlight">
\[\begin{split}
e_1 :=
\begin{bmatrix}
     1 \\
     0 \\
     0
\end{bmatrix}
, \quad
e_2 :=
\begin{bmatrix}
     0 \\
     1 \\
     0
\end{bmatrix}
, \quad
e_3 :=
\begin{bmatrix}
     0 \\
     0 \\
     1
\end{bmatrix}
\end{split}\]</div>
<p>那么 <span class="math notranslate nohighlight">\(A\)</span> 的张成就是整个 <span class="math notranslate nohighlight">\(\mathbb R ^3\)</span>，因为对于任意的 <span class="math notranslate nohighlight">\(x = (x_1, x_2, x_3) \in \mathbb R ^3\)</span>，我们可以写成</p>
<div class="math notranslate nohighlight">
\[
x = x_1 e_1 + x_2 e_2 + x_3 e_3
\]</div>
<p>现在考虑 <span class="math notranslate nohighlight">\(A_0 = \{e_1, e_2, e_1 + e_2\}\)</span>。</p>
<p>如果 <span class="math notranslate nohighlight">\(y = (y_1, y_2, y_3)\)</span> 是这些向量的任意线性组合，那么 <span class="math notranslate nohighlight">\(y_3 = 0\)</span>（请验证）。</p>
<p>因此 <span class="math notranslate nohighlight">\(A_0\)</span> 不能张成整个 <span class="math notranslate nohighlight">\(\mathbb R ^3\)</span>。</p>
</section>
</section>
<section id="la-li">
<span id="id9"></span><h3><span class="section-number">2.2.4. </span>线性无关<a class="headerlink" href="#la-li" title="Permalink to this heading">#</a></h3>
<p id="index-7">正如我们将看到的，找到具有相对较大张成空间的向量族通常是很有必要的，这样许多向量就可以通过对少数向量进行线性运算来描述。</p>
<p>对于一组向量要具有较大的张成空间，我们需要的条件就是所谓的线性无关。</p>
<p>具体来说，在<span class="math notranslate nohighlight">\(\mathbb R ^n\)</span>中的一组向量<span class="math notranslate nohighlight">\(A := \{a_1, \ldots, a_k\}\)</span>被称为</p>
<ul class="simple">
<li><p><em>线性相关的</em>，如果<span class="math notranslate nohighlight">\(A\)</span>的某个真子集与<span class="math notranslate nohighlight">\(A\)</span>具有相同的张成空间。</p></li>
<li><p><em>线性无关的</em>，如果它不是线性相关的。</p></li>
</ul>
<p>换句话说，如果没有向量对张成空间是多余的，那么这组向量就是线性无关的，否则就是线性相关的。</p>
<p>为了说明这个概念，回想<a class="reference internal" href="#la-3dvec"><span class="std std-ref">图示</span></a>展示了<span class="math notranslate nohighlight">\(\mathbb R ^3\)</span>中向量<span class="math notranslate nohighlight">\(\{a_1, a_2\}\)</span>的张成空间是一个经过原点的平面。</p>
<p>如果我们再取第三个向量<span class="math notranslate nohighlight">\(a_3\)</span>并形成集合<span class="math notranslate nohighlight">\(\{a_1, a_2, a_3\}\)</span>，这个集合将会是</p>
<ul class="simple">
<li><p>如果<span class="math notranslate nohighlight">\(a_3\)</span>位于该平面内，则线性相关</p></li>
<li><p>否则线性无关</p></li>
</ul>
<p>作为这个概念的另一个说明，由于<span class="math notranslate nohighlight">\(\mathbb R ^n\)</span>可以由<span class="math notranslate nohighlight">\(n\)</span>个向量张成（参见上文关于标准基向量的讨论），在<span class="math notranslate nohighlight">\(\mathbb R ^n\)</span>中任何包含<span class="math notranslate nohighlight">\(m &gt; n\)</span>个向量的集合必定线性相关。</p>
<p>以下陈述等价于<span class="math notranslate nohighlight">\(A := \{a_1, \ldots, a_k\} \subset \mathbb R ^n\)</span>的线性独立性：</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(A\)</span>中的任何向量都不能由其他元素的线性组合表示。</p></li>
<li><p>如果对于标量<span class="math notranslate nohighlight">\(\beta_1, \ldots, \beta_k\)</span>，有<span class="math notranslate nohighlight">\(\beta_1 a_1 + \cdots \beta_k a_k = 0\)</span>，那么<span class="math notranslate nohighlight">\(\beta_1 = \cdots = \beta_k = 0\)</span>。</p></li>
</ol>
<p>（第一个表达式中的零是<span class="math notranslate nohighlight">\(\mathbb R ^n\)</span>的原点）</p>
</section>
<section id="la-unique-reps">
<span id="id10"></span><h3><span class="section-number">2.2.5. </span>唯一表示<a class="headerlink" href="#la-unique-reps" title="Permalink to this heading">#</a></h3>
<p>关于线性独立向量集合的另一个优点是，其张成空间中的每个元素都可以唯一地表示为这些向量的线性组合。</p>
<p>换句话说，如果<span class="math notranslate nohighlight">\(A := \{a_1, \ldots, a_k\} \subset \mathbb R ^n\)</span>是线性独立的，且</p>
<div class="math notranslate nohighlight">
\[
y = \beta_1 a_1 + \cdots \beta_k a_k
\]</div>
<p>那么其他任何系数序列 <span class="math notranslate nohighlight">\(\gamma_1, \ldots, \gamma_k\)</span> 都不会产生相同的向量 <span class="math notranslate nohighlight">\(y\)</span>。</p>
<p>事实上，如果我们也有 <span class="math notranslate nohighlight">\(y = \gamma_1 a_1 + \cdots \gamma_k a_k\)</span>，
那么</p>
<div class="math notranslate nohighlight">
\[
(\beta_1 - \gamma_1) a_1 + \cdots + (\beta_k - \gamma_k) a_k = 0
\]</div>
<p>线性独立性现在意味着对所有 <span class="math notranslate nohighlight">\(i\)</span> 都有 <span class="math notranslate nohighlight">\(\gamma_i = \beta_i\)</span>。</p>
</section>
</section>
<section id="id11">
<h2><a class="toc-backref" href="#id37"><span class="section-number">2.3. </span>矩阵</a><a class="headerlink" href="#id11" title="Permalink to this heading">#</a></h2>
<p id="index-8">矩阵是组织数据用于线性运算的一种简洁方式。</p>
<p>一个 <span class="math notranslate nohighlight">\(n \times k\)</span> 矩阵是一个具有 <span class="math notranslate nohighlight">\(n\)</span> 行和 <span class="math notranslate nohighlight">\(k\)</span> 列的矩形数字数组 <span class="math notranslate nohighlight">\(A\)</span>：</p>
<div class="math notranslate nohighlight">
\[\begin{split}
A =
\begin{bmatrix}
    a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1k} \\
    a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2k} \\
    \vdots &amp; \vdots &amp;  &amp; \vdots \\
    a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nk}
\end{bmatrix}
\end{split}\]</div>
<p>通常，矩阵中的数字表示线性方程组中的系数，正如本讲开始时所讨论的。</p>
<p>显然，当 <span class="math notranslate nohighlight">\(n = 1\)</span> 或 <span class="math notranslate nohighlight">\(k = 1\)</span> 时，矩阵 <span class="math notranslate nohighlight">\(A\)</span> 也被称为向量。</p>
<p>在前一种情况下，<span class="math notranslate nohighlight">\(A\)</span> 被称为<em>行向量</em>，而在后一种情况下被称为<em>列向量</em>。</p>
<p>如果 <span class="math notranslate nohighlight">\(n = k\)</span>，则 <span class="math notranslate nohighlight">\(A\)</span> 被称为<em>方阵</em>。</p>
<p>将每个 <span class="math notranslate nohighlight">\(a_{ij}\)</span> 替换为 <span class="math notranslate nohighlight">\(a_{ji}\)</span> 所形成的矩阵被称为 <span class="math notranslate nohighlight">\(A\)</span> 的<em>转置</em>，记作 <span class="math notranslate nohighlight">\(A'\)</span> 或 <span class="math notranslate nohighlight">\(A^{\top}\)</span>。</p>
<p>如果 <span class="math notranslate nohighlight">\(A = A'\)</span>，则 <span class="math notranslate nohighlight">\(A\)</span> 被称为<em>对称矩阵</em>。</p>
<p>对于方阵 <span class="math notranslate nohighlight">\(A\)</span>，形如 <span class="math notranslate nohighlight">\(a_{ii}\)</span> 的 <span class="math notranslate nohighlight">\(i\)</span> 个元素（其中 <span class="math notranslate nohighlight">\(i=1,\ldots,n\)</span>）被称为<em>主对角线</em>。</p>
<p>如果只有主对角线上的元素非零，则 <span class="math notranslate nohighlight">\(A\)</span> 被称为<em>对角矩阵</em>。</p>
<p>如果除了是对角矩阵外，主对角线上的每个元素都等于1，则 <span class="math notranslate nohighlight">\(A\)</span> 被称为<em>单位矩阵</em>，记作 <span class="math notranslate nohighlight">\(I\)</span>。</p>
<section id="id12">
<h3><span class="section-number">2.3.1. </span>矩阵运算<a class="headerlink" href="#id12" title="Permalink to this heading">#</a></h3>
<p id="index-9">与向量一样，矩阵也定义了许多代数运算。</p>
<p>标量乘法和加法是向量情况的直接推广：</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}
\gamma A =
\gamma
\begin{bmatrix}\\\begin{split}a_{11} &amp;  \cdots &amp; a_{1k} \\
    \vdots &amp; \vdots  &amp; \vdots \\
    a_{n1} &amp;  \cdots &amp; a_{nk}
\end{bmatrix} :=
\begin{bmatrix}
    \gamma a_{11} &amp; \cdots &amp; \gamma a_{1k} \\
    \vdots &amp; \vdots &amp; \vdots \\
    \gamma a_{n1} &amp; \cdots &amp; \gamma a_{nk}
\end{bmatrix}
\end{split}\end{aligned}\end{align} \]</div>
<p>以及</p>
<div class="math notranslate nohighlight">
\[\begin{split}
A + B =
\begin{bmatrix}
    a_{11} &amp; \cdots &amp; a_{1k} \\
    \vdots &amp; \vdots &amp; \vdots \\
    a_{n1} &amp; \cdots &amp; a_{nk}
\end{bmatrix} +
\begin{bmatrix}
    b_{11} &amp; \cdots &amp; b_{1k} \\
    \vdots &amp; \vdots &amp; \vdots \\
    b_{n1} &amp; \cdots &amp; b_{nk}
\end{bmatrix} :=
\begin{bmatrix}
    a_{11} + b_{11} &amp;  \cdots &amp; a_{1k} + b_{1k} \\
    \vdots &amp; \vdots &amp; \vdots \\
    a_{n1} + b_{n1} &amp;  \cdots &amp; a_{nk} + b_{nk}
\end{bmatrix}
\end{split}\]</div>
<p>在后一种情况下，矩阵必须具有相同的形状才能使定义有意义。</p>
<p>我们还有一个<em>相乘</em>两个矩阵的约定。</p>
<p>矩阵乘法的规则推广了上面讨论的内积的概念。</p>
<p>并且其设计使得乘法能够很好地配合基本线性运算。</p>
<p>如果<span class="math notranslate nohighlight">\(A\)</span>和<span class="math notranslate nohighlight">\(B\)</span>是两个矩阵，那么它们的乘积<span class="math notranslate nohighlight">\(A B\)</span>的第<span class="math notranslate nohighlight">\(i,j\)</span>个元素是由<span class="math notranslate nohighlight">\(A\)</span>的第<span class="math notranslate nohighlight">\(i\)</span>行与<span class="math notranslate nohighlight">\(B\)</span>的第<span class="math notranslate nohighlight">\(j\)</span>列的内积得到的。</p>
<p>有许多教程可以帮助你理解这个运算，比如<a class="reference external" href="https://www.mathsisfun.com/algebra/matrix-multiplying.html">这个</a>，或者<a class="reference external" href="https://en.wikipedia.org/wiki/Matrix_multiplication">维基百科页面</a>上的讨论。</p>
<p>如果<span class="math notranslate nohighlight">\(A\)</span>是<span class="math notranslate nohighlight">\(n \times k\)</span>矩阵，<span class="math notranslate nohighlight">\(B\)</span>是<span class="math notranslate nohighlight">\(j \times m\)</span>矩阵，那么要使<span class="math notranslate nohighlight">\(A\)</span>和<span class="math notranslate nohighlight">\(B\)</span>可以相乘，我们需要<span class="math notranslate nohighlight">\(k = j\)</span>，且得到的矩阵<span class="math notranslate nohighlight">\(A B\)</span>是<span class="math notranslate nohighlight">\(n \times m\)</span>的。</p>
<p>作为可能最重要的特例，考虑将<span class="math notranslate nohighlight">\(n \times k\)</span>矩阵<span class="math notranslate nohighlight">\(A\)</span>与<span class="math notranslate nohighlight">\(k \times 1\)</span>列向量<span class="math notranslate nohighlight">\(x\)</span>相乘。</p>
<p>根据前面的规则，这会得到一个<span class="math notranslate nohighlight">\(n \times 1\)</span>列向量</p>
<div class="math notranslate nohighlight" id="equation-la-atx">
<span class="eqno">(2.2)<a class="headerlink" href="#equation-la-atx" title="Permalink to this equation">#</a></span>\[ \begin{align}\begin{aligned}\begin{split}A x =
\begin{bmatrix}
    a_{11} &amp;  \cdots &amp; a_{1k} \\
    \vdots &amp; \vdots  &amp; \vdots \\
    a_{n1} &amp;  \cdots &amp; a_{nk}\end{split}\\\begin{split}\end{bmatrix}
\begin{bmatrix}
    x_{1}  \\
    \vdots  \\
    x_{k}
\end{bmatrix} :=
\begin{bmatrix}
    a_{11} x_1 + \cdots + a_{1k} x_k \\
    \vdots \\
    a_{n1} x_1 + \cdots + a_{nk} x_k
\end{bmatrix}\end{split}\end{aligned}\end{align} \]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><span class="math notranslate nohighlight">\(A B\)</span> 和 <span class="math notranslate nohighlight">\(B A\)</span> 通常不是同一个东西。</p>
</div>
<p>另一个重要的特殊情况是单位矩阵。</p>
<p>你应该验证如果 <span class="math notranslate nohighlight">\(A\)</span> 是 <span class="math notranslate nohighlight">\(n \times k\)</span> 矩阵且 <span class="math notranslate nohighlight">\(I\)</span> 是 <span class="math notranslate nohighlight">\(k \times k\)</span> 单位矩阵，那么 <span class="math notranslate nohighlight">\(AI = A\)</span>。</p>
<p>如果 <span class="math notranslate nohighlight">\(I\)</span> 是 <span class="math notranslate nohighlight">\(n \times n\)</span> 单位矩阵，那么 <span class="math notranslate nohighlight">\(IA = A\)</span>。</p>
</section>
<section id="numpy">
<h3><span class="section-number">2.3.2. </span>NumPy中的矩阵<a class="headerlink" href="#numpy" title="Permalink to this heading">#</a></h3>
<p id="index-10">NumPy数组也被用作矩阵，并且对所有标准矩阵运算都有快速、高效的函数和方法<a class="footnote-reference brackets" href="#fn-mdt" id="id13">1</a>。</p>
<p>你可以通过元组的元组（或列表的列表）手动创建它们，如下所示</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
     <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

<span class="nb">type</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>tuple
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>

<span class="nb">type</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>numpy.ndarray
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(2, 2)
</pre></div>
</div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">shape</span></code> 属性是一个表示行数和列数的元组 — 更多讨论请参见<a class="reference external" href="https://python-programming.quantecon.org/numpy.html#shape-and-dimension">这里</a>。</p>
<p>要获取 <code class="docutils literal notranslate"><span class="pre">A</span></code> 的转置，可以使用 <code class="docutils literal notranslate"><span class="pre">A.transpose()</span></code> 或更简单的 <code class="docutils literal notranslate"><span class="pre">A.T</span></code>。</p>
<p>有许多便捷的函数可用于创建常见矩阵（零矩阵、全1矩阵等）— 参见<a class="reference external" href="https://python-programming.quantecon.org/numpy.html#creating-arrays">这里</a>。</p>
<p>由于运算默认按元素执行，标量乘法和加法具有非常自然的语法</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="mi">2</span> <span class="o">*</span> <span class="n">A</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[2., 0., 0.],
       [0., 2., 0.],
       [0., 0., 2.]])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">+</span> <span class="n">B</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[2., 1., 1.],
       [1., 2., 1.],
       [1., 1., 2.]])
</pre></div>
</div>
</div>
</div>
<p>矩阵相乘我们使用<code class="docutils literal notranslate"><span class="pre">&#64;</span></code>符号。</p>
<p>具体来说，<code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&#64;</span> <span class="pre">B</span></code>表示矩阵乘法，而<code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">*</span> <span class="pre">B</span></code>表示元素逐个相乘。</p>
<p>更多讨论请参见<a class="reference external" href="https://python-programming.quantecon.org/numpy.html#matrix-multiplication">这里</a>。</p>
</section>
<section id="la-linear-map">
<span id="id14"></span><h3><span class="section-number">2.3.3. </span>矩阵作为映射<a class="headerlink" href="#la-linear-map" title="Permalink to this heading">#</a></h3>
<p id="index-11">每个<span class="math notranslate nohighlight">\(n \times k\)</span>矩阵<span class="math notranslate nohighlight">\(A\)</span>都可以被视为一个函数<span class="math notranslate nohighlight">\(f(x) = Ax\)</span>，该函数将<span class="math notranslate nohighlight">\(x \in \mathbb R ^k\)</span>映射到<span class="math notranslate nohighlight">\(y = Ax \in \mathbb R ^n\)</span>。</p>
<p>这类函数具有一个特殊性质：它们是<em>线性的</em>。</p>
<p>如果对于所有的<span class="math notranslate nohighlight">\(x, y \in \mathbb R ^k\)</span>和所有标量<span class="math notranslate nohighlight">\(\alpha, \beta\)</span>，一个函数<span class="math notranslate nohighlight">\(f \colon \mathbb R ^k \to \mathbb R ^n\)</span>满足：</p>
<div class="math notranslate nohighlight">
\[
f(\alpha x + \beta y) = \alpha f(x) + \beta f(y)
\]</div>
<p>则称该函数为<em>线性</em>函数。</p>
<p>你可以验证，当<span class="math notranslate nohighlight">\(b\)</span>为零向量时，函数<span class="math notranslate nohighlight">\(f(x) = A x + b\)</span>满足这个性质，而当<span class="math notranslate nohighlight">\(b\)</span>非零时则不满足。</p>
<p>事实上，已<a class="reference external" href="https://en.wikipedia.org/wiki/Linear_map#Matrices">知</a><span class="math notranslate nohighlight">\(f\)</span>是线性的，当且<em>仅当</em>存在矩阵<span class="math notranslate nohighlight">\(A\)</span>使得对所有的<span class="math notranslate nohighlight">\(x\)</span>都有<span class="math notranslate nohighlight">\(f(x) = Ax\)</span>。</p>
</section>
</section>
<section id="id15">
<h2><a class="toc-backref" href="#id38"><span class="section-number">2.4. </span>求解方程组</a><a class="headerlink" href="#id15" title="Permalink to this heading">#</a></h2>
<p id="index-12">再次回顾方程组<a class="reference internal" href="#equation-la-se">(2.1)</a>。</p>
<p>如果我们比较<a class="reference internal" href="#equation-la-se">(2.1)</a>和<a class="reference internal" href="#equation-la-atx">(2.2)</a>，我们可以看到<a class="reference internal" href="#equation-la-se">(2.1)</a>现在可以更方便地写成</p>
<div class="math notranslate nohighlight" id="equation-la-se2">
<span class="eqno">(2.3)<a class="headerlink" href="#equation-la-se2" title="Permalink to this equation">#</a></span>\[y = Ax\]</div>
<p>我们面临的问题是确定一个向量<span class="math notranslate nohighlight">\(x \in \mathbb R ^k\)</span>来解<a class="reference internal" href="#equation-la-se2">(2.3)</a>，其中<span class="math notranslate nohighlight">\(y\)</span>和<span class="math notranslate nohighlight">\(A\)</span>是已知的。</p>
<p>这是一个更一般问题的特例：找到一个<span class="math notranslate nohighlight">\(x\)</span>使得<span class="math notranslate nohighlight">\(y = f(x)\)</span>。</p>
<p>给定任意函数<span class="math notranslate nohighlight">\(f\)</span>和一个<span class="math notranslate nohighlight">\(y\)</span>，是否总是存在一个<span class="math notranslate nohighlight">\(x\)</span>使得<span class="math notranslate nohighlight">\(y = f(x)\)</span>？</p>
<p>如果存在，它是否总是唯一的？</p>
<p>这两个问题的答案都是否定的，如下图所示</p>
<div class="cell tag_output_scroll docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">0.6</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.4</span>


<span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="mi">160</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">ya</span><span class="p">,</span> <span class="n">yb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

<span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
    <span class="c1"># Set the axes through the origin</span>
    <span class="k">for</span> <span class="n">spine</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;bottom&#39;</span><span class="p">]:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="n">spine</span><span class="p">]</span><span class="o">.</span><span class="n">set_position</span><span class="p">(</span><span class="s1">&#39;zero&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">spine</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="s1">&#39;top&#39;</span><span class="p">]:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="n">spine</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>

    <span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ylim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">3.2</span><span class="p">),</span> <span class="n">xlim</span><span class="o">=</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">),</span>
           <span class="n">yticks</span><span class="o">=</span><span class="p">(),</span> <span class="n">xticks</span><span class="o">=</span><span class="p">())</span>

    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$f$&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ya</span><span class="p">,</span> <span class="n">yb</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">vlines</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">ya</span><span class="p">,</span> <span class="n">yb</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;range of $f$&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.04</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.3</span><span class="p">,</span> <span class="s1">&#39;$0$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper right&#39;</span><span class="p">,</span> <span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">ybar</span> <span class="o">=</span> <span class="mf">1.5</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">ybar</span><span class="p">,</span> <span class="s1">&#39;k--&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.8</span> <span class="o">*</span> <span class="n">ybar</span><span class="p">,</span> <span class="s1">&#39;$y$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">((</span><span class="o">-</span><span class="mf">0.35</span><span class="p">,</span> <span class="mf">0.35</span><span class="p">)):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;$x_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="n">ybar</span> <span class="o">=</span> <span class="mf">2.6</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">0</span> <span class="o">+</span> <span class="n">ybar</span><span class="p">,</span> <span class="s1">&#39;k--&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">0.04</span><span class="p">,</span> <span class="mf">0.91</span> <span class="o">*</span> <span class="n">ybar</span><span class="p">,</span> <span class="s1">&#39;$y$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/daa1be2204698227107bcaf2f37e58dedbcc686a5beba81ed49e2d76ec847fe7.png" src="_images/daa1be2204698227107bcaf2f37e58dedbcc686a5beba81ed49e2d76ec847fe7.png" />
</div>
</div>
<p>在第一个图中，由于函数不是一一对应的，存在多个解，而
在第二个图中，由于<span class="math notranslate nohighlight">\(y\)</span>在函数<span class="math notranslate nohighlight">\(f\)</span>的值域之外，所以没有解。</p>
<p>我们能否对<a class="reference internal" href="#equation-la-se2">(2.3)</a>中的<span class="math notranslate nohighlight">\(A\)</span>施加条件来避免这些问题？</p>
<p>在这种情况下，最重要的是要认识到表达式<span class="math notranslate nohighlight">\(Ax\)</span>对应于<span class="math notranslate nohighlight">\(A\)</span>的列的线性组合。</p>
<p>具体来说，如果<span class="math notranslate nohighlight">\(a_1, \ldots, a_k\)</span>是<span class="math notranslate nohighlight">\(A\)</span>的列，那么</p>
<div class="math notranslate nohighlight">
\[
Ax = x_1 a_1 + \cdots + x_k a_k
\]</div>
<p>因此，<span class="math notranslate nohighlight">\(f(x) = Ax\)</span>的值域恰好是<span class="math notranslate nohighlight">\(A\)</span>的列的张成空间。</p>
<p>我们希望值域足够大，以包含任意的<span class="math notranslate nohighlight">\(y\)</span>。</p>
<p>你可能记得，我们希望张成空间足够大的条件是<a class="reference internal" href="#la-li"><span class="std std-ref">线性独立</span></a>。</p>
<p>一个令人高兴的事实是，<span class="math notranslate nohighlight">\(A\)</span>的列的线性独立性也能给我们唯一性。</p>
<p>确实，根据我们<a class="reference internal" href="#la-unique-reps"><span class="std std-ref">之前的讨论</span></a>，如果<span class="math notranslate nohighlight">\(\{a_1, \ldots, a_k\}\)</span>是线性无关的，且<span class="math notranslate nohighlight">\(y = Ax = x_1 a_1 + \cdots + x_k a_k\)</span>，那么不存在<span class="math notranslate nohighlight">\(z \not= x\)</span>满足<span class="math notranslate nohighlight">\(y = Az\)</span>。</p>
<section id="id16">
<h3><span class="section-number">2.4.1. </span>方阵的情况<a class="headerlink" href="#id16" title="Permalink to this heading">#</a></h3>
<p>让我们讨论更多细节，首先从<span class="math notranslate nohighlight">\(A\)</span>是<span class="math notranslate nohighlight">\(n \times n\)</span>矩阵的情况开始。</p>
<p>这是我们熟悉的方程个数等于未知数个数的情况。</p>
<p>对于任意的<span class="math notranslate nohighlight">\(y \in \mathbb R ^n\)</span>，我们希望找到唯一的<span class="math notranslate nohighlight">\(x \in \mathbb R ^n\)</span>使得<span class="math notranslate nohighlight">\(y = Ax\)</span>。</p>
<p>根据上面的观察，如果<span class="math notranslate nohighlight">\(A\)</span>的列向量是线性无关的，那么它们的张成空间，也就是函数<span class="math notranslate nohighlight">\(f(x) = Ax\)</span>的值域，就是整个<span class="math notranslate nohighlight">\(\mathbb R ^n\)</span>。</p>
<p>因此总是存在<span class="math notranslate nohighlight">\(x\)</span>使得<span class="math notranslate nohighlight">\(y = Ax\)</span>。</p>
<p>而且，这个解是唯一的。</p>
<p>特别地，以下陈述是等价的：</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(A\)</span>的列向量是线性无关的。</p></li>
<li><p>对于任意<span class="math notranslate nohighlight">\(y \in \mathbb R ^n\)</span>，方程<span class="math notranslate nohighlight">\(y = Ax\)</span>有唯一解。</p></li>
</ol>
<p>列向量线性独立的性质有时被表述为具有<em>满秩列</em>。</p>
<section id="id17">
<h4><span class="section-number">2.4.1.1. </span>逆矩阵<a class="headerlink" href="#id17" title="Permalink to this heading">#</a></h4>
<p id="index-13">我们能给出某种形式的解吗？</p>
<p>如果<span class="math notranslate nohighlight">\(y\)</span>和<span class="math notranslate nohighlight">\(A\)</span>是标量且<span class="math notranslate nohighlight">\(A \not= 0\)</span>，那么解为<span class="math notranslate nohighlight">\(x = A^{-1} y\)</span>。</p>
<p>在矩阵的情况下也有类似的表达式。</p>
<p>特别地，如果方阵<span class="math notranslate nohighlight">\(A\)</span>具有满秩列，那么它就有一个乘法<em>逆矩阵</em><span class="math notranslate nohighlight">\(A^{-1}\)</span>，具有性质<span class="math notranslate nohighlight">\(A A^{-1} = A^{-1} A = I\)</span>。</p>
<p>因此，如果我们用<span class="math notranslate nohighlight">\(A^{-1}\)</span>左乘等式<span class="math notranslate nohighlight">\(y = Ax\)</span>的两边，就得到<span class="math notranslate nohighlight">\(x = A^{-1} y\)</span>。</p>
<p>这就是我们要找的解。</p>
</section>
<section id="id18">
<h4><span class="section-number">2.4.1.2. </span>行列式<a class="headerlink" href="#id18" title="Permalink to this heading">#</a></h4>
<p id="index-14">关于方阵的另一个简短说明是，每个这样的矩阵都有一个唯一的数，称为矩阵的<em>行列式</em>——你可以在<a class="reference external" href="https://en.wikipedia.org/wiki/Determinant">这里</a>找到它的表达式。</p>
<p>如果矩阵<span class="math notranslate nohighlight">\(A\)</span>的行列式不为零，我们就说<span class="math notranslate nohighlight">\(A\)</span>是<em>非奇异的</em>。</p>
<p>关于行列式最重要的事实可能是：<span class="math notranslate nohighlight">\(A\)</span>是非奇异的，当且仅当<span class="math notranslate nohighlight">\(A\)</span>具有满列秩。</p>
<p>这为我们提供了一个有用的单一数值，用来概括一个方阵是否可逆。</p>
</section>
</section>
<section id="id19">
<h3><span class="section-number">2.4.2. </span>行数多于列数<a class="headerlink" href="#id19" title="Permalink to this heading">#</a></h3>
<p>这是<span class="math notranslate nohighlight">\(n \times k\)</span>的情况，其中<span class="math notranslate nohighlight">\(n &gt; k\)</span>。</p>
<p>这种情况在许多场合都非常重要，尤其是在线性回归中（其中<span class="math notranslate nohighlight">\(n\)</span>是观测数量，<span class="math notranslate nohighlight">\(k\)</span>是解释变量的数量）。</p>
<p>对于任意的<span class="math notranslate nohighlight">\(y \in \mathbb R ^n\)</span>，我们寻找一个<span class="math notranslate nohighlight">\(x \in \mathbb R ^k\)</span>使得<span class="math notranslate nohighlight">\(y = Ax\)</span>。</p>
<p>在这种情况下，解的存在性是极不可能的。</p>
<p>在不失一般性的情况下，让我们着重讨论<span class="math notranslate nohighlight">\(A\)</span>的列向量线性独立的情况。</p>
<p>由此可知，<span class="math notranslate nohighlight">\(A\)</span>的列向量张成的空间是<span class="math notranslate nohighlight">\(\mathbb R ^n\)</span>中的一个<span class="math notranslate nohighlight">\(k\)</span>维子空间。</p>
<p>这个张成空间不太”可能”包含任意的 <span class="math notranslate nohighlight">\(y \in \mathbb R ^n\)</span>。</p>
<p>要理解原因，请回顾<a class="reference internal" href="#la-3dvec"><span class="std std-ref">上图</span></a>，其中 <span class="math notranslate nohighlight">\(k=2\)</span> 且 <span class="math notranslate nohighlight">\(n=3\)</span>。</p>
<p>想象一个任意选择的 <span class="math notranslate nohighlight">\(y \in \mathbb R ^3\)</span>，位于这个三维空间中的某处。</p>
<p><span class="math notranslate nohighlight">\(y\)</span> 落在 <span class="math notranslate nohighlight">\(\{a_1, a_2\}\)</span> 的张成空间中（即通过这些点的二维平面）的可能性有多大？</p>
<p>从某种意义上说，这个可能性一定很小，因为这个平面的”厚度”为零。</p>
<p>因此，在 <span class="math notranslate nohighlight">\(n &gt; k\)</span> 的情况下，我们通常会放弃寻求精确解。</p>
<p>然而，我们仍然可以寻求最佳近似解，例如，找到一个使距离 <span class="math notranslate nohighlight">\(\| y - Ax\|\)</span> 尽可能小的 <span class="math notranslate nohighlight">\(x\)</span>。</p>
<p>要解决这个问题，可以使用微积分或正交投影理论。</p>
<p>解为 <span class="math notranslate nohighlight">\(\hat x = (A'A)^{-1}A'y\)</span> — 参见<a class="reference external" href="https://python.quantecon.org/_static/lecture_specific/linear_algebra/course_notes.pdf">这些笔记</a>的第3章。</p>
</section>
<section id="id20">
<h3><span class="section-number">2.4.3. </span>列数多于行数<a class="headerlink" href="#id20" title="Permalink to this heading">#</a></h3>
<p>这是 <span class="math notranslate nohighlight">\(n \times k\)</span> 的情况，其中 <span class="math notranslate nohighlight">\(n &lt; k\)</span>，所以方程数少于未知数。</p>
<p>在这种情况下，要么没有解，要么有无穷多个解 — 换句话说，解永远不会是唯一的。</p>
<p>例如，考虑 <span class="math notranslate nohighlight">\(k=3\)</span> 且 <span class="math notranslate nohighlight">\(n=2\)</span> 的情况。</p>
<p>因此，<span class="math notranslate nohighlight">\(A\)</span> 的列由 <span class="math notranslate nohighlight">\(\mathbb R ^2\)</span> 中的3个向量组成。</p>
<p>这组向量永远不可能线性独立，因为可以找到两个向量就能张成 <span class="math notranslate nohighlight">\(\mathbb R ^2\)</span>。</p>
<p>（例如，使用标准基向量）</p>
<p>由此可知，其中一列是其他两列的线性组合。</p>
<p>例如，假设 <span class="math notranslate nohighlight">\(a_1 = \alpha a_2 + \beta a_3\)</span>。</p>
<p>那么如果 <span class="math notranslate nohighlight">\(y = Ax = x_1 a_1 + x_2 a_2 + x_3 a_3\)</span>，我们也可以写成</p>
<div class="math notranslate nohighlight">
\[
y
= x_1 (\alpha a_2 + \beta a_3) + x_2 a_2 + x_3 a_3
= (x_1 \alpha + x_2) a_2 + (x_1 \beta + x_3) a_3
\]</div>
<p>换句话说，解不具有唯一性。</p>
</section>
<section id="scipy">
<h3><span class="section-number">2.4.4. </span>使用SciPy求解线性方程<a class="headerlink" href="#scipy" title="Permalink to this heading">#</a></h3>
<p id="index-15">下面展示如何使用SciPy的<code class="docutils literal notranslate"><span class="pre">linalg</span></code>子模块求解线性方程。</p>
<p>所有这些程序都是经过时间检验和高度优化的FORTRAN代码的Python前端接口</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># 列向量</span>
<span class="n">det</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>  <span class="c1"># 检查A是非奇异的，因此是可逆的</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-2.0
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A_inv</span> <span class="o">=</span> <span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>  <span class="c1"># 计算逆矩阵</span>
<span class="n">A_inv</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[-2. ,  1. ],
       [ 1.5, -0.5]])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">A_inv</span> <span class="o">@</span> <span class="n">y</span>  <span class="c1"># 解</span>
<span class="n">A</span> <span class="o">@</span> <span class="n">x</span>          <span class="c1"># 应该等于y</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[1.],
       [1.]])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>  <span class="c1"># 产生相同的解</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[-1.],
       [ 1.]])
</pre></div>
</div>
</div>
</div>
<p>观察我们如何通过<code class="docutils literal notranslate"><span class="pre">inv(A)</span> <span class="pre">&#64;</span> <span class="pre">y</span></code>或使用<code class="docutils literal notranslate"><span class="pre">solve(A,</span> <span class="pre">y)</span></code>来求解<span class="math notranslate nohighlight">\(x = A^{-1} y\)</span>。</p>
<p>后一种方法使用不同的算法（LU分解），在数值上更稳定，因此几乎总是应该优先选择。</p>
<p>要获得最小二乘解<span class="math notranslate nohighlight">\(\hat x = (A'A)^{-1}A'y\)</span>，使用<code class="docutils literal notranslate"><span class="pre">scipy.linalg.lstsq(A,</span> <span class="pre">y)</span></code>。</p>
</section>
</section>
<section id="la-eigen">
<span id="id21"></span><h2><a class="toc-backref" href="#id39"><span class="section-number">2.5. </span><span class="target" id="index-16"></span>特征值和<span class="target" id="index-17"></span>特征向量</a><a class="headerlink" href="#la-eigen" title="Permalink to this heading">#</a></h2>
<span class="target" id="index-18"></span><p id="index-19">设<span class="math notranslate nohighlight">\(A\)</span>是一个<span class="math notranslate nohighlight">\(n \times n\)</span>的方阵。</p>
<p>如果<span class="math notranslate nohighlight">\(\lambda\)</span>是一个标量，且<span class="math notranslate nohighlight">\(v\)</span>是<span class="math notranslate nohighlight">\(\mathbb R ^n\)</span>中的非零向量，满足</p>
<div class="math notranslate nohighlight">
\[
A v = \lambda v
\]</div>
<p>则我们称<span class="math notranslate nohighlight">\(\lambda\)</span>是<span class="math notranslate nohighlight">\(A\)</span>的<em>特征值</em>，而<span class="math notranslate nohighlight">\(v\)</span>是<em>特征向量</em>。</p>
<p>因此，<span class="math notranslate nohighlight">\(A\)</span>的特征向量是指当应用映射<span class="math notranslate nohighlight">\(f(x) = Ax\)</span>时，<span class="math notranslate nohighlight">\(v\)</span>仅仅被缩放的向量。</p>
<p>下图显示了两个特征向量（蓝色箭头）及其在<span class="math notranslate nohighlight">\(A\)</span>下的像（红色箭头）。</p>
<p>正如预期的那样，每个向量 <span class="math notranslate nohighlight">\(v\)</span> 的像 <span class="math notranslate nohighlight">\(Av\)</span> 只是原向量的缩放版本</p>
<div class="cell tag_output_scroll docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
     <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="n">eig</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">evecs</span> <span class="o">=</span> <span class="n">evecs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">evecs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="c1"># 设置通过原点的坐标轴</span>
<span class="k">for</span> <span class="n">spine</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;bottom&#39;</span><span class="p">]:</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="n">spine</span><span class="p">]</span><span class="o">.</span><span class="n">set_position</span><span class="p">(</span><span class="s1">&#39;zero&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">spine</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="s1">&#39;top&#39;</span><span class="p">]:</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="n">spine</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>

<span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span>
<span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlim</span><span class="o">=</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">),</span> <span class="n">ylim</span><span class="o">=</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">))</span>

<span class="c1"># 绘制每个特征向量</span>
<span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">evecs</span><span class="p">:</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                <span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span>
                <span class="n">shrink</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
                <span class="n">width</span><span class="o">=</span><span class="mf">0.5</span><span class="p">))</span>

<span class="c1"># 绘制每个特征向量的像</span>
<span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">evecs</span><span class="p">:</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">A</span> <span class="o">@</span> <span class="n">v</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                <span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span>
                <span class="n">shrink</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
                <span class="n">width</span><span class="o">=</span><span class="mf">0.5</span><span class="p">))</span>

<span class="c1"># 绘制它们所在的直线</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">evecs</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;b-&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/88edff116a1f81895367082e79931a2c664165411f1726cf05c6703ed3ae779e.png" src="_images/88edff116a1f81895367082e79931a2c664165411f1726cf05c6703ed3ae779e.png" />
</div>
</div>
<p>特征值方程等价于 <span class="math notranslate nohighlight">\((A - \lambda I) v = 0\)</span>，只有当 <span class="math notranslate nohighlight">\(A - \lambda I\)</span> 的列向量线性相关时，才存在非零解 <span class="math notranslate nohighlight">\(v\)</span>。</p>
<p>这反过来又等价于行列式为零。</p>
<p>因此，要找到所有特征值，我们可以寻找使 <span class="math notranslate nohighlight">\(A - \lambda I\)</span> 的行列式为零的 <span class="math notranslate nohighlight">\(\lambda\)</span> 值。</p>
<p>这个问题可以表示为求解一个关于 <span class="math notranslate nohighlight">\(\lambda\)</span> 的 <span class="math notranslate nohighlight">\(n\)</span> 次多项式的根。</p>
<p>这进而意味着在复平面上存在 <span class="math notranslate nohighlight">\(n\)</span> 个解，尽管有些可能是重复的。</p>
<p>关于方阵 <span class="math notranslate nohighlight">\(A\)</span> 的特征值，有以下一些重要性质：</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(A\)</span> 的行列式等于所有特征值的乘积。</p></li>
<li><p><span class="math notranslate nohighlight">\(A\)</span> 的迹（主对角线上元素的和）等于所有特征值的和。</p></li>
<li><p>如果 <span class="math notranslate nohighlight">\(A\)</span> 是对称矩阵，那么它的所有特征值都是实数。</p></li>
<li><p>如果<span class="math notranslate nohighlight">\(A\)</span>是可逆的，且<span class="math notranslate nohighlight">\(\lambda_1, \ldots, \lambda_n\)</span>是它的特征值，那么<span class="math notranslate nohighlight">\(A^{-1}\)</span>的特征值是<span class="math notranslate nohighlight">\(1/\lambda_1, \ldots, 1/\lambda_n\)</span>。</p></li>
</ol>
<p>第一个陈述的一个推论是：矩阵可逆当且仅当它的所有特征值都不为零。</p>
<p>使用SciPy，我们可以按如下方式求解矩阵的特征值和特征向量</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
     <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">evals</span><span class="p">,</span> <span class="n">evecs</span> <span class="o">=</span> <span class="n">eig</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">evals</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([ 3.+0.j, -1.+0.j])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">evecs</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[ 0.70710678, -0.70710678],
       [ 0.70710678,  0.70710678]])
</pre></div>
</div>
</div>
</div>
<p>注意 <code class="docutils literal notranslate"><span class="pre">evecs</span></code> 的<em>列</em>是特征向量。</p>
<p>由于特征向量的任意标量倍数都是具有相同特征值的特征向量（可以验证），eig 程序会将每个特征向量的长度归一化为1。</p>
<section id="id22">
<h3><span class="section-number">2.5.1. </span>广义特征值<a class="headerlink" href="#id22" title="Permalink to this heading">#</a></h3>
<p>有时考虑<em>广义特征值问题</em>很有用，即对给定的矩阵 <span class="math notranslate nohighlight">\(A\)</span> 和 <span class="math notranslate nohighlight">\(B\)</span>，寻找广义特征值 <span class="math notranslate nohighlight">\(\lambda\)</span> 和特征向量 <span class="math notranslate nohighlight">\(v\)</span>，使得</p>
<div class="math notranslate nohighlight">
\[
A v = \lambda B v
\]</div>
<p>这可以通过 SciPy 中的 <code class="docutils literal notranslate"><span class="pre">scipy.linalg.eig(A,</span> <span class="pre">B)</span></code> 求解。</p>
<p>当然，如果 <span class="math notranslate nohighlight">\(B\)</span> 是方阵且可逆，我们可以将广义特征值问题转化为普通特征值问题 <span class="math notranslate nohighlight">\(B^{-1} A v = \lambda v\)</span>，但情况并非总是如此。</p>
</section>
</section>
<section id="id23">
<h2><a class="toc-backref" href="#id40"><span class="section-number">2.6. </span>进阶主题</a><a class="headerlink" href="#id23" title="Permalink to this heading">#</a></h2>
<p>我们通过简要介绍几个其他重要主题来结束讨论。</p>
<section id="id24">
<h3><span class="section-number">2.6.1. </span>级数展开<a class="headerlink" href="#id24" title="Permalink to this heading">#</a></h3>
<p id="index-20">回顾几何级数的常用求和公式，即</p>
<p>如果 <span class="math notranslate nohighlight">\(|a| &lt; 1\)</span>，那么 <span class="math notranslate nohighlight">\(\sum_{k=0}^{\infty} a^k = (1 - a)^{-1}\)</span>。</p>
<p>这个思想在矩阵环境中有一个推广形式。</p>
<section id="la-mn">
<span id="id25"></span><h4><span class="section-number">2.6.1.1. </span>矩阵范数<a class="headerlink" href="#la-mn" title="Permalink to this heading">#</a></h4>
<p id="index-21">设 <span class="math notranslate nohighlight">\(A\)</span> 为方阵，定义</p>
<div class="math notranslate nohighlight">
\[
\| A \| := \max_{\| x \| = 1} \| A x \|
\]</div>
<p>右边的范数是普通的向量范数，而左边的范数是<em>矩阵范数</em>——在这种情况下，称为<em>谱范数</em>。</p>
<p>例如，对于方阵 <span class="math notranslate nohighlight">\(S\)</span>，条件 <span class="math notranslate nohighlight">\(\| S \| &lt; 1\)</span> 意味着 <span class="math notranslate nohighlight">\(S\)</span> 是<em>压缩的</em>，即它将所有向量拉向原点<a class="footnote-reference brackets" href="#cfn" id="id26">2</a>。</p>
</section>
<section id="la-neumann">
<span id="id27"></span><h4><span class="section-number">2.6.1.2. </span><span class="target" id="index-22"></span>诺伊曼定理<a class="headerlink" href="#la-neumann" title="Permalink to this heading">#</a></h4>
<p id="index-23">设 <span class="math notranslate nohighlight">\(A\)</span> 为方阵，令 <span class="math notranslate nohighlight">\(A^k := A A^{k-1}\)</span>，其中 <span class="math notranslate nohighlight">\(A^1 := A\)</span>。</p>
<p>换句话说，<span class="math notranslate nohighlight">\(A^k\)</span> 是 <span class="math notranslate nohighlight">\(A\)</span> 的 <span class="math notranslate nohighlight">\(k\)</span> 次幂。</p>
<p>诺伊曼定理指出：如果对某个 <span class="math notranslate nohighlight">\(\| A^k \| &lt; 1\)</span></p>
<p><span class="math notranslate nohighlight">\(k \in \mathbb{N}\)</span>，则 <span class="math notranslate nohighlight">\(I - A\)</span> 是可逆的，且</p>
<div class="math notranslate nohighlight" id="equation-la-neumann">
<span class="eqno">(2.4)<a class="headerlink" href="#equation-la-neumann" title="Permalink to this equation">#</a></span>\[(I - A)^{-1} = \sum_{k=0}^{\infty} A^k\]</div>
</section>
<section id="la-neumann-remarks">
<span id="id28"></span><h4><span class="section-number">2.6.1.3. </span><span class="target" id="index-24"></span>谱半径<a class="headerlink" href="#la-neumann-remarks" title="Permalink to this heading">#</a></h4>
<p id="index-25">Gelfand公式告诉我们，对于任意方阵 <span class="math notranslate nohighlight">\(A\)</span>，</p>
<div class="math notranslate nohighlight">
\[
\rho(A) = \lim_{k \to \infty} \| A^k \|^{1/k}
\]</div>
<p>这里 <span class="math notranslate nohighlight">\(\rho(A)\)</span> 是<em>谱半径</em>，定义为 <span class="math notranslate nohighlight">\(\max_i |\lambda_i|\)</span>，其中 <span class="math notranslate nohighlight">\(\{\lambda_i\}_i\)</span> 是 <span class="math notranslate nohighlight">\(A\)</span> 的特征值集合。</p>
<p>作为Gelfand公式的结果，如果所有特征值的模都严格小于1，
则存在一个 <span class="math notranslate nohighlight">\(k\)</span> 使得 <span class="math notranslate nohighlight">\(\| A^k \| &lt; 1\)</span>。</p>
<p>在这种情况下，<a class="reference internal" href="#equation-la-neumann">(2.4)</a> 是有效的。</p>
</section>
</section>
<section id="id29">
<h3><span class="section-number">2.6.2. </span><span class="target" id="index-26"></span>正定矩阵<a class="headerlink" href="#id29" title="Permalink to this heading">#</a></h3>
<p id="index-27">设 <span class="math notranslate nohighlight">\(A\)</span> 是一个 <span class="math notranslate nohighlight">\(n \times n\)</span> 对称矩阵。</p>
<p>我们称 <span class="math notranslate nohighlight">\(A\)</span> 是</p>
<ol class="arabic simple">
<li><p>如果对于每个 <span class="math notranslate nohighlight">\(x \in \mathbb R ^n \setminus \{0\}\)</span>，都有 <span class="math notranslate nohighlight">\(x' A x &gt; 0\)</span>，则称矩阵为<em>正定的</em></p></li>
<li><p>如果对于每个 <span class="math notranslate nohighlight">\(x \in \mathbb R ^n\)</span>，都有 <span class="math notranslate nohighlight">\(x' A x \geq 0\)</span>，则称矩阵为<em>半正定的</em>或<em>非负定的</em></p></li>
</ol>
<p>负定和半负定矩阵有类似的定义。</p>
<p>值得注意的是，如果 <span class="math notranslate nohighlight">\(A\)</span> 是正定的，那么它的所有特征值都严格为正，因此 <span class="math notranslate nohighlight">\(A\)</span> 是可逆的（且其逆矩阵也是正定的）。</p>
</section>
<section id="la-mcalc">
<span id="id30"></span><h3><span class="section-number">2.6.3. </span>线性和二次型的求导<a class="headerlink" href="#la-mcalc" title="Permalink to this heading">#</a></h3>
<p id="index-28">以下公式在许多经济学场景中都很有用。设</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(z, x\)</span> 和 <span class="math notranslate nohighlight">\(a\)</span> 都是 <span class="math notranslate nohighlight">\(n \times 1\)</span> 向量</p></li>
<li><p><span class="math notranslate nohighlight">\(A\)</span> 是 <span class="math notranslate nohighlight">\(n \times n\)</span> 矩阵</p></li>
<li><p><span class="math notranslate nohighlight">\(B\)</span> 是 <span class="math notranslate nohighlight">\(m \times n\)</span> 矩阵，<span class="math notranslate nohighlight">\(y\)</span> 是 <span class="math notranslate nohighlight">\(m \times 1\)</span> 向量</p></li>
</ul>
<p>则</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(\frac{\partial a' x}{\partial x} = a\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\frac{\partial A x}{\partial x} = A'\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\frac{\partial x'A x}{\partial x} = (A + A') x\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\frac{\partial y'B z}{\partial y} = B z\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\frac{\partial y'B z}{\partial B} = y z'\)</span></p></li>
</ol>
<p>下面的<a class="reference internal" href="#la_ex1"><span class="std std-numref">Exercise 2.1</span></a>要求你应用这些公式。</p>
</section>
<section id="id31">
<h3><span class="section-number">2.6.4. </span>延伸阅读<a class="headerlink" href="#id31" title="Permalink to this heading">#</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">scipy.linalg</span></code>子模块的文档可以在<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/linalg.html">这里</a>找到。</p>
<p><a class="reference external" href="https://johnstachurski.net/emet.html">计量经济学理论</a>的第2章和第3章包含了与上述内容类似的线性代数讨论，并附有已解答的练习题。</p>
<p>如果你不介意稍微抽象的方法，<span id="id32">[<a class="reference internal" href="zreferences.html#id178" title="K Jänich. Linear Algebra. Springer Undergraduate Texts in Mathematics and Technology. Springer, 1994.">Jänich, 1994</a>]</span>是一本不错的中级线性代数教材。</p>
</section>
</section>
<section id="id33">
<h2><a class="toc-backref" href="#id41"><span class="section-number">2.7. </span>练习</a><a class="headerlink" href="#id33" title="Permalink to this heading">#</a></h2>
<div class="exercise admonition" id="la_ex1">

<p class="admonition-title"><span class="caption-number">Exercise 2.1 </span></p>
<section id="exercise-content">
<p>设<span class="math notranslate nohighlight">\(x\)</span>是一个给定的<span class="math notranslate nohighlight">\(n \times 1\)</span>向量，考虑以下问题</p>
<div class="math notranslate nohighlight">
\[
v(x) =  \max_{y,u} \left\{ - y'P y - u' Q u \right\}
\]</div>
<p>受限于线性约束</p>
<div class="math notranslate nohighlight">
\[
y = A x + B u
\]</div>
<p>其中</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(P\)</span>是一个<span class="math notranslate nohighlight">\(n \times n\)</span>矩阵，<span class="math notranslate nohighlight">\(Q\)</span>是一个<span class="math notranslate nohighlight">\(m \times m\)</span>矩阵</p></li>
<li><p><span class="math notranslate nohighlight">\(A\)</span>是一个<span class="math notranslate nohighlight">\(n \times n\)</span>矩阵，<span class="math notranslate nohighlight">\(B\)</span>是一个<span class="math notranslate nohighlight">\(n \times m\)</span>矩阵</p></li>
<li><p><span class="math notranslate nohighlight">\(P\)</span>和<span class="math notranslate nohighlight">\(Q\)</span>都是对称且半正定的</p></li>
</ul>
<p>(<span class="math notranslate nohighlight">\(y\)</span> 和 <span class="math notranslate nohighlight">\(u\)</span> 的维度必须是多少才能使这成为一个合理的问题？)</p>
<p>解决这个问题的一种方法是构建拉格朗日函数</p>
<div class="math notranslate nohighlight">
\[
\mathcal L = - y' P y - u' Q u + \lambda' \left[A x + B u - y\right]
\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\lambda\)</span> 是一个 <span class="math notranslate nohighlight">\(n \times 1\)</span> 的拉格朗日乘子向量。</p>
<p>尝试应用上面给出的关于二次型和线性型求导的公式，得到关于 <span class="math notranslate nohighlight">\(y, u\)</span> 的最大化和关于 <span class="math notranslate nohighlight">\(\lambda\)</span> 的最小化的一阶条件。</p>
<p>证明这些条件意味着：</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(\lambda = - 2 P y\)</span>。</p></li>
<li><p><span class="math notranslate nohighlight">\(u\)</span> 的最优选择满足 <span class="math notranslate nohighlight">\(u = - (Q + B' P B)^{-1} B' P A x\)</span>。</p></li>
<li><p>函数 <span class="math notranslate nohighlight">\(v\)</span> 满足 <span class="math notranslate nohighlight">\(v(x) = - x' \tilde P x\)</span>，其中 <span class="math notranslate nohighlight">\(\tilde P = A' P A - A'P B (Q + B'P B)^{-1} B' P A\)</span>。</p></li>
</ol>
<p>正如我们将看到的，在经济学背景下，拉格朗日乘子通常是影子价格。</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>如果我们不关心拉格朗日乘数，我们可以将约束条件代入目标函数，然后仅对<span class="math notranslate nohighlight">\(u\)</span>最大化<span class="math notranslate nohighlight">\(-(Ax + Bu)'P (Ax + Bu) - u' Q u\)</span>。你可以验证这会得到相同的最大值。</p>
</div>
</section>
</div>
<div class="solution dropdown admonition" id="linear_algebra-solution-1">

<p class="admonition-title">Solution to<a class="reference internal" href="#la_ex1"> Exercise 2.1</a></p>
<section id="solution-content">
<p>我们有一个优化问题：</p>
<div class="math notranslate nohighlight">
\[
v(x) = \max_{y,u} \{ -y'Py - u'Qu \}
\]</div>
<p>满足约束条件：</p>
<div class="math notranslate nohighlight">
\[
y = Ax + Bu
\]</div>
<p>其中基本条件为：</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(P\)</span>是一个对称且半正定的<span class="math notranslate nohighlight">\(n \times n\)</span>矩阵</p></li>
<li><p><span class="math notranslate nohighlight">\(Q\)</span>是一个对称且半正定的<span class="math notranslate nohighlight">\(m \times m\)</span>矩阵</p></li>
<li><p><span class="math notranslate nohighlight">\(A\)</span>是一个<span class="math notranslate nohighlight">\(n \times n\)</span>矩阵</p></li>
<li><p><span class="math notranslate nohighlight">\(B\)</span>是一个<span class="math notranslate nohighlight">\(n \times m\)</span>矩阵</p></li>
</ul>
<p>相关的拉格朗日函数是：</p>
<div class="math notranslate nohighlight">
\[
L = -y'Py - u'Qu + \lambda' \lbrack Ax + Bu - y \rbrack
\]</div>
<p><strong>第1步：</strong></p>
<p>对拉格朗日方程关于y求导并令其导数等于零得到：</p>
<div class="math notranslate nohighlight">
\[
\frac{ \partial L}{\partial y} = - (P + P') y - \lambda = - 2 P y - \lambda = 0 \:,
\]</div>
<p>因为P是对称的。</p>
<p>因此，关于y的拉格朗日方程最大化的一阶条件意味着</p>
<div class="math notranslate nohighlight">
\[
\lambda = -2 Py \:
\]</div>
<p><strong>第2步.</strong></p>
<p>对拉格朗日方程关于u求导并令其导数等于零得到</p>
<div class="math notranslate nohighlight">
\[
\frac{ \partial L}{\partial u} = - (Q + Q') u - B'\lambda = - 2Qu + B'\lambda = 0 \:
\]</div>
<p>代入<span class="math notranslate nohighlight">\(\lambda = -2 P y\)</span>得到</p>
<div class="math notranslate nohighlight">
\[
Qu + B'Py = 0 \:
\]</div>
<p>将线性约束<span class="math notranslate nohighlight">\(y = Ax + Bu\)</span>代入上式得到</p>
<div class="math notranslate nohighlight">
\[
Qu + B'P(Ax + Bu) = 0
\]</div>
<div class="math notranslate nohighlight">
\[
(Q + B'PB)u + B'PAx = 0
\]</div>
<p>这是关于u的拉格朗日方程最大化的一阶条件。</p>
<p>因此，u的最优选择必须满足</p>
<div class="math notranslate nohighlight">
\[
u = -(Q + B'PB)^{-1}B'PAx \:,
\]</div>
<p>这是由拉格朗日方程的一阶条件定义得出的。</p>
<p><strong>第3步.</strong></p>
<p>将约束代入目标函数，重写我们的问题，得到</p>
<div class="math notranslate nohighlight">
\[
v(x) = \max_{u} \{ -(Ax+ Bu)'P(Ax+Bu) - u'Qu \} \:
\]</div>
<p>由于我们知道u的最优选择满足<span class="math notranslate nohighlight">\(u = -(Q + B'PB)^{-1}B'PAx\)</span>，那么</p>
<div class="math notranslate nohighlight">
\[v(x) =  -(Ax+ B u)'P(Ax+B u) - u'Q u  \,\,\,\, 其中 \,\,\,\, u = -(Q + B'PB)^{-1}B'PAx
\]</div>
<p>计算函数</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
v(x) &amp;=  -(Ax+ B u)'P(Ax+Bu) - u'Q u \\
&amp;= -(x'A' + u'B')P(Ax+Bu) - u'Q u \\
&amp;= - x'A'PAx - u'B'PAx - x'A'PBu - u'B'PBu - u'Qu \\
&amp;= - x'A'PAx - 2u'B'PAx - u'(Q + B'PB) u
\end{aligned}
\end{split}\]</div>
<p>为简化起见，令 <span class="math notranslate nohighlight">\(S := (Q + B'PB)^{-1} B'PA\)</span>，则 <span class="math notranslate nohighlight">\(u = -Sx\)</span>。</p>
<p>对于第二项 <span class="math notranslate nohighlight">\(- 2u'B'PAx\)</span>，</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
-2u'B'PAx &amp;= -2 x'S'B'PAx  \\
&amp; = 2 x'A'PB( Q + B'PB)^{-1} B'PAx
\end{aligned}
\end{split}\]</div>
<p>注意到项 <span class="math notranslate nohighlight">\((Q + B'PB)^{-1}\)</span> 是对称的，因为 P 和 Q 都是对称的。</p>
<p>对于第三项 <span class="math notranslate nohighlight">\(- u'(Q + B'PB) u\)</span>，</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
-u'(Q + B'PB) u &amp;= - x'S' (Q + B'PB)Sx \\
&amp;= -x'A'PB(Q + B'PB)^{-1}B'PAx
\end{aligned}
\end{split}\]</div>
<p>因此，第二项和第三项的和为
<span class="math notranslate nohighlight">\(x'A'PB(Q + B'PB)^{-1}B'PAx\)</span>。</p>
<p>这意味着</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
 v(x) &amp;= - x'A'PAx - 2u'B'PAx - u'(Q + B'PB) u\\
 &amp;= - x'A'PAx + x'A'PB(Q + B'PB)^{-1}B'PAx \\\end{split}\]</div>
<p>\begin{aligned}
&amp;= -x’[A’PA - A’PB(Q + B’PB)^{-1}B’PA] x
\end{aligned}
$$</p>
<p>因此，优化问题的解
<span class="math notranslate nohighlight">\(v(x) = -x' \tilde{P}x\)</span> 遵循上述结果，其中
<span class="math notranslate nohighlight">\(\tilde{P} := A'PA - A'PB(Q + B'PB)^{-1}B'PA\)</span></p>
</section>
</div>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="fn-mdt"><span class="brackets"><a class="fn-backref" href="#id13">1</a></span></dt>
<dd><p>虽然NumPy中定义了专门的矩阵数据类型，但使用普通的NumPy数组更为标准。
参见<a class="reference external" href="https://python-programming.quantecon.org/numpy.html#matrix-multiplication">此讨论</a>。</p>
</dd>
<dt class="label" id="cfn"><span class="brackets"><a class="fn-backref" href="#id26">2</a></span></dt>
<dd><p>假设 <span class="math notranslate nohighlight">\(\|S \| &lt; 1\)</span>。取任意非零向量 <span class="math notranslate nohighlight">\(x\)</span>，令 <span class="math notranslate nohighlight">\(r := \|x\|\)</span>。我们有 <span class="math notranslate nohighlight">\(\| Sx \| = r \| S (x/r) \| \leq r \| S \| &lt; r = \| x\|\)</span>。因此每个点都被拉向原点。</p>
</dd>
</dl>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                    </div>
                    
                </main> <!-- .page__content -->
                


                <footer class="qe-page__footer">

                    <p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><img src="https://licensebuttons.net/l/by-sa/4.0/80x15.png"></a></p>

                    <p>Creative Commons License &ndash; This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International.</p>

                    <p>A theme by <a href="https://quantecon.org">QuantEcon</a></p>

                </footer> <!-- .page__footer -->

            </div> <!-- .page -->

            

            
            <div class="qe-sidebar bd-sidebar inactive" id="site-navigation">

                <div class="qe-sidebar__header">


                    Contents

                </div>

                <nav class="qe-sidebar__nav" id="qe-sidebar-nav" aria-label="Main navigation">
                    <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  工具与技术
 </span>
</p>
<ul class="current nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="sir_model.html">
   1. 新冠病毒建模
  </a>
 </li>
 <li class="toctree-l1 current active active">
  <a class="current reference internal" href="#">
   2. 线性代数
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="qr_decomp.html">
   3. QR分解
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="eig_circulant.html">
   4. 循环矩阵
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="svd_intro.html">
   5. 奇异值分解（SVD）
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="var_dmd.html">
   6. 向量自回归和动态模态分解
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="newton_method.html">
   7. 使用牛顿法求解经济模型
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  基础统计学
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="prob_matrix.html">
   8. 基础概率论与矩阵
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lln_clt.html">
   9. 大数定律 和 中心极限定理
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="prob_meaning.html">
   10. 概率的两种含义
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="multi_hyper.html">
   11. 多元超几何分布
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="multivariate_normal.html">
   12. 多元正态分布
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="hoist_failure.html">
   13. 故障树不确定性
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="back_prop.html">
   14. 人工神经网络简介
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="rand_resp.html">
   15. 随机化回应调查
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="util_rand_resp.html">
   16. 随机回答的期望效用
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  线性规划
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="opt_transport.html">
   17. 最优传输
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="von_neumann_model.html">
   18. 冯·诺依曼增长模型（及其推广）
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  动态系统导论
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="finite_markov.html">
   19. 有限马尔可夫链
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="inventory_dynamics.html">
   20. 库存动态
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="linear_models.html">
   21. 线性状态空间模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="samuelson.html">
   22. 萨缪尔森乘数-加速器模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="kesten_processes.html">
   23. Kesten过程与企业动态
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="wealth_dynamics.html">
   24. 财富分配动态
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="kalman.html">
   25. 卡尔曼滤波初探
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="kalman_2.html">
   26. 卡尔曼滤波器的另一个视角
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  搜索
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="mccall_model.html">
   27. 工作搜寻 I: McCall搜寻模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mccall_model_with_separation.html">
   28. 工作搜寻 II：搜寻与离职
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mccall_fitted_vfi.html">
   29. 工作搜寻 III: 拟合值函数迭代
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mccall_correlated.html">
   30. 工作搜寻 IV：相关工资报价
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="career.html">
   31. 工作搜寻 V：职业选择建模
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="jv.html">
   32. 工作搜寻 VI：在职搜索
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mccall_q.html">
   33. 工作搜寻 VII：McCall工人的Q学习
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  消费、储蓄与资本
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="cass_koopmans_1.html">
   34. Cass-Koopmans模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cass_koopmans_2.html">
   35. Cass-Koopmans竞争均衡
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cass_fiscal.html">
   36. 带扭曲性税收的Cass-Koopmans模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ak2.html">
   37. 重叠世代模型中的转换
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cake_eating_problem.html">
   38. 蛋糕食用问题 I：最优储蓄导论
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cake_eating_numerical.html">
   39. 蛋糕食用问题 II：数值方法
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="optgrowth.html">
   40. 最优增长 I：随机最优增长模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="optgrowth_fast.html">
   41. 最优增长 II：使用Numba加速代码
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="coleman_policy_iter.html">
   42. 最优增长 III：时间迭代
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="egm_policy_iter.html">
   43. 最优增长 IV：内生网格法
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ifp.html">
   44. 收入波动问题 I：基本模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ifp_advanced.html">
   45. 收入波动问题 II：资产随机收益
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  贝叶斯定律
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="bayes_nonconj.html">
   46. 非共轭先验
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ar1_bayes.html">
   47. AR(1)参数的后验分布
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ar1_turningpts.html">
   48. 预测 AR(1) 过程
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  信息论
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="odu.html">
   49. 求职搜索 VII: 带学习的搜索
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="likelihood_ratio_process.html">
   50. 似然比过程
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="imp_sample.html">
   51. 计算似然比过程的均值
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="wald_friedman.html">
   52. 让弥尔顿·弗里德曼困惑的问题
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="exchangeable.html">
   53. 可交换性和贝叶斯更新
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="likelihood_bayes.html">
   54. 似然比过程和贝叶斯学习
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mix_model.html">
   55. 错误模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="navy_captain.html">
   56. 贝叶斯与频率主义决策规则的比较
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  LQ控制
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="lqcontrol.html">
   57. LQ控制：基础
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lagrangian_lqdp.html">
   58. LQ控制的拉格朗日方法
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cross_product_trick.html">
   59. 消除交叉项
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="perm_income.html">
   60. 永久收入模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="perm_income_cons.html">
   61. 永久收入 II：线性二次方法
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lq_inventories.html">
   62. 通过库存实现生产平滑
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  多主体模型
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="lake_model.html">
   63. 就业和失业的湖泊模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="rational_expectations.html">
   64. 理性预期均衡
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="re_with_feedback.html">
   65. 线性理性预期模型中的稳定性
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="markov_perf.html">
   66. 马尔可夫完美均衡
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="uncertainty_traps.html">
   67. 不确定性陷阱
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="aiyagari.html">
   68. 艾亚加里模型
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  资产定价与金融
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="markov_asset.html">
   69. 资产定价：有限状态模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ge_arrow.html">
   70. 带有阿罗证券的竞争均衡
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="harrison_kreps.html">
   71. 异质信念与泡沫
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  数据与实证
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="pandas_panel.html">
   72. 面板数据的Pandas使用
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ols.html">
   73. Python线性回归
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mle.html">
   74. 最大似然估计
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  拍卖
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="two_auctions.html">
   75. 一价和二价拍卖
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="house_auction.html">
   76. 多种商品分配机制
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  其他
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="troubleshooting.html">
   77. 故障排除
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="zreferences.html">
   78. 参考文献
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="status.html">
   79. 执行统计
  </a>
 </li>
</ul>

                </nav>

                <div class="qe-sidebar__footer">

                </div>

            </div> <!-- .sidebar -->
            
        </div> <!-- .main -->

        <div class="qe-toolbar">

            <div class="qe-toolbar__inner">

                <ul class="qe-toolbar__main">
                    <li data-tippy-content="Table of Contents" class="btn__sidebar"><i data-feather="menu"></i></li>
                    <li data-tippy-content="Home"><a href="intro.html"><i data-feather="home"></i></a></li>
                    <li class="btn__qelogo"><a href="https://quantecon.org" title=""><span class="show-for-sr">QuantEcon</span></a></li>
                </ul>

                <ul class="qe-toolbar__links">
                    <li class="btn__search">
                        <form action="search.html" method="get">
                            <input type="search" class="form-control" name="q" id="search-input" placeholder="Search..." aria-label="Search..." autocomplete="off" accesskey="k">
                            <i data-feather="search" id="search-icon"></i>
                        </form>
                    </li>
                    <li data-tippy-content="Fullscreen" class="btn__fullscreen"><i data-feather="maximize"></i></li>
                    <li data-tippy-content="Increase font size" class="btn__plus"><i data-feather="plus-circle"></i></li>
                    <li data-tippy-content="Decrease font size" class="btn__minus"><i data-feather="minus-circle"></i></li>
                    <li data-tippy-content="Change contrast" class="btn__contrast"><i data-feather="sunset"></i></li>
                    <li data-tippy-content="Download Notebook"><a href="/_notebooks/linear_algebra.ipynb" download><i data-feather="download-cloud"></i></a></li>
                    <li class="settings-button" id="settingsButton"><div data-tippy-content="Launch Notebook"><i data-feather="play-circle"></i></div></li>
                        <li data-tippy-content="Download PDF" onClick="window.print()"><i data-feather="file"></i></li>
                    <!--
                    # Enable if looking for link to specific document hosted on GitHub
                    <li data-tippy-content="View Source"><a target="_blank" href="https://github.com/QuantEcon/lecture-python.myst/linear_algebra.md" download><i data-feather="github"></i></a></li>
                    -->
                    <li data-tippy-content="View Source"><a target="_blank" href="https://github.com/QuantEcon/lecture-python.myst" download><i data-feather="github"></i></a></li>
                </ul>

            </div>

        </div> <!-- .toolbar -->
        <div id="downloadPDFModal" style="display: none;">
            <ul class="pdf-options" style="display: block;">
                <li class="download-pdf-book" onClick="window.print()">
                    <p>Lecture (PDF)</p>
                </li>
                <li class="download-pdf-file">
                    <a href="" download><p>Book (PDF)</p></a>
                </li>
            </ul>
        </div>
        <div id="settingsModal" style="display: none;">
            <p class="modal-title"> Notebook Launcher </p>
            <div class="modal-desc">
            <p>
                Choose public or private cloud service for "Launch" button.
            </p>
            </div>
            <p class="modal-subtitle">Select a server</p>
            <ul class="modal-servers">
            <li class="active launcher-public">
                <span class="label">Public</span>
                <select id="launcher-public-input">
                
                    <option value="https://colab.research.google.com/github/QuantEcon/lecture-python.zh-cn.notebooks/blob/main/linear_algebra.ipynb">Colab</option>
                
                </select>
                <i class="fas fa-check-circle"></i>
            </li>
            <li class="launcher-private">
                <span class="label">Private</span>
                <input type="text" id="launcher-private-input" data-repourl="https://github.com/QuantEcon/lecture-python.zh-cn.notebooks" data-urlpath="tree/lecture-python.zh-cn.notebooks/linear_algebra.ipynb" data-branch=main>
                <i class="fas fa-check-circle"></i>
            </li>
            </ul>
            <p class="launch"><a href="https://colab.research.google.com/github/QuantEcon/lecture-python.zh-cn.notebooks/blob/main/linear_algebra.ipynb" id="advancedLaunchButton" target="_blank">Launch Notebook</a></p>
            <script>
                // QuantEcon Notebook Launcher
                const launcherTypeElements = document.querySelectorAll('#settingsModal .modal-servers li');
                // Highlight the server type if previous selection exists
                if (typeof localStorage.launcherType !== 'undefined') {
                  for (var i = 0; i < launcherTypeElements.length; i++) {
                    launcherTypeElements[i].classList.remove('active');
                    if ( launcherTypeElements[i].classList.contains(localStorage.launcherType) ) {
                      launcherTypeElements[i].classList.add('active');
                    }
                  }
                }
                // Highlight server type on click and set local storage value
                for (var i = 0; i < launcherTypeElements.length; i++) {
                  launcherTypeElements[i].addEventListener('click', function() {
                    for (var j = 0; j < launcherTypeElements.length; j++) {
                      launcherTypeElements[j].classList.remove('active');
                    }
                    this.classList.add('active');
                    if ( this.classList.contains('launcher-private') ) {
                      localStorage.launcherType = 'launcher-private';
                    } else if ( this.classList.contains('launcher-public') ) {
                      localStorage.launcherType = 'launcher-public';
                    }
                    setLaunchServer();
                  })
                }
                const launcherPublic = document.getElementById('launcher-public-input');
                const launcherPrivate = document.getElementById('launcher-private-input');
                const pageName = "linear_algebra";
                const repoURL = "https://github.com/QuantEcon/lecture-python.zh-cn.notebooks";
                const urlPath = "tree/lecture-python.zh-cn.notebooks/linear_algebra.ipynb";
                const branch = "main"
                const launchNotebookLink = document.getElementById('advancedLaunchButton');

                // Highlight public server option if previous selection exists
                if (typeof localStorage.launcherPublic !== 'undefined') {
                  launcherPublic.value = localStorage.launcherPublic;
                }
                // Update local storage upon public server selection
                launcherPublic.addEventListener('change', (event) => {
                  setLaunchServer();
                });
                // Populate private server input if previous entry exists
                if (typeof localStorage.launcherPrivate !== 'undefined') {
                  launcherPrivate.value = localStorage.launcherPrivate;
                }
                // Update local storage when a private server is entered
                launcherPrivate.addEventListener('input', (event) => {
                  setLaunchServer();
                });

                // Function to update the "Launch Notebook" link href
                function setLaunchServer() {
                  launchNotebookLink.removeAttribute("style")
                  if ( localStorage.launcherType == 'launcher-private' ) {
                    let repoPrefix = "/user-redirect/git-pull?repo=" + repoURL + "&branch=" + branch + "&urlpath=" + urlPath;
                    launcherPrivateValue = launcherPrivate.value
                    if (!launcherPrivateValue) {
                        launchNotebookLink.removeAttribute("href")
                        launchNotebookLink.style.background = "grey"
                        return
                    }
                    localStorage.launcherPrivate = launcherPrivateValue;
                    privateServer = localStorage.launcherPrivate.replace(/\/$/, "")
                    if (!privateServer.includes("http")) {
                        privateServer = "http://" + privateServer
                    }
                    launchNotebookLinkURL = privateServer + repoPrefix;
                  } else if ( localStorage.launcherType == 'launcher-public' ) {
                    launcherPublicValue = launcherPublic.options[launcherPublic.selectedIndex].value;
                    localStorage.launcherPublic = launcherPublicValue;
                    launchNotebookLinkURL = localStorage.launcherPublic;
                  }
                  if (launchNotebookLinkURL) launchNotebookLink.href = launchNotebookLinkURL;
                }
                // Check if user has previously selected a server
                if ( (typeof localStorage.launcherPrivate !== 'undefined') || (typeof localStorage.launcherPublic !== 'undefined') ) {
                  setLaunchServer();
                }
                </script>

        </div>

    </div> <!-- .wrapper-->
  </body>
</html>