

<!DOCTYPE html>


<html lang="en" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>12. 多元正态分布 &#8212; Python中级数量经济学</title>
    <script src="https://unpkg.com/@popperjs/core@2.9.2/dist/umd/popper.min.js"></script>
    <script src="https://unpkg.com/tippy.js@6.3.1/dist/tippy-bundle.umd.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
    
        <script>
            MathJax = {
            loader: {load: ['[tex]/boldsymbol', '[tex]/textmacros']},
            tex: {
                packages: {'[+]': ['boldsymbol', 'textmacros']},
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                processEscapes: true,
                macros: {
                    "argmax" : "arg\\,max",
                    "argmin" : "arg\\,min",
                    "col"    : "col",
                    "Span"   :  "span",
                    "epsilon": "\\varepsilon",
                    "EE": "\\mathbb{E}",
                    "PP": "\\mathbb{P}",
                    "RR": "\\mathbb{R}",
                    "NN": "\\mathbb{N}",
                    "ZZ": "\\mathbb{Z}",
                    "aA": "\\mathcal{A}",
                    "bB": "\\mathcal{B}",
                    "cC": "\\mathcal{C}",
                    "dD": "\\mathcal{D}",
                    "eE": "\\mathcal{E}",
                    "fF": "\\mathcal{F}",
                    "gG": "\\mathcal{G}",
                    "hH": "\\mathcal{H}",
                }
            },
            svg: {
                fontCache: 'global',
                scale: 0.92,
                displayAlign: "center",
            },
            };
        </script>
    
    
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/quantecon-book-theme.css?digest=bd0785fbb14d8d2bd4d9ae501d79ed8d3bc089ec" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/exercise.css" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-design.5ea377869091fd0449014c60fc090103.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>


    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/scripts/quantecon-book-theme.js?digest=d9faaf6c4b57726f74ba012412af1f5681bdff87"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js"></script>
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-J0SMYR4SG3"></script>
    <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){ dataLayer.push(arguments); }
                gtag('js', new Date());
                gtag('config', 'G-J0SMYR4SG3');
            </script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"argmax": "arg\\,max", "argmin": "arg\\,min"}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'multivariate_normal';</script>
    <link rel="canonical" href="https://python.quantecon-zh-cn.org/multivariate_normal.html" />
    <link rel="shortcut icon" href="_static/lectures-favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="13. 故障树不确定性" href="hoist_failure.html" />
    <link rel="prev" title="11. 多元超几何分布" href="multi_hyper.html" />

<!-- Normal Meta Tags -->
<meta name="author" context="Thomas J. Sargent &amp; John Stachurski" />
<meta name="keywords" content="Python, QuantEcon, Quantitative Economics, Economics, Sloan, Alfred P. Sloan Foundation, Tom J. Sargent, John Stachurski" />
<meta name="description" content=本课程是由托马斯·萨金特（Thomas J. Sargent）和约翰·斯塔胡斯基（John Stachurski）设计和编写的数量经济建模讲座。 />

<!-- Twitter tags -->
<meta name="twitter:card" content="summary" />
<meta name="twitter:site" content="@quantecon" />
<meta name="twitter:title" content="多元正态分布"/>
<meta name="twitter:description" content="本课程是由托马斯·萨金特（Thomas J. Sargent）和约翰·斯塔胡斯基（John Stachurski）设计和编写的数量经济建模讲座。">
<meta name="twitter:creator" content="@quantecon">
<meta name="twitter:image" content="https://assets.quantecon.org/img/qe-twitter-logo.png">

<!-- Opengraph tags -->
<meta property="og:title" content="多元正态分布" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://python.quantecon-zh-cn.org/multivariate_normal.html" />
<meta property="og:image" content="https://assets.quantecon.org/img/qe-og-logo.png" />
<meta property="og:description" content="本课程是由托马斯·萨金特（Thomas J. Sargent）和约翰·斯塔胡斯基（John Stachurski）设计和编写的数量经济建模讲座。" />
<meta property="og:site_name" content="Python中级数量经济学" />
<meta name="theme-color" content="#ffffff" />

  </head>
<body>

<!-- Override QuantEcon theme colors -->

    <span id="top"></span>

    <div class="qe-wrapper">

        <div class="qe-main">

            <div class="qe-page" id=multivariate_normal>

                <div class="qe-page__toc">

                    <div class="inner">

                        
                        <div class="qe-page__toc-header">
                            On this page
                        </div>


                        <nav id="bd-toc-nav" class="qe-page__toc-nav">
                            <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id3">12.1. 概述</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id4">12.2. 多元正态分布</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">12.3. 二元示例</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id6">12.4. 三变量示例</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#iq">12.5. 一维智力（IQ）</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id7">12.6. 信息即惊奇</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#cholesky">12.7. Cholesky因子魔法</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id8">12.8. 数学和语言智力</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id9">12.9. 单变量时间序列分析</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id10">12.9.1. 平滑示例</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id11">12.9.2. 滤波练习</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id12">12.9.3. 预测练习</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id13">12.9.4. 构建沃尔德表示</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id14">12.10. 随机差分方程</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id15">12.11. 应用于股票价格模型</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id16">12.12. 滤波基础</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id17">12.12.1. 迈向动态分析</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id18">12.12.2. 动态版本</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id19">12.12.3. 一个例子</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#id20">12.12.4. 迭代代码</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id21">12.13. 经典因子分析模型</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pca">12.14. PCA和因子分析</a></li>
</ul>
                            <p class="logo">
                                
                                    
                                    <a href=https://quantecon.org><img src="_static/qe-logo-large.png" class="logo logo-img" alt="logo"></a>
                                    
                                    
                                
                            </p>

                            <p class="powered">Powered by <a href="https://jupyterbook.org/">Jupyter Book</a></p>

                        </nav>

                        <div class="qe-page__toc-footer">
                            
                            
                            <p><a href="#top"><strong>Back to top</strong></a></p>
                        </div>

                    </div>

                </div>

                <div class="qe-page__header">

                    <div class="qe-page__header-copy">

                        <p class="qe-page__header-heading"><a href="intro.html">Python中级数量经济学</a></p>

                        <p class="qe-page__header-subheading">多元正态分布</p>

                    </div>
                    <!-- length 2, since its a string and empty dict has length 2 - {} -->
                        <p class="qe-page__header-authors" font-size="18">
                            
                                
                                    <a href="http://www.tomsargent.com/" target="_blank"><span>托马斯·萨金特（Thomas J. Sargent）</span></a>
                                
                            
                                
                                    and <a href="https://johnstachurski.net/" target="_blank"><span>约翰·斯塔胡斯基（John Stachurski）</span></a>
                                
                            
                        </p>


                </div> <!-- .page__header -->



                
                <main class="qe-page__content" role="main">
                    
                    <div>
                        
  <section class="tex2jax_ignore mathjax_ignore" id="id1">
<h1><a class="toc-backref" href="#id22"><span class="section-number">12. </span>多元正态分布</a><a class="headerlink" href="#id1" title="Permalink to this heading">#</a></h1>
<div class="contents topic" id="id2">
<p class="topic-title">目录</p>
<ul class="simple">
<li><p><a class="reference internal" href="#id1" id="id22">多元正态分布</a></p>
<ul>
<li><p><a class="reference internal" href="#id3" id="id23">概述</a></p></li>
<li><p><a class="reference internal" href="#id4" id="id24">多元正态分布</a></p></li>
<li><p><a class="reference internal" href="#id5" id="id25">二元示例</a></p></li>
<li><p><a class="reference internal" href="#id6" id="id26">三变量示例</a></p></li>
<li><p><a class="reference internal" href="#iq" id="id27">一维智力（IQ）</a></p></li>
<li><p><a class="reference internal" href="#id7" id="id28">信息即惊奇</a></p></li>
<li><p><a class="reference internal" href="#cholesky" id="id29">Cholesky因子魔法</a></p></li>
<li><p><a class="reference internal" href="#id8" id="id30">数学和语言智力</a></p></li>
<li><p><a class="reference internal" href="#id9" id="id31">单变量时间序列分析</a></p></li>
<li><p><a class="reference internal" href="#id14" id="id32">随机差分方程</a></p></li>
<li><p><a class="reference internal" href="#id15" id="id33">应用于股票价格模型</a></p></li>
<li><p><a class="reference internal" href="#id16" id="id34">滤波基础</a></p></li>
<li><p><a class="reference internal" href="#id21" id="id35">经典因子分析模型</a></p></li>
<li><p><a class="reference internal" href="#pca" id="id36">PCA和因子分析</a></p></li>
</ul>
</li>
</ul>
</div>
<section id="id3">
<h2><a class="toc-backref" href="#id23"><span class="section-number">12.1. </span>概述</a><a class="headerlink" href="#id3" title="Permalink to this heading">#</a></h2>
<p>本讲座介绍概率论、统计学和经济学中的一个重要工具，即<strong>多元正态分布</strong>。</p>
<p>在本讲座中，你将学习以下公式：</p>
<ul class="simple">
<li><p>长度为N的随机向量<span class="math notranslate nohighlight">\(x\)</span>的联合分布</p></li>
<li><p><span class="math notranslate nohighlight">\(x\)</span>的所有子向量的边际分布</p></li>
<li><p><span class="math notranslate nohighlight">\(x\)</span>的子向量在其他子向量条件下的条件分布</p></li>
</ul>
<p>我们将使用多元正态分布来构建一些有用的模型：</p>
<ul class="simple">
<li><p>智商(IQ)的因子分析模型</p></li>
<li><p>两种独立固有能力(如数学和语言能力)的因子分析模型</p></li>
<li><p>更一般的因子分析模型</p></li>
<li><p>作为因子分析模型近似的主成分分析(PCA)</p></li>
<li><p>由线性随机差分方程生成的时间序列</p></li>
<li><p>最优线性滤波理论</p></li>
</ul>
</section>
<section id="id4">
<h2><a class="toc-backref" href="#id24"><span class="section-number">12.2. </span>多元正态分布</a><a class="headerlink" href="#id4" title="Permalink to this heading">#</a></h2>
<p>本讲将定义一个Python类<code class="docutils literal notranslate"><span class="pre">MultivariateNormal</span></code>，用于生成与多元正态分布相关的<strong>边缘</strong>和<strong>条件</strong>分布。</p>
<p>对于多元正态分布，非常方便的是：</p>
<ul class="simple">
<li><p>条件期望等于线性最小二乘投影</p></li>
<li><p>条件分布由多元线性回归表征</p></li>
</ul>
<p>我们将把我们的Python类应用到一些例子中。</p>
<p>我们使用以下导入：</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
<span class="n">FONTPATH</span> <span class="o">=</span> <span class="s2">&quot;fonts/SourceHanSerifSC-SemiBold.otf&quot;</span>
<span class="n">mpl</span><span class="o">.</span><span class="n">font_manager</span><span class="o">.</span><span class="n">fontManager</span><span class="o">.</span><span class="n">addfont</span><span class="p">(</span><span class="n">FONTPATH</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;font.family&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Source Han Serif SC&#39;</span><span class="p">]</span>

<span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;figure.figsize&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>  <span class="c1">#设置默认图形大小</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">jit</span>
<span class="kn">import</span> <span class="nn">statsmodels.api</span> <span class="k">as</span> <span class="nn">sm</span>
</pre></div>
</div>
</div>
</div>
<p>假设 <span class="math notranslate nohighlight">\(N \times 1\)</span> 随机向量 <span class="math notranslate nohighlight">\(z\)</span> 具有多元正态概率密度。</p>
<p>这意味着概率密度的形式为</p>
<div class="math notranslate nohighlight">
\[
f\left(z;\mu,\Sigma\right)=\left(2\pi\right)^{-\left(\frac{N}{2}\right)}\det\left(\Sigma\right)^{-\frac{1}{2}}\exp\left(-.5\left(z-\mu\right)^{\prime}\Sigma^{-1}\left(z-\mu\right)\right)
\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\mu=Ez\)</span> 是随机向量 <span class="math notranslate nohighlight">\(z\)</span> 的均值，<span class="math notranslate nohighlight">\(\Sigma=E\left(z-\mu\right)\left(z-\mu\right)^\prime\)</span> 是 <span class="math notranslate nohighlight">\(z\)</span> 的协方差矩阵。</p>
<p>协方差矩阵 <span class="math notranslate nohighlight">\(\Sigma\)</span> 是对称且正定的。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">μ</span><span class="p">,</span> <span class="n">Σ</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    多元正态分布的密度函数。</span>

<span class="sd">    参数</span>
<span class="sd">    ---------------</span>
<span class="sd">    z: ndarray(float, dim=2)</span>
<span class="sd">        随机向量，N x 1</span>
<span class="sd">    μ: ndarray(float, dim=1 or 2)</span>
<span class="sd">        z的均值，N x 1</span>
<span class="sd">    Σ: ndarray(float, dim=2)</span>
<span class="sd">        z的协方差矩阵，N x 1</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="n">μ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">μ</span><span class="p">)</span>
    <span class="n">Σ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">Σ</span><span class="p">)</span>

    <span class="n">N</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">size</span>

    <span class="n">temp1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">Σ</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">temp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">z</span> <span class="o">-</span> <span class="n">μ</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">Σ</span><span class="p">)</span> <span class="o">@</span> <span class="p">(</span><span class="n">z</span> <span class="o">-</span> <span class="n">μ</span><span class="p">))</span>

    <span class="k">return</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">temp1</span> <span class="o">*</span> <span class="n">temp2</span>
</pre></div>
</div>
</div>
</div>
<p>对于某个整数 <span class="math notranslate nohighlight">\(k\in \{1,\dots, N-1\}\)</span>，将 <span class="math notranslate nohighlight">\(z\)</span> 分割为</p>
<div class="math notranslate nohighlight">
\[\begin{split}
z=\left[\begin{array}{c} z_{1}\\ z_{2} \end{array}\right],
\end{split}\]</div>
<p>其中 <span class="math notranslate nohighlight">\(z_1\)</span> 是一个 <span class="math notranslate nohighlight">\(\left(N-k\right)\times1\)</span> 向量，<span class="math notranslate nohighlight">\(z_2\)</span> 是一个 <span class="math notranslate nohighlight">\(k\times1\)</span> 向量。</p>
<p>令</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mu=\left[\begin{array}{c}
\mu_{1}\\
\mu_{2}
\end{array}\right],\quad\Sigma=\left[\begin{array}{cc}
\Sigma_{11} &amp; \Sigma_{12}\\
\Sigma_{21} &amp; \Sigma_{22}
\end{array}\right]
\end{split}\]</div>
<p>为 <span class="math notranslate nohighlight">\(\mu\)</span> 和 <span class="math notranslate nohighlight">\(\Sigma\)</span> 的相应分割。</p>
<p><span class="math notranslate nohighlight">\(z_1\)</span> 的<strong>边缘</strong>分布是：</p>
<ul class="simple">
<li><p>多元正态分布，均值为 <span class="math notranslate nohighlight">\(\mu_1\)</span>，协方差矩阵为 <span class="math notranslate nohighlight">\(\Sigma_{11}\)</span>。</p></li>
</ul>
<p><span class="math notranslate nohighlight">\(z_2\)</span> 的<strong>边缘</strong>分布是：</p>
<ul class="simple">
<li><p>多元正态分布，均值为 <span class="math notranslate nohighlight">\(\mu_2\)</span>，协方差矩阵为 <span class="math notranslate nohighlight">\(\Sigma_{22}\)</span>。</p></li>
</ul>
<p>在给定 <span class="math notranslate nohighlight">\(z_2\)</span> 条件下，<span class="math notranslate nohighlight">\(z_1\)</span> 的<strong>条件</strong>分布是：</p>
<ul class="simple">
<li><p>多元正态分布，均值为</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
\hat{\mu}_1 = \mu_1 + \beta \left(z_2 -\mu_2\right)
\]</div>
<p>协方差矩阵为</p>
<div class="math notranslate nohighlight">
\[
\hat{\Sigma}_{11}=\Sigma_{11}-\Sigma_{12}\Sigma_{22}^{-1}\Sigma_{21}=\Sigma_{11}-\beta\Sigma_{22}\beta^{\prime}
\]</div>
<p>其中</p>
<div class="math notranslate nohighlight">
\[\beta = \Sigma_{12}\Sigma_{22}^{-1}
\]</div>
<p>是一个 <span class="math notranslate nohighlight">\(\left(N-k\right) \times k\)</span> 的<strong>总体回归系数</strong>矩阵，表示 <span class="math notranslate nohighlight">\((N -k) \times 1\)</span> 随机向量 <span class="math notranslate nohighlight">\(z_1 - \mu_1\)</span> 对 <span class="math notranslate nohighlight">\(k \times 1\)</span> 随机向量 <span class="math notranslate nohighlight">\(z_2 - \mu_2\)</span> 的回归系数。</p>
<p>以下类构造了一个多元正态分布实例，具有两个方法：</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">partition</span></code>方法计算 <span class="math notranslate nohighlight">\(\beta\)</span>，以 <span class="math notranslate nohighlight">\(k\)</span> 作为输入</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cond_dist</span></code>方法计算 <span class="math notranslate nohighlight">\(z_1\)</span> 在给定 <span class="math notranslate nohighlight">\(z_2\)</span> 条件下的分布，或 <span class="math notranslate nohighlight">\(z_2\)</span> 在给定 <span class="math notranslate nohighlight">\(z_1\)</span> 条件下的分布</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MultivariateNormal</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    多元正态分布类。</span>

<span class="sd">    参数</span>
<span class="sd">    ----------</span>
<span class="sd">    μ: ndarray(float, dim=1)</span>
<span class="sd">        z的均值，N乘1</span>
<span class="sd">    Σ: ndarray(float, dim=2)</span>
<span class="sd">        z的协方差矩阵，N乘1</span>

<span class="sd">    属性</span>
<span class="sd">    ---------</span>
<span class="sd">    μ, Σ:</span>
<span class="sd">        见参数</span>
<span class="sd">    μs: list(ndarray(float, dim=1))</span>
<span class="sd">        按顺序排列的均值向量μ1和μ2的列表</span>
<span class="sd">    Σs: list(list(ndarray(float, dim=2)))</span>
<span class="sd">        按顺序排列的协方差矩阵Σ11、Σ12、Σ21、Σ22的二维列表</span>
<span class="sd">    βs: list(ndarray(float, dim=1))</span>
<span class="sd">        按顺序排列的回归系数β1和β2的列表</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">μ</span><span class="p">,</span> <span class="n">Σ</span><span class="p">):</span>
        <span class="s2">&quot;初始化&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">μ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">μ</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Σ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">Σ</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        给定k，将随机向量z分割为大小为k的向量z1和大小为N-k的向量z2。</span>
<span class="sd">        相应地将均值向量μ分割为μ1和μ2，将协方差矩阵Σ分割为Σ11、Σ12、</span>
<span class="sd">        Σ21、Σ22。使用分割后的数组计算回归系数β1和β2。</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">μ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">μ</span>
        <span class="n">Σ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Σ</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">μs</span> <span class="o">=</span> <span class="p">[</span><span class="n">μ</span><span class="p">[:</span><span class="n">k</span><span class="p">],</span> <span class="n">μ</span><span class="p">[</span><span class="n">k</span><span class="p">:]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Σs</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Σ</span><span class="p">[:</span><span class="n">k</span><span class="p">,</span> <span class="p">:</span><span class="n">k</span><span class="p">],</span> <span class="n">Σ</span><span class="p">[:</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">:]],</span>
                   <span class="p">[</span><span class="n">Σ</span><span class="p">[</span><span class="n">k</span><span class="p">:,</span> <span class="p">:</span><span class="n">k</span><span class="p">],</span> <span class="n">Σ</span><span class="p">[</span><span class="n">k</span><span class="p">:,</span> <span class="n">k</span><span class="p">:]]]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">βs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Σs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Σs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">Σs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Σs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])]</span>

    <span class="k">def</span> <span class="nf">cond_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        计算在给定z2条件下z1的条件分布，或反之。</span>
<span class="sd">        参数ind决定我们是计算z1的条件分布(ind=0)还是z2的条件分布(ind=1)。</span>

<span class="sd">        返回值</span>
<span class="sd">        ---------</span>
<span class="sd">        μ_hat: ndarray(float, ndim=1)</span>
<span class="sd">            z1或z2的条件均值。</span>
<span class="sd">        Σ_hat: ndarray(float, ndim=2)</span>
<span class="sd">            z1或z2的条件协方差矩阵。</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">β</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">βs</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
        <span class="n">μs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">μs</span>
        <span class="n">Σs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Σs</span>

        <span class="n">μ_hat</span> <span class="o">=</span> <span class="n">μs</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">+</span> <span class="n">β</span> <span class="o">@</span> <span class="p">(</span><span class="n">z</span> <span class="o">-</span> <span class="n">μs</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="n">ind</span><span class="p">])</span>
        <span class="n">Σ_hat</span> <span class="o">=</span> <span class="n">Σs</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">ind</span><span class="p">]</span> <span class="o">-</span> <span class="n">β</span> <span class="o">@</span> <span class="n">Σs</span><span class="p">[</span><span class="mi">1</span><span class="o">-</span><span class="n">ind</span><span class="p">][</span><span class="mi">1</span><span class="o">-</span><span class="n">ind</span><span class="p">]</span> <span class="o">@</span> <span class="n">β</span><span class="o">.</span><span class="n">T</span>

        <span class="k">return</span> <span class="n">μ_hat</span><span class="p">,</span> <span class="n">Σ_hat</span>
</pre></div>
</div>
</div>
</div>
<p>让我们通过一系列示例来运用这段代码。</p>
<p>我们先从一个简单的二元示例开始；之后我们将转向三元示例。</p>
<p>我们将使用我们的<code class="docutils literal notranslate"><span class="pre">MultivariateNormal</span></code>类来计算一些条件分布的总体矩。</p>
<p>为了增添趣味，我们还将通过生成模拟数据并计算线性最小二乘回归来计算相关总体回归的样本类比。</p>
<p>我们将比较这些模拟数据的线性最小二乘回归与其总体对应值。</p>
</section>
<section id="id5">
<h2><a class="toc-backref" href="#id25"><span class="section-number">12.3. </span>二元示例</a><a class="headerlink" href="#id5" title="Permalink to this heading">#</a></h2>
<p>我们从由以下参数确定的二元正态分布开始</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mu=\left[\begin{array}{c}
.5 \\
1.0
\end{array}\right],\quad\Sigma=\left[\begin{array}{cc}
1 &amp; .5\\
.5 &amp; 1
\end{array}\right]
\end{split}\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">μ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">.5</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span>
<span class="n">Σ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">.5</span> <span class="p">,</span><span class="mf">1.</span><span class="p">]])</span>

<span class="c1"># 构建多元正态分布实例</span>
<span class="n">multi_normal</span> <span class="o">=</span> <span class="n">MultivariateNormal</span><span class="p">(</span><span class="n">μ</span><span class="p">,</span> <span class="n">Σ</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">k</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># 选择分区</span>

<span class="c1"># 分区并计算回归系数</span>
<span class="n">multi_normal</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="n">multi_normal</span><span class="o">.</span><span class="n">βs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">multi_normal</span><span class="o">.</span><span class="n">βs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(array([[0.5]]), array([[0.5]]))
</pre></div>
</div>
</div>
</div>
<p>让我们说明一下你可以_把任何东西都可以回归到其他任何东西上_这个事实。</p>
<p>我们已经计算了所需的一切，可以计算两条回归线，一条是<span class="math notranslate nohighlight">\(z_2\)</span>对<span class="math notranslate nohighlight">\(z_1\)</span>的回归，另一条是<span class="math notranslate nohighlight">\(z_1\)</span>对<span class="math notranslate nohighlight">\(z_2\)</span>的回归。</p>
<p>我们将这些回归表示为</p>
<div class="math notranslate nohighlight">
\[
z_1 = a_1 + b_1 z_2 + \epsilon_1
\]</div>
<p>和</p>
<div class="math notranslate nohighlight">
\[
z_2 = a_2 + b_2 z_1 + \epsilon_2
\]</div>
<p>其中我们有总体最小二乘正交条件</p>
<div class="math notranslate nohighlight">
\[
E \epsilon_1 z_2 = 0
\]</div>
<p>和</p>
<div class="math notranslate nohighlight">
\[
E \epsilon_2 z_1 = 0
\]</div>
<p>让我们计算<span class="math notranslate nohighlight">\(a_1, a_2, b_1, b_2\)</span>。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">beta</span> <span class="o">=</span> <span class="n">multi_normal</span><span class="o">.</span><span class="n">βs</span>

<span class="n">a1</span> <span class="o">=</span> <span class="n">μ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">beta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">μ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">b1</span> <span class="o">=</span> <span class="n">beta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="n">a2</span> <span class="o">=</span> <span class="n">μ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">μ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">b2</span> <span class="o">=</span> <span class="n">beta</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>让我们打印出截距和斜率。</p>
<p>对于 <span class="math notranslate nohighlight">\(z_1\)</span> 对 <span class="math notranslate nohighlight">\(z_2\)</span> 的回归，我们有</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;a1 = &quot;</span><span class="p">,</span> <span class="n">a1</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;b1 = &quot;</span><span class="p">,</span> <span class="n">b1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>a1 =  [[0.]]
b1 =  [[0.5]]
</pre></div>
</div>
</div>
</div>
<p>对于 <span class="math notranslate nohighlight">\(z_2\)</span> 对 <span class="math notranslate nohighlight">\(z_1\)</span> 的回归，我们有</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;a2 = &quot;</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>
<span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;b2 = &quot;</span><span class="p">,</span> <span class="n">b2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>a2 =  [[0.75]]
b2 =  [[0.5]]
</pre></div>
</div>
</div>
</div>
<p>现在让我们绘制这两条回归线并仔细观察。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">z2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>


<span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
<span class="n">b1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span>

<span class="n">a2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
<span class="n">b2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">b2</span><span class="p">)</span>

<span class="n">z1</span>  <span class="o">=</span> <span class="n">b1</span><span class="o">*</span><span class="n">z2</span> <span class="o">+</span> <span class="n">a1</span>


<span class="n">z1h</span> <span class="o">=</span> <span class="n">z2</span><span class="o">/</span><span class="n">b2</span> <span class="o">-</span> <span class="n">a2</span><span class="o">/</span><span class="n">b2</span>


<span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">12</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">xlim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">ylim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_position</span><span class="p">(</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_position</span><span class="p">(</span><span class="s1">&#39;zero&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;$z_1$&#39;</span><span class="p">,</span> <span class="n">loc</span> <span class="o">=</span> <span class="s1">&#39;top&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;$z_2$,&#39;</span><span class="p">,</span> <span class="n">loc</span> <span class="o">=</span> <span class="s1">&#39;right&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;两条回归线&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">z2</span><span class="p">,</span><span class="n">z1</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;$z_1$ 对 $z_2$ 的回归&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">z2</span><span class="p">,</span><span class="n">z1h</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;$z_2$ 对 $z_1$ 的回归&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/e80a3c95614c87c11a82060102c827f519dad25c7f3869488c47e0cf36ed9ede.png" src="_images/e80a3c95614c87c11a82060102c827f519dad25c7f3869488c47e0cf36ed9ede.png" />
</div>
</div>
<p>红线是在给定 <span class="math notranslate nohighlight">\(z_2\)</span> 条件下 <span class="math notranslate nohighlight">\(z_1\)</span> 的期望值。</p>
<p>红线的截距和斜率是</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;a1 = &quot;</span><span class="p">,</span> <span class="n">a1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;b1 = &quot;</span><span class="p">,</span> <span class="n">b1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>a1 =  0.0
b1 =  0.5
</pre></div>
</div>
</div>
</div>
<p>蓝线是在给定 <span class="math notranslate nohighlight">\(z_1\)</span> 条件下 <span class="math notranslate nohighlight">\(z_2\)</span> 的期望值。</p>
<p>蓝线的截距和斜率是</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-a2/b2 = &quot;</span><span class="p">,</span> <span class="o">-</span> <span class="n">a2</span><span class="o">/</span><span class="n">b2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;1/b2 = &quot;</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">b2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>-a2/b2 =  -1.5
1/b2 =  2.0
</pre></div>
</div>
</div>
</div>
<p>我们可以使用这些回归线或我们的代码来计算条件期望。</p>
<p>让我们计算在给定<span class="math notranslate nohighlight">\(z_1=5\)</span>条件下<span class="math notranslate nohighlight">\(z_2\)</span>分布的均值和方差。</p>
<p>之后我们将对调回归中左右两边的变量。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># compute the cond. dist. of z1</span>
<span class="n">ind</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">z1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">5.</span><span class="p">])</span> <span class="c1"># given z1</span>

<span class="n">μ2_hat</span><span class="p">,</span> <span class="n">Σ2_hat</span> <span class="o">=</span> <span class="n">multi_normal</span><span class="o">.</span><span class="n">cond_dist</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">z1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;μ2_hat, Σ2_hat = &#39;</span><span class="p">,</span> <span class="n">μ2_hat</span><span class="p">,</span> <span class="n">Σ2_hat</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>μ2_hat, Σ2_hat =  [3.25] [[0.75]]
</pre></div>
</div>
</div>
</div>
<p>现在让我们计算在 <span class="math notranslate nohighlight">\(z_2=5\)</span> 的条件下 <span class="math notranslate nohighlight">\(z_1\)</span> 的分布的均值和方差。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 计算 z1 的条件分布</span>
<span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">z2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">5.</span><span class="p">])</span> <span class="c1"># 给定 z2</span>

<span class="n">μ1_hat</span><span class="p">,</span> <span class="n">Σ1_hat</span> <span class="o">=</span> <span class="n">multi_normal</span><span class="o">.</span><span class="n">cond_dist</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">z2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;μ1_hat, Σ1_hat = &#39;</span><span class="p">,</span> <span class="n">μ1_hat</span><span class="p">,</span> <span class="n">Σ1_hat</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>μ1_hat, Σ1_hat =  [2.5] [[0.75]]
</pre></div>
</div>
</div>
</div>
<p>让我们比较前面的总体均值和方差与从大样本抽取并对<span class="math notranslate nohighlight">\(z_1 - \mu_1\)</span>和<span class="math notranslate nohighlight">\(z_2 - \mu_2\)</span>进行回归的结果。</p>
<p>我们知道</p>
<div class="math notranslate nohighlight">
\[
E z_1 | z_2 = \left(\mu_1 - \beta \mu_2 \right) + \beta z_2
\]</div>
<p>这可以重新整理为</p>
<div class="math notranslate nohighlight">
\[
z_1 - \mu_1 = \beta \left( z_2 - \mu_2 \right) + \epsilon,
\]</div>
<p>我们预计，随着样本量越来越大，估计的OLS系数将收敛到<span class="math notranslate nohighlight">\(\beta\)</span>，<span class="math notranslate nohighlight">\(\epsilon\)</span>的估计方差将收敛到<span class="math notranslate nohighlight">\(\hat{\Sigma}_1\)</span>。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="mi">1_000_000</span> <span class="c1"># 样本量</span>

<span class="c1"># 模拟多元正态随机向量</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">μ</span><span class="p">,</span> <span class="n">Σ</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
<span class="n">z1_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">z2_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

<span class="c1"># OLS回归</span>
<span class="n">μ1</span><span class="p">,</span> <span class="n">μ2</span> <span class="o">=</span> <span class="n">multi_normal</span><span class="o">.</span><span class="n">μs</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">OLS</span><span class="p">(</span><span class="n">z1_data</span> <span class="o">-</span> <span class="n">μ1</span><span class="p">,</span> <span class="n">z2_data</span> <span class="o">-</span> <span class="n">μ2</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>让我们比较前面的总体 <span class="math notranslate nohighlight">\(\beta\)</span> 与 <span class="math notranslate nohighlight">\(z_2 - \mu_2\)</span> 的 OLS 样本估计值</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">multi_normal</span><span class="o">.</span><span class="n">βs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">results</span><span class="o">.</span><span class="n">params</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(array([[0.5]]), array([0.49898302]))
</pre></div>
</div>
</div>
</div>
<p>让我们将我们的总体 <span class="math notranslate nohighlight">\(\hat{\Sigma}_1\)</span> 与 <span class="math notranslate nohighlight">\(\epsilon\)</span> 的自由度调整后的方差估计进行比较</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Σ1_hat</span><span class="p">,</span> <span class="n">results</span><span class="o">.</span><span class="n">resid</span> <span class="o">@</span> <span class="n">results</span><span class="o">.</span><span class="n">resid</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(array([[0.75]]), 0.7491102087368485)
</pre></div>
</div>
</div>
</div>
<p>最后，让我们计算<span class="math notranslate nohighlight">\(\hat{E z_1 | z_2}\)</span>的估计值并将其与<span class="math notranslate nohighlight">\(\hat{\mu}_1\)</span>进行比较</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">μ1_hat</span><span class="p">,</span> <span class="n">results</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">z2</span> <span class="o">-</span> <span class="n">μ2</span><span class="p">)</span> <span class="o">+</span> <span class="n">μ1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(array([2.5]), array([2.4959321]))
</pre></div>
</div>
</div>
</div>
<p>因此，在每种情况下，对于我们的大样本量，样本类比都与其总体对应值非常接近。</p>
<p>大数定律解释了为什么样本类比会接近总体对象。</p>
</section>
<section id="id6">
<h2><a class="toc-backref" href="#id26"><span class="section-number">12.4. </span>三变量示例</a><a class="headerlink" href="#id6" title="Permalink to this heading">#</a></h2>
<p>让我们将代码应用到一个三变量示例中。</p>
<p>我们将按如下方式指定均值向量和协方差矩阵。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">μ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">Σ</span> <span class="o">=</span> <span class="n">C</span> <span class="o">@</span> <span class="n">C</span><span class="o">.</span><span class="n">T</span> <span class="c1"># positive semi-definite</span>

<span class="n">multi_normal</span> <span class="o">=</span> <span class="n">MultivariateNormal</span><span class="p">(</span><span class="n">μ</span><span class="p">,</span> <span class="n">Σ</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">μ</span><span class="p">,</span> <span class="n">Σ</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(array([0.23712981, 0.91400481, 0.84232708]),
 array([[0.81828728, 0.53745426, 0.68115546],
        [0.53745426, 1.1413295 , 0.66991637],
        [0.68115546, 0.66991637, 0.6400623 ]]))
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">multi_normal</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>让我们计算在给定 <span class="math notranslate nohighlight">\(z_{2}=\left[\begin{array}{c} 2\\ 5 \end{array}\right]\)</span> 条件下 <span class="math notranslate nohighlight">\(z_1\)</span> 的分布。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">z2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">5.</span><span class="p">])</span>

<span class="n">μ1_hat</span><span class="p">,</span> <span class="n">Σ1_hat</span> <span class="o">=</span> <span class="n">multi_normal</span><span class="o">.</span><span class="n">cond_dist</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">z2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="mi">1_000_000</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">μ</span><span class="p">,</span> <span class="n">Σ</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
<span class="n">z1_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span>
<span class="n">z2_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="n">k</span><span class="p">:]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">μ1</span><span class="p">,</span> <span class="n">μ2</span> <span class="o">=</span> <span class="n">multi_normal</span><span class="o">.</span><span class="n">μs</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">sm</span><span class="o">.</span><span class="n">OLS</span><span class="p">(</span><span class="n">z1_data</span> <span class="o">-</span> <span class="n">μ1</span><span class="p">,</span> <span class="n">z2_data</span> <span class="o">-</span> <span class="n">μ2</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>如上所述，我们依次比较总体和样本回归系数、条件协方差矩阵和条件均值向量。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">multi_normal</span><span class="o">.</span><span class="n">βs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">results</span><span class="o">.</span><span class="n">params</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(array([[-0.39864898,  1.48144476]]), array([-0.39857892,  1.481409  ]))
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Σ1_hat</span><span class="p">,</span> <span class="n">results</span><span class="o">.</span><span class="n">resid</span> <span class="o">@</span> <span class="n">results</span><span class="o">.</span><span class="n">resid</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(array([[0.02344868]]), 0.023399998755823166)
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">μ1_hat</span><span class="p">,</span> <span class="n">results</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">z2</span> <span class="o">-</span> <span class="n">μ2</span><span class="p">)</span> <span class="o">+</span> <span class="n">μ1</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(array([5.9635617]), array([5.96348908]))
</pre></div>
</div>
</div>
</div>
<p>再一次，样本类比很好地近似了它们的总体对应值。</p>
</section>
<section id="iq">
<h2><a class="toc-backref" href="#id27"><span class="section-number">12.5. </span>一维智力（IQ）</a><a class="headerlink" href="#iq" title="Permalink to this heading">#</a></h2>
<p>让我们来看一个更接近现实生活的例子，即从一系列测试分数中推断出一个称为IQ的一维智力测量值。</p>
<p>第<span class="math notranslate nohighlight">\(i\)</span>个测试分数<span class="math notranslate nohighlight">\(y_i\)</span>等于未知标量IQ <span class="math notranslate nohighlight">\(\theta\)</span>和随机变量<span class="math notranslate nohighlight">\(w_{i}\)</span>的和。</p>
<div class="math notranslate nohighlight">
\[
y_{i} = \theta + \sigma_y w_i, \quad i=1,\dots, n
\]</div>
<p>对于一群人的IQ分布是一个正态随机变量，描述如下：</p>
<div class="math notranslate nohighlight">
\[
\theta = \mu_{\theta} + \sigma_{\theta} w_{n+1}.
\]</div>
<p>我们假设测试分数中的噪声<span class="math notranslate nohighlight">\(\{w_i\}_{i=1}^N\)</span>是独立同分布的，且与IQ不相关。</p>
<p>我们还假设<span class="math notranslate nohighlight">\(\{w_i\}_{i=1}^{n+1}\)</span>是独立同分布的标准正态分布：</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\boldsymbol{w}=
\left[\begin{array}{c}
w_{1}\\
w_{2}\\
\vdots\\
w_{n}\\
w_{n+1}
\end{array}\right]\sim N\left(0,I_{n+1}\right)
\end{split}\]</div>
<p>以下系统描述了我们感兴趣的<span class="math notranslate nohighlight">\((n+1) \times 1\)</span>随机向量<span class="math notranslate nohighlight">\(X\)</span>：</p>
<div class="math notranslate nohighlight">
\[\begin{split}X=\left[\begin{array}{c}
y_{1}\\
y_{2}\\
\vdots\\
y_{n}\\
\theta
\end{array}\right]=\left[\begin{array}{c}
\mu_{\theta}\\
\mu_{\theta}\\
\vdots\\
\mu_{\theta}\\
\mu_{\theta}
\end{array}\right]+\left[\begin{array}{ccccc}
\sigma_{y} &amp; 0 &amp; \cdots &amp; 0 &amp; \sigma_{\theta}\\
0 &amp; \sigma_{y} &amp; \cdots &amp; 0 &amp; \sigma_{\theta}\\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots\\
0 &amp; 0 &amp; \cdots &amp; \sigma_{y} &amp; \sigma_{\theta}\\
0 &amp; 0 &amp; \cdots &amp; 0 &amp; \sigma_{\theta}
\end{array}\right]\left[\begin{array}{c}
w_{1}\\
w_{2}\\
\vdots\\
w_{n}\\
w_{n+1}
\end{array}\right],
\end{split}\]</div>
<p>或等价地，</p>
<div class="math notranslate nohighlight">
\[
X=\mu_{\theta}\boldsymbol{1}_{n+1}+D\boldsymbol{w}
\]</div>
<p>其中 <span class="math notranslate nohighlight">\(X = \begin{bmatrix} y \cr \theta \end{bmatrix}\)</span>，
<span class="math notranslate nohighlight">\(\boldsymbol{1}_{n+1}\)</span> 是一个大小为 <span class="math notranslate nohighlight">\(n+1\)</span> 的全1向量，
而 <span class="math notranslate nohighlight">\(D\)</span> 是一个 <span class="math notranslate nohighlight">\(n+1\)</span> 乘 <span class="math notranslate nohighlight">\(n+1\)</span> 的矩阵。</p>
<p>让我们定义一个Python函数来构造我们已知遵循多元正态分布的随机向量 <span class="math notranslate nohighlight">\(X\)</span> 的均值 <span class="math notranslate nohighlight">\(\mu\)</span> 和协方差矩阵 <span class="math notranslate nohighlight">\(\Sigma\)</span>。</p>
<p>作为参数，该函数接收测试次数 <span class="math notranslate nohighlight">\(n\)</span>、IQ分布的均值 <span class="math notranslate nohighlight">\(\mu_{\theta}\)</span> 和标准差 <span class="math notranslate nohighlight">\(\sigma_\theta\)</span>，以及测试分数中随机性的标准差 <span class="math notranslate nohighlight">\(\sigma_{y}\)</span>。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">construct_moments_IQ</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">μθ</span><span class="p">,</span> <span class="n">σθ</span><span class="p">,</span> <span class="n">σy</span><span class="p">):</span>

    <span class="n">μ_IQ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">μθ</span><span class="p">)</span>

    <span class="n">D_IQ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">D_IQ</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="o">=</span> <span class="n">σy</span>
    <span class="n">D_IQ</span><span class="p">[:,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">σθ</span>

    <span class="n">Σ_IQ</span> <span class="o">=</span> <span class="n">D_IQ</span> <span class="o">@</span> <span class="n">D_IQ</span><span class="o">.</span><span class="n">T</span>

    <span class="k">return</span> <span class="n">μ_IQ</span><span class="p">,</span> <span class="n">Σ_IQ</span><span class="p">,</span> <span class="n">D_IQ</span>
</pre></div>
</div>
</div>
</div>
<p>现在让我们考虑这个模型的一个具体实例。</p>
<p>假设我们记录了<span class="math notranslate nohighlight">\(50\)</span>个测试分数，并且我们知道
<span class="math notranslate nohighlight">\(\mu_{\theta}=100\)</span>，<span class="math notranslate nohighlight">\(\sigma_{\theta}=10\)</span>，以及
<span class="math notranslate nohighlight">\(\sigma_{y}=10\)</span>。</p>
<p>我们可以使用<code class="docutils literal notranslate"><span class="pre">construct_moments_IQ</span></code>函数轻松计算<span class="math notranslate nohighlight">\(X\)</span>的均值向量和协方差矩阵，如下所示。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">μθ</span><span class="p">,</span> <span class="n">σθ</span><span class="p">,</span> <span class="n">σy</span> <span class="o">=</span> <span class="mf">100.</span><span class="p">,</span> <span class="mf">10.</span><span class="p">,</span> <span class="mf">10.</span>

<span class="n">μ_IQ</span><span class="p">,</span> <span class="n">Σ_IQ</span><span class="p">,</span> <span class="n">D_IQ</span> <span class="o">=</span> <span class="n">construct_moments_IQ</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">μθ</span><span class="p">,</span> <span class="n">σθ</span><span class="p">,</span> <span class="n">σy</span><span class="p">)</span>
<span class="n">μ_IQ</span><span class="p">,</span> <span class="n">Σ_IQ</span><span class="p">,</span> <span class="n">D_IQ</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(array([100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100.,
        100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100.,
        100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100.,
        100., 100., 100., 100., 100., 100., 100., 100., 100., 100., 100.,
        100., 100., 100., 100., 100., 100., 100.]),
 array([[200., 100., 100., ..., 100., 100., 100.],
        [100., 200., 100., ..., 100., 100., 100.],
        [100., 100., 200., ..., 100., 100., 100.],
        ...,
        [100., 100., 100., ..., 200., 100., 100.],
        [100., 100., 100., ..., 100., 200., 100.],
        [100., 100., 100., ..., 100., 100., 100.]]),
 array([[10.,  0.,  0., ...,  0.,  0., 10.],
        [ 0., 10.,  0., ...,  0.,  0., 10.],
        [ 0.,  0., 10., ...,  0.,  0., 10.],
        ...,
        [ 0.,  0.,  0., ..., 10.,  0., 10.],
        [ 0.,  0.,  0., ...,  0., 10., 10.],
        [ 0.,  0.,  0., ...,  0.,  0., 10.]]))
</pre></div>
</div>
</div>
</div>
<p>我们现在可以使用我们的<code class="docutils literal notranslate"><span class="pre">MultivariateNormal</span></code>类来构建一个实例，然后按照我们的需要对均值向量和协方差矩阵进行分割。</p>
<p>我们想要对IQ（即随机变量<span class="math notranslate nohighlight">\(\theta\)</span>，<em>我们不知道的</em>）基于测试分数向量<span class="math notranslate nohighlight">\(y\)</span>（<em>我们知道的</em>）进行回归。</p>
<p>我们选择<code class="docutils literal notranslate"><span class="pre">k=n</span></code>，这样<span class="math notranslate nohighlight">\(z_{1} = y\)</span>且<span class="math notranslate nohighlight">\(z_{2} = \theta\)</span>。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">multi_normal_IQ</span> <span class="o">=</span> <span class="n">MultivariateNormal</span><span class="p">(</span><span class="n">μ_IQ</span><span class="p">,</span> <span class="n">Σ_IQ</span><span class="p">)</span>

<span class="n">k</span> <span class="o">=</span> <span class="n">n</span>
<span class="n">multi_normal_IQ</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>使用生成器 <code class="docutils literal notranslate"><span class="pre">multivariate_normal</span></code>，我们可以从我们的分布中抽取一次随机向量，然后计算在给定测试分数条件下 <span class="math notranslate nohighlight">\(\theta\)</span> 的分布。</p>
<p>让我们来做这个，然后打印出一些相关的数值。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">μ_IQ</span><span class="p">,</span> <span class="n">Σ_IQ</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># 测试分数</span>
<span class="n">θ</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># 智商</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 真实值</span>
<span class="n">θ</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>104.6551625652423
</pre></div>
</div>
</div>
</div>
<p>方法 <code class="docutils literal notranslate"><span class="pre">cond_dist</span></code> 接收测试分数 <span class="math notranslate nohighlight">\(y\)</span> 作为输入，并返回智商 <span class="math notranslate nohighlight">\(\theta\)</span> 的条件正态分布。</p>
<p>在下面的代码中，<code class="docutils literal notranslate"><span class="pre">ind</span></code> 设置回归右侧的变量。</p>
<p>根据我们定义向量 <span class="math notranslate nohighlight">\(X\)</span> 的方式，我们需要设置 <code class="docutils literal notranslate"><span class="pre">ind=1</span></code> 以使 <span class="math notranslate nohighlight">\(\theta\)</span> 成为总体回归中的左侧变量。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ind</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">multi_normal_IQ</span><span class="o">.</span><span class="n">cond_dist</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(array([106.71131605]), array([[1.96078431]]))
</pre></div>
</div>
</div>
</div>
<p>第一个数字是条件均值 <span class="math notranslate nohighlight">\(\hat{\mu}_{\theta}\)</span>，第二个是条件方差 <span class="math notranslate nohighlight">\(\hat{\Sigma}_{\theta}\)</span>。</p>
<p>额外的测试分数如何影响我们的推断？</p>
<p>为了阐明这一点，我们通过将条件集中的测试分数数量从 <span class="math notranslate nohighlight">\(1\)</span> 变化到 <span class="math notranslate nohighlight">\(n\)</span>，计算一系列 <span class="math notranslate nohighlight">\(\theta\)</span> 的条件分布。</p>
<p>我们将制作一个漂亮的图表，展示随着更多测试结果的出现，我们对这个人的智商判断是如何变化的。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 存放矩的数组</span>
<span class="n">μθ_hat_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="n">Σθ_hat_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

<span class="c1"># 循环测试分数的数量</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># 构建多元正态分布实例</span>
    <span class="n">μ_IQ_i</span><span class="p">,</span> <span class="n">Σ_IQ_i</span><span class="p">,</span> <span class="n">D_IQ_i</span> <span class="o">=</span> <span class="n">construct_moments_IQ</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">μθ</span><span class="p">,</span> <span class="n">σθ</span><span class="p">,</span> <span class="n">σy</span><span class="p">)</span>
    <span class="n">multi_normal_IQ_i</span> <span class="o">=</span> <span class="n">MultivariateNormal</span><span class="p">(</span><span class="n">μ_IQ_i</span><span class="p">,</span> <span class="n">Σ_IQ_i</span><span class="p">)</span>

    <span class="c1"># 分割并计算条件分布</span>
    <span class="n">multi_normal_IQ_i</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">scores_i</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>
    <span class="n">μθ_hat_i</span><span class="p">,</span> <span class="n">Σθ_hat_i</span> <span class="o">=</span> <span class="n">multi_normal_IQ_i</span><span class="o">.</span><span class="n">cond_dist</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">scores_i</span><span class="p">)</span>

    <span class="c1"># 存储结果</span>
    <span class="n">μθ_hat_arr</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">μθ_hat_i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Σθ_hat_arr</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Σθ_hat_i</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

<span class="c1"># 将方差转换为标准差</span>
<span class="n">σθ_hat_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Σθ_hat_arr</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">μθ_hat_lower</span> <span class="o">=</span> <span class="n">μθ_hat_arr</span> <span class="o">-</span> <span class="mf">1.96</span> <span class="o">*</span> <span class="n">σθ_hat_arr</span>
<span class="n">μθ_hat_higher</span> <span class="o">=</span> <span class="n">μθ_hat_arr</span> <span class="o">+</span> <span class="mf">1.96</span> <span class="o">*</span> <span class="n">σθ_hat_arr</span>

<span class="n">plt</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="n">θ</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;真实 $θ$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">μθ_hat_arr</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$\hat</span><span class="si">{μ}</span><span class="s1">_</span><span class="si">{θ}</span><span class="s1">$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">μθ_hat_lower</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">μθ_hat_higher</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">μθ_hat_lower</span><span class="p">,</span> <span class="n">μθ_hat_higher</span><span class="p">,</span>
                 <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;95%&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;测试分数数量&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;$\hat</span><span class="si">{θ}</span><span class="s1">$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;&gt;:12: SyntaxWarning: invalid escape sequence &#39;\h&#39;
&lt;&gt;:12: SyntaxWarning: invalid escape sequence &#39;\h&#39;
/tmp/ipykernel_7482/815258190.py:12: SyntaxWarning: invalid escape sequence &#39;\h&#39;
  plt.ylabel(&#39;$\hat{θ}$&#39;)
</pre></div>
</div>
<img alt="_images/1a18871412a5619cd1f445c04d49095360252d5f1dbd2b84a9b13fe09e0dc31c.png" src="_images/1a18871412a5619cd1f445c04d49095360252d5f1dbd2b84a9b13fe09e0dc31c.png" />
</div>
</div>
<p>上图中的蓝色实线显示了<span class="math notranslate nohighlight">\(\hat{\mu}_{\theta}\)</span>作为我们已记录和条件化的测试分数数量的函数。</p>
<p>蓝色区域显示了从<span class="math notranslate nohighlight">\(\hat{\mu}_{\theta}\)</span>加上或减去<span class="math notranslate nohighlight">\(1.96 \hat{\sigma}_{\theta}\)</span>所得到的范围。</p>
<p>因此，条件分布的95%概率质量落在这个范围内。</p>
<p>黑色虚线显示了我们抽取的随机<span class="math notranslate nohighlight">\(\theta\)</span>的值。</p>
<p>随着越来越多的测试分数出现，我们对这个人的<span class="math notranslate nohighlight">\(\theta\)</span>的估计变得越来越可靠。</p>
<p>通过观察条件分布的变化，我们可以看到添加更多的测试分数使<span class="math notranslate nohighlight">\(\hat{\theta}\)</span>逐渐稳定并接近<span class="math notranslate nohighlight">\(\theta\)</span>。</p>
<p>因此，每个<span class="math notranslate nohighlight">\(y_{i}\)</span>都提供了关于<span class="math notranslate nohighlight">\(\theta\)</span>的信息。</p>
<p>如果我们让测试次数<span class="math notranslate nohighlight">\(n \rightarrow + \infty\)</span>，条件标准差<span class="math notranslate nohighlight">\(\hat{\sigma}_{\theta}\)</span>将以<span class="math notranslate nohighlight">\(\frac{1}{n^{.5}}\)</span>的速率收敛到<span class="math notranslate nohighlight">\(0\)</span>。</p>
</section>
<section id="id7">
<h2><a class="toc-backref" href="#id28"><span class="section-number">12.6. </span>信息即惊奇</a><a class="headerlink" href="#id7" title="Permalink to this heading">#</a></h2>
<p>让我们通过使用不同的表示方法，从另一个角度来看这个问题。</p>
<p>我们可以将上述随机向量<span class="math notranslate nohighlight">\(X\)</span>表示为</p>
<div class="math notranslate nohighlight">
\[
X = \mu_{\theta} \boldsymbol{1}_{n+1} + C \epsilon, \quad \epsilon \sim N\left(0, I\right)
\]</div>
<p>其中<span class="math notranslate nohighlight">\(C\)</span>是<span class="math notranslate nohighlight">\(\Sigma\)</span>的下三角<strong>Cholesky因子</strong>，使得</p>
<div class="math notranslate nohighlight">
\[
\Sigma \equiv DD^{\prime} = C C^\prime
\]</div>
<p>且</p>
<div class="math notranslate nohighlight">
\[
E \epsilon \epsilon' = I .
\]</div>
<p>因此可得</p>
<div class="math notranslate nohighlight">
\[
\epsilon \sim N(0, I) .
\]</div>
<p>令<span class="math notranslate nohighlight">\(G=C^{-1}\)</span></p>
<p><span class="math notranslate nohighlight">\(G\)</span>也是下三角矩阵。</p>
<p>我们可以通过以下公式计算<span class="math notranslate nohighlight">\(\epsilon\)</span></p>
<div class="math notranslate nohighlight">
\[
\epsilon = G \left( X - \mu_{\theta} \boldsymbol{1}_{n+1} \right)
\]</div>
<p>这个公式证实了正交向量<span class="math notranslate nohighlight">\(\epsilon\)</span>包含了与非正交向量<span class="math notranslate nohighlight">\(\left( X - \mu_{\theta} \boldsymbol{1}_{n+1} \right)\)</span>相同的信息。</p>
<p>我们可以说<span class="math notranslate nohighlight">\(\epsilon\)</span>是<span class="math notranslate nohighlight">\(\left( X - \mu_{\theta} \boldsymbol{1}_{n+1} \right)\)</span>的一个正交基。</p>
<p>令<span class="math notranslate nohighlight">\(c_{i}\)</span>为<span class="math notranslate nohighlight">\(C\)</span>最后一行的第<span class="math notranslate nohighlight">\(i\)</span>个元素。</p>
<p>那么我们可以写作</p>
<div class="math notranslate nohighlight" id="equation-mnv-1">
<span class="eqno">(12.1)<a class="headerlink" href="#equation-mnv-1" title="Permalink to this equation">#</a></span>\[\theta = \mu_{\theta} + c_1 \epsilon_1 + c_2 \epsilon_2 + \dots + c_n \epsilon_n + c_{n+1} \epsilon_{n+1}\]</div>
<p><span class="math notranslate nohighlight">\(\epsilon_i\)</span> 之间的相互正交性为我们提供了一种有启发性的方式来解释方程 <a class="reference internal" href="#equation-mnv-1">(12.1)</a>。</p>
<p>因此，相对于从测试 <span class="math notranslate nohighlight">\(i=1, \ldots, n-1\)</span> 已知的信息而言，<span class="math notranslate nohighlight">\(c_i \epsilon_i\)</span> 是测试编号 <span class="math notranslate nohighlight">\(i\)</span> 带来的关于 <span class="math notranslate nohighlight">\(\theta\)</span> 的<strong>新信息</strong>量。</p>
<p>这里的<strong>新信息</strong>意味着<strong>惊喜</strong>或无法从先前信息预测的内容。</p>
<p>公式 <a class="reference internal" href="#equation-mnv-1">(12.1)</a> 还为我们提供了一种富有启发性的方式来表达我们之前计算的条件均值和条件方差。</p>
<p>具体来说，</p>
<div class="math notranslate nohighlight">
\[
E\left[\theta \mid y_1, \dots, y_k\right] = \mu_{\theta} + c_1 \epsilon_1 + \dots + c_k \epsilon_k
\]</div>
<p>和</p>
<div class="math notranslate nohighlight">
\[
Var\left(\theta \mid y_1, \dots, y_k\right) = c^2_{k+1} + c^2_{k+2} + \dots + c^2_{n+1}.
\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">Σ_IQ</span><span class="p">)</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>

<span class="n">ε</span> <span class="o">=</span> <span class="n">G</span> <span class="o">@</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">μθ</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cε</span> <span class="o">=</span> <span class="n">C</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">ε</span>

<span class="c1"># 计算基于 y1, y2, ..., yk 的条件μθ和Σθ序列</span>
<span class="n">μθ_hat_arr_C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cε</span><span class="p">[:</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span> <span class="o">+</span> <span class="n">μθ</span>
<span class="n">Σθ_hat_arr_C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
</pre></div>
</div>
</div>
</div>
<p>为了确认这些公式给出的答案与我们之前计算的结果相同，我们可以将基于<span class="math notranslate nohighlight">\(\{y_i\}_{i=1}^k\)</span>条件下的<span class="math notranslate nohighlight">\(\theta\)</span>的均值和方差，与我们之前使用<code class="docutils literal notranslate"><span class="pre">MultivariateNormal</span></code>类（基于我们对多元正态分布条件分布的原始表示）实现的公式所得到的结果进行比较。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 条件均值</span>
<span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">μθ_hat_arr</span> <span class="o">-</span> <span class="n">μθ_hat_arr_C</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1e-10</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 条件方差</span>
<span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Σθ_hat_arr</span> <span class="o">-</span> <span class="n">Σθ_hat_arr_C</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1e-10</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
</section>
<section id="cholesky">
<h2><a class="toc-backref" href="#id29"><span class="section-number">12.7. </span>Cholesky因子魔法</a><a class="headerlink" href="#cholesky" title="Permalink to this heading">#</a></h2>
<p>显然，Cholesky分解自动计算了我们的<code class="docutils literal notranslate"><span class="pre">MultivariateNormal</span></code>类所产生的总体<strong>回归系数</strong>和相关统计数据。</p>
<p>Cholesky分解<strong>递归地</strong>计算这些内容。</p>
<p>实际上，在公式<a class="reference internal" href="#equation-mnv-1">(12.1)</a>中，</p>
<ul class="simple">
<li><p>随机变量<span class="math notranslate nohighlight">\(c_i \epsilon_i\)</span>包含了关于<span class="math notranslate nohighlight">\(\theta\)</span>的信息，这些信息不包含在<span class="math notranslate nohighlight">\(\epsilon_1, \epsilon_2, \ldots, \epsilon_{i-1}\)</span>的信息中</p></li>
<li><p>系数<span class="math notranslate nohighlight">\(c_i\)</span>是<span class="math notranslate nohighlight">\(\theta - \mu_\theta\)</span>对<span class="math notranslate nohighlight">\(\epsilon_i\)</span>的简单总体回归系数</p></li>
</ul>
</section>
<section id="id8">
<h2><a class="toc-backref" href="#id30"><span class="section-number">12.8. </span>数学和语言智力</a><a class="headerlink" href="#id8" title="Permalink to this heading">#</a></h2>
<p>我们可以修改前面的例子使其更加贴近现实。</p>
<p>有大量证据表明智商不是一个标量。</p>
<p>有些人数学能力强但语言能力差。</p>
<p>其他人语言能力强但数学能力差。</p>
<p>因此现在我们假设智商有两个维度，<span class="math notranslate nohighlight">\(\theta\)</span>和<span class="math notranslate nohighlight">\(\eta\)</span>。</p>
<p>这些分别决定了数学和语言测试的平均表现。</p>
<p>我们观察到数学分数 <span class="math notranslate nohighlight">\(\{y_i\}_{i=1}^{n}\)</span> 和语言分数
<span class="math notranslate nohighlight">\(\{y_i\}_{i=n+1}^{2n}\)</span>。</p>
<p>当 <span class="math notranslate nohighlight">\(n=2\)</span> 时，我们假设结果来自一个多元正态分布，其表示为</p>
<div class="math notranslate nohighlight">
\[\begin{split}
X=\left[\begin{array}{c}
y_{1}\\
y_{2}\\
y_{3}\\
y_{4}\\
\theta\\
\eta
\end{array}\right]=\left[\begin{array}{c}
\mu_{\theta}\\
\mu_{\theta}\\
\mu_{\eta}\\
\mu_{\eta}\\
\mu_{\theta}\\
\mu_{\eta}
\end{array}\right]+\left[\begin{array}{cccccc}
\sigma_{y} &amp; 0 &amp; 0 &amp; 0 &amp; \sigma_{\theta} &amp; 0\\
0 &amp; \sigma_{y} &amp; 0 &amp; 0 &amp; \sigma_{\theta} &amp; 0\\
0 &amp; 0 &amp; \sigma_{y} &amp; 0 &amp; 0 &amp; \sigma_{\eta}\\
0 &amp; 0 &amp; 0 &amp; \sigma_{y} &amp; 0 &amp; \sigma_{\eta}\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; \sigma_{\theta} &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; \sigma_{\eta}
\end{array}\right]\left[\begin{array}{c}
w_{1}\\
w_{2}\\
w_{3}\\
w_{4}\\
w_{5}\\
w_{6}
\end{array}\right]
\end{split}\]</div>
<p>其中
<span class="math notranslate nohighlight">\(w \begin{bmatrix} w_1 \cr w_2 \cr \vdots \cr w_6 \end{bmatrix}\)</span>
是一个标准正态随机向量。</p>
<p>我们构建一个Python函数<code class="docutils literal notranslate"><span class="pre">construct_moments_IQ2d</span></code>来构造联合正态分布的均值向量和协方差矩阵。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">construct_moments_IQ2d</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">μθ</span><span class="p">,</span> <span class="n">σθ</span><span class="p">,</span> <span class="n">μη</span><span class="p">,</span> <span class="n">ση</span><span class="p">,</span> <span class="n">σy</span><span class="p">):</span>

    <span class="n">μ_IQ2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">μ_IQ2d</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">μθ</span>
    <span class="n">μ_IQ2d</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">μθ</span>
    <span class="n">μ_IQ2d</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">μη</span>
    <span class="n">μ_IQ2d</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">μη</span>


    <span class="n">D_IQ2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
    <span class="n">D_IQ2d</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">)]</span> <span class="o">=</span> <span class="n">σy</span>
    <span class="n">D_IQ2d</span><span class="p">[:</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">σθ</span>
    <span class="n">D_IQ2d</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">σθ</span>
    <span class="n">D_IQ2d</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ση</span>
    <span class="n">D_IQ2d</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ση</span>

    <span class="n">Σ_IQ2d</span> <span class="o">=</span> <span class="n">D_IQ2d</span> <span class="o">@</span> <span class="n">D_IQ2d</span><span class="o">.</span><span class="n">T</span>

    <span class="k">return</span> <span class="n">μ_IQ2d</span><span class="p">,</span> <span class="n">Σ_IQ2d</span><span class="p">,</span> <span class="n">D_IQ2d</span>
</pre></div>
</div>
</div>
</div>
<p>让我们让函数开始工作。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">n</span> <span class="o">=</span> <span class="mi">2</span>
<span class="c1"># θ、η和y的均值和方差</span>
<span class="n">μθ</span><span class="p">,</span> <span class="n">σθ</span><span class="p">,</span> <span class="n">μη</span><span class="p">,</span> <span class="n">ση</span><span class="p">,</span> <span class="n">σy</span> <span class="o">=</span> <span class="mf">100.</span><span class="p">,</span> <span class="mf">10.</span><span class="p">,</span> <span class="mf">100.</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span>

<span class="n">μ_IQ2d</span><span class="p">,</span> <span class="n">Σ_IQ2d</span><span class="p">,</span> <span class="n">D_IQ2d</span> <span class="o">=</span> <span class="n">construct_moments_IQ2d</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">μθ</span><span class="p">,</span> <span class="n">σθ</span><span class="p">,</span> <span class="n">μη</span><span class="p">,</span> <span class="n">ση</span><span class="p">,</span> <span class="n">σy</span><span class="p">)</span>
<span class="n">μ_IQ2d</span><span class="p">,</span> <span class="n">Σ_IQ2d</span><span class="p">,</span> <span class="n">D_IQ2d</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(array([100., 100., 100., 100., 100., 100.]),
 array([[200., 100.,   0.,   0., 100.,   0.],
        [100., 200.,   0.,   0., 100.,   0.],
        [  0.,   0., 200., 100.,   0., 100.],
        [  0.,   0., 100., 200.,   0., 100.],
        [100., 100.,   0.,   0., 100.,   0.],
        [  0.,   0., 100., 100.,   0., 100.]]),
 array([[10.,  0.,  0.,  0., 10.,  0.],
        [ 0., 10.,  0.,  0., 10.,  0.],
        [ 0.,  0., 10.,  0.,  0., 10.],
        [ 0.,  0.,  0., 10.,  0., 10.],
        [ 0.,  0.,  0.,  0., 10.,  0.],
        [ 0.,  0.,  0.,  0.,  0., 10.]]))
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 进行一次抽样</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">μ_IQ2d</span><span class="p">,</span> <span class="n">Σ_IQ2d</span><span class="p">)</span>
<span class="n">y1</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span>
<span class="n">y2</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">]</span>
<span class="n">θ</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">]</span>
<span class="n">η</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># 真实值</span>
<span class="n">θ</span><span class="p">,</span> <span class="n">η</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(111.06790647488529, 79.50055336206911)
</pre></div>
</div>
</div>
</div>
<p>我们首先计算<span class="math notranslate nohighlight">\(\left(\theta, \eta\right)\)</span>的联合正态分布。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">multi_normal_IQ2d</span> <span class="o">=</span> <span class="n">MultivariateNormal</span><span class="p">(</span><span class="n">μ_IQ2d</span><span class="p">,</span> <span class="n">Σ_IQ2d</span><span class="p">)</span>

<span class="n">k</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span> <span class="c1"># 数据向量的长度</span>
<span class="n">multi_normal_IQ2d</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

<span class="n">multi_normal_IQ2d</span><span class="o">.</span><span class="n">cond_dist</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="o">*</span><span class="n">y1</span><span class="p">,</span> <span class="o">*</span><span class="n">y2</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(array([109.53870777,  80.01100487]),
 array([[33.33333333,  0.        ],
        [ 0.        , 33.33333333]]))
</pre></div>
</div>
</div>
</div>
<p>现在让我们分别计算基于各种测试分数子集条件下的 <span class="math notranslate nohighlight">\(\theta\)</span> 和 <span class="math notranslate nohighlight">\(\mu\)</span> 的分布。</p>
<p>通过构建一个辅助函数 <code class="docutils literal notranslate"><span class="pre">cond_dist_IQ2d</span></code>，我们可以有趣地比较各种结果。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">cond_dist_IQ2d</span><span class="p">(</span><span class="n">μ</span><span class="p">,</span> <span class="n">Σ</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">μ</span><span class="p">)</span>

    <span class="n">multi_normal</span> <span class="o">=</span> <span class="n">MultivariateNormal</span><span class="p">(</span><span class="n">μ</span><span class="p">,</span> <span class="n">Σ</span><span class="p">)</span>
    <span class="n">multi_normal</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">μ_hat</span><span class="p">,</span> <span class="n">Σ_hat</span> <span class="o">=</span> <span class="n">multi_normal</span><span class="o">.</span><span class="n">cond_dist</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">μ_hat</span><span class="p">,</span> <span class="n">Σ_hat</span>
</pre></div>
</div>
</div>
</div>
<p>让我们看看这个例子是如何运行的。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">indices</span><span class="p">,</span> <span class="n">IQ</span><span class="p">,</span> <span class="n">conditions</span> <span class="ow">in</span> <span class="p">[([</span><span class="o">*</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">],</span> <span class="s1">&#39;θ&#39;</span><span class="p">,</span> <span class="s1">&#39;y1, y2, y3, y4&#39;</span><span class="p">),</span>
                                <span class="p">([</span><span class="o">*</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">],</span> <span class="s1">&#39;θ&#39;</span><span class="p">,</span> <span class="s1">&#39;y1, y2&#39;</span><span class="p">),</span>
                                <span class="p">([</span><span class="o">*</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">],</span> <span class="s1">&#39;θ&#39;</span><span class="p">,</span> <span class="s1">&#39;y3, y4&#39;</span><span class="p">),</span>
                                <span class="p">([</span><span class="o">*</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;η&#39;</span><span class="p">,</span> <span class="s1">&#39;y1, y2, y3, y4&#39;</span><span class="p">),</span>
                                <span class="p">([</span><span class="o">*</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;η&#39;</span><span class="p">,</span> <span class="s1">&#39;y1, y2&#39;</span><span class="p">),</span>
                                <span class="p">([</span><span class="o">*</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;η&#39;</span><span class="p">,</span> <span class="s1">&#39;y3, y4&#39;</span><span class="p">)]:</span>

    <span class="n">μ_hat</span><span class="p">,</span> <span class="n">Σ_hat</span> <span class="o">=</span> <span class="n">cond_dist_IQ2d</span><span class="p">(</span><span class="n">μ_IQ2d</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">Σ_IQ2d</span><span class="p">[</span><span class="n">indices</span><span class="p">][:,</span> <span class="n">indices</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">indices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;在</span><span class="si">{</span><span class="n">conditions</span><span class="si">:</span><span class="s1"> &lt;15</span><span class="si">}</span><span class="s1">条件下，</span><span class="si">{</span><span class="n">IQ</span><span class="si">}</span><span class="s1">的均值和方差分别为&#39;</span> <span class="o">+</span>
          <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">μ_hat</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s1">1.2f</span><span class="si">}</span><span class="s1">和</span><span class="si">{</span><span class="n">Σ_hat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s1">1.2f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>在y1, y2, y3, y4 条件下，θ的均值和方差分别为109.54和33.33
在y1, y2         条件下，θ的均值和方差分别为109.54和33.33
在y3, y4         条件下，θ的均值和方差分别为100.00和100.00
在y1, y2, y3, y4 条件下，η的均值和方差分别为80.01和33.33
在y1, y2         条件下，η的均值和方差分别为100.00和100.00
在y3, y4         条件下，η的均值和方差分别为80.01和33.33
</pre></div>
</div>
</div>
</div>
<p>显然，数学考试不能提供关于 <span class="math notranslate nohighlight">\(\mu\)</span> 的信息，语言考试不能提供关于 <span class="math notranslate nohighlight">\(\eta\)</span> 的信息。</p>
</section>
<section id="id9">
<h2><a class="toc-backref" href="#id31"><span class="section-number">12.9. </span>单变量时间序列分析</a><a class="headerlink" href="#id9" title="Permalink to this heading">#</a></h2>
<p>我们可以使用多元正态分布和一些矩阵代数来介绍单变量线性时间序列分析的基础。</p>
<p>设 <span class="math notranslate nohighlight">\(x_t, y_t, v_t, w_{t+1}\)</span> 对于 <span class="math notranslate nohighlight">\(t \geq 0\)</span> 均为标量。</p>
<p>考虑以下模型：</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
x_0 &amp; \sim  N\left(0, \sigma_0^2\right) \\
x_{t+1} &amp; = a x_{t} + b w_{t+1}, \quad w_{t+1} \sim N\left(0, 1\right), t \geq 0  \\
y_{t} &amp; = c x_{t} + d v_{t}, \quad v_{t} \sim N\left(0, 1\right), t \geq 0
\end{aligned}
\end{split}\]</div>
<p>我们可以计算 <span class="math notranslate nohighlight">\(x_{t}\)</span> 的矩：</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(E x_{t+1}^2 = a^2 E x_{t}^2 + b^2, t \geq 0\)</span>，其中
<span class="math notranslate nohighlight">\(E x_{0}^2 = \sigma_{0}^2\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(E x_{t+j} x_{t} = a^{j} E x_{t}^2, \forall t \ \forall j\)</span></p></li>
</ol>
<p>给定某个 <span class="math notranslate nohighlight">\(T\)</span>，我们可以将序列 <span class="math notranslate nohighlight">\(\{x_{t}\}_{t=0}^T\)</span> 表示为随机向量</p>
<div class="math notranslate nohighlight">
\[\begin{split}
X=\left[\begin{array}{c}
x_{0}\\
x_{1}\\
\vdots\\
x_{T}
\end{array}\right]
\end{split}\]</div>
<p>协方差矩阵 <span class="math notranslate nohighlight">\(\Sigma_{x}\)</span> 可以用我们上面计算的矩来构建。</p>
<p>类似地，我们可以定义</p>
<div class="math notranslate nohighlight">
\[\begin{split}
Y=\left[\begin{array}{c}
y_{0}\\
y_{1}\\
\vdots\\
y_{T}
\end{array}\right], \quad
v=\left[\begin{array}{c}
v_{0}\\
v_{1}\\
\vdots\\
v_{T}
\end{array}\right]
\end{split}\]</div>
<p>因此</p>
<div class="math notranslate nohighlight">
\[
Y = C X + D V
\]</div>
<p>其中 <span class="math notranslate nohighlight">\(C\)</span> 和 <span class="math notranslate nohighlight">\(D\)</span> 都是对角矩阵，对角线上分别为常数 <span class="math notranslate nohighlight">\(c\)</span> 和 <span class="math notranslate nohighlight">\(d\)</span>。</p>
<p>因此，<span class="math notranslate nohighlight">\(Y\)</span> 的协方差矩阵为</p>
<div class="math notranslate nohighlight">
\[
\Sigma_{y} = E Y Y^{\prime} = C \Sigma_{x} C^{\prime} + D D^{\prime}
\]</div>
<p>通过将 <span class="math notranslate nohighlight">\(X\)</span> 和 <span class="math notranslate nohighlight">\(Y\)</span> 堆叠，我们可以写成</p>
<div class="math notranslate nohighlight">
\[\begin{split}
Z=\left[\begin{array}{c}
X\\
Y
\end{array}\right]
\end{split}\]</div>
<p>且</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\Sigma_{z} = EZZ^{\prime}=\left[\begin{array}{cc}
\Sigma_{x} &amp; \Sigma_{x}C^{\prime}\\
C\Sigma_{x} &amp; \Sigma_{y}
\end{array}\right]
\end{split}\]</div>
<p>因此，堆叠序列 <span class="math notranslate nohighlight">\(\{x_{t}\}_{t=0}^T\)</span> 和 <span class="math notranslate nohighlight">\(\{y_{t}\}_{t=0}^T\)</span> 共同服从多元正态分布 <span class="math notranslate nohighlight">\(N\left(0, \Sigma_{z}\right)\)</span>。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 作为示例，考虑 T = 3 的情况</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 初始分布 x_0 的方差</span>
<span class="n">σ0</span> <span class="o">=</span> <span class="mf">1.</span>

<span class="c1"># 方程系统的参数</span>
<span class="n">a</span> <span class="o">=</span> <span class="mf">.9</span>
<span class="n">b</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="n">c</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">d</span> <span class="o">=</span> <span class="mf">.05</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 构建 X 的协方差矩阵</span>
<span class="n">Σx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

<span class="n">Σx</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">σ0</span> <span class="o">**</span> <span class="mi">2</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
    <span class="n">Σx</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">Σx</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
    <span class="n">Σx</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Σx</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>

    <span class="n">Σx</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">Σx</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span> <span class="o">**</span> <span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Σx</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[1.      , 0.9     , 0.81    , 0.729   ],
       [0.9     , 1.81    , 1.629   , 1.4661  ],
       [0.81    , 1.629   , 2.4661  , 2.21949 ],
       [0.729   , 1.4661  , 2.21949 , 2.997541]])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 构建Y的协方差矩阵</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">d</span>

<span class="n">Σy</span> <span class="o">=</span> <span class="n">C</span> <span class="o">@</span> <span class="n">Σx</span> <span class="o">@</span> <span class="n">C</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">D</span> <span class="o">@</span> <span class="n">D</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 构建Z的协方差矩阵</span>
<span class="n">Σz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>

<span class="n">Σz</span><span class="p">[:</span><span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Σx</span>
<span class="n">Σz</span><span class="p">[:</span><span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">Σx</span> <span class="o">@</span> <span class="n">C</span><span class="o">.</span><span class="n">T</span>
<span class="n">Σz</span><span class="p">[</span><span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:</span><span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span> <span class="o">@</span> <span class="n">Σx</span>
<span class="n">Σz</span><span class="p">[</span><span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">:,</span> <span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">Σy</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Σz</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[1.      , 0.9     , 0.81    , 0.729   , 1.      , 0.9     ,
        0.81    , 0.729   ],
       [0.9     , 1.81    , 1.629   , 1.4661  , 0.9     , 1.81    ,
        1.629   , 1.4661  ],
       [0.81    , 1.629   , 2.4661  , 2.21949 , 0.81    , 1.629   ,
        2.4661  , 2.21949 ],
       [0.729   , 1.4661  , 2.21949 , 2.997541, 0.729   , 1.4661  ,
        2.21949 , 2.997541],
       [1.      , 0.9     , 0.81    , 0.729   , 1.0025  , 0.9     ,
        0.81    , 0.729   ],
       [0.9     , 1.81    , 1.629   , 1.4661  , 0.9     , 1.8125  ,
        1.629   , 1.4661  ],
       [0.81    , 1.629   , 2.4661  , 2.21949 , 0.81    , 1.629   ,
        2.4686  , 2.21949 ],
       [0.729   , 1.4661  , 2.21949 , 2.997541, 0.729   , 1.4661  ,
        2.21949 , 3.000041]])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 构建Z的均值向量</span>
<span class="n">μz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>以下 Python 代码让我们可以对随机向量 <span class="math notranslate nohighlight">\(X\)</span> 和 <span class="math notranslate nohighlight">\(Y\)</span> 进行采样。</p>
<p>这对于在下面有趣的练习中进行条件化处理将非常有用。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">μz</span><span class="p">,</span> <span class="n">Σz</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">z</span><span class="p">[:</span><span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
</pre></div>
</div>
</div>
</div>
<section id="id10">
<h3><span class="section-number">12.9.1. </span>平滑示例<a class="headerlink" href="#id10" title="Permalink to this heading">#</a></h3>
<p>这是一个经典的<code class="docutils literal notranslate"><span class="pre">平滑</span></code>计算示例，其目的是计算<span class="math notranslate nohighlight">\(E X \mid Y\)</span>。</p>
<p>这个示例的解释是：</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(X\)</span>是一个隐马尔可夫状态变量<span class="math notranslate nohighlight">\(x_t\)</span>的随机序列</p></li>
<li><p><span class="math notranslate nohighlight">\(Y\)</span>是一个包含隐藏状态信息的观测信号<span class="math notranslate nohighlight">\(y_t\)</span>序列</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 构建一个多元正态分布实例</span>
<span class="n">multi_normal_ex1</span> <span class="o">=</span> <span class="n">MultivariateNormal</span><span class="p">(</span><span class="n">μz</span><span class="p">,</span> <span class="n">Σz</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">z</span><span class="p">[:</span><span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 将Z分割成X和Y</span>
<span class="n">multi_normal_ex1</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 计算给定Y=y时X的条件均值和协方差矩阵</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;X = &quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Y = &quot;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot; E [ X | Y] = &quot;</span><span class="p">,</span> <span class="p">)</span>

<span class="n">multi_normal_ex1</span><span class="o">.</span><span class="n">cond_dist</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>X =  [-1.83758685 -1.13193571  0.14473619  0.29486267]
Y =  [-1.89170365 -1.14991592  0.07146159  0.32090162]
 E [ X | Y] = 
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(array([-1.88575541, -1.14880464,  0.06928384,  0.32025686]),
 array([[2.48875094e-03, 5.57449314e-06, 1.24861718e-08, 2.80234724e-11],
        [5.57449314e-06, 2.48876343e-03, 5.57452116e-06, 1.25113935e-08],
        [1.24861718e-08, 5.57452116e-06, 2.48876346e-03, 5.58575339e-06],
        [2.80233614e-11, 1.25113933e-08, 5.58575339e-06, 2.49377812e-03]]))
</pre></div>
</div>
</div>
</div>
</section>
<section id="id11">
<h3><span class="section-number">12.9.2. </span>滤波练习<a class="headerlink" href="#id11" title="Permalink to this heading">#</a></h3>
<p>计算 <span class="math notranslate nohighlight">\(E\left[x_{t} \mid y_{t-1}, y_{t-2}, \dots, y_{0}\right]\)</span>。</p>
<p>为此，我们首先需要构建子向量 <span class="math notranslate nohighlight">\(\left[x_{t}, y_{0}, \dots, y_{t-2}, y_{t-1}\right]\)</span> 的均值向量和协方差矩阵。</p>
<p>例如，假设我们想要求 <span class="math notranslate nohighlight">\(x_{3}\)</span> 的条件分布。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 子向量的均值</span>
<span class="n">sub_μz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># 子向量的协方差矩阵</span>
<span class="n">sub_Σz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

<span class="n">sub_Σz</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Σz</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="c1"># x_t</span>
<span class="n">sub_Σz</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">Σz</span><span class="p">[</span><span class="n">t</span><span class="p">,</span> <span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">T</span><span class="o">+</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="n">sub_Σz</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Σz</span><span class="p">[</span><span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">T</span><span class="o">+</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span>
<span class="n">sub_Σz</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">Σz</span><span class="p">[</span><span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">T</span><span class="o">+</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">T</span><span class="o">+</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sub_Σz</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[2.997541, 0.729   , 1.4661  , 2.21949 ],
       [0.729   , 1.0025  , 0.9     , 0.81    ],
       [1.4661  , 0.9     , 1.8125  , 1.629   ],
       [2.21949 , 0.81    , 1.629   , 2.4686  ]])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">multi_normal_ex2</span> <span class="o">=</span> <span class="n">MultivariateNormal</span><span class="p">(</span><span class="n">sub_μz</span><span class="p">,</span> <span class="n">sub_Σz</span><span class="p">)</span>
<span class="n">multi_normal_ex2</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sub_y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:</span><span class="n">t</span><span class="p">]</span>

<span class="n">multi_normal_ex2</span><span class="o">.</span><span class="n">cond_dist</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sub_y</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(array([0.06183451]), array([[1.00201996]]))
</pre></div>
</div>
</div>
</div>
</section>
<section id="id12">
<h3><span class="section-number">12.9.3. </span>预测练习<a class="headerlink" href="#id12" title="Permalink to this heading">#</a></h3>
<p>计算 <span class="math notranslate nohighlight">\(E\left[y_{t} \mid y_{t-j}, \dots, y_{0} \right]\)</span>。</p>
<p>如同我们在练习2中所做的那样，我们将构建子向量 <span class="math notranslate nohighlight">\(\left[y_{t}, y_{0}, \dots, y_{t-j-1}, y_{t-j} \right]\)</span> 的均值向量和协方差矩阵。</p>
<p>例如，我们以 <span class="math notranslate nohighlight">\(t=3\)</span> 且 <span class="math notranslate nohighlight">\(j=2\)</span> 的情况为例。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">j</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sub_μz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">t</span><span class="o">-</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
<span class="n">sub_Σz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">t</span><span class="o">-</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="o">-</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">))</span>

<span class="n">sub_Σz</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Σz</span><span class="p">[</span><span class="n">T</span><span class="o">+</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">+</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="n">sub_Σz</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">Σz</span><span class="p">[</span><span class="n">T</span><span class="o">+</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">T</span><span class="o">+</span><span class="n">t</span><span class="o">-</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
<span class="n">sub_Σz</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Σz</span><span class="p">[</span><span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">T</span><span class="o">+</span><span class="n">t</span><span class="o">-</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">T</span><span class="o">+</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="n">sub_Σz</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">Σz</span><span class="p">[</span><span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">T</span><span class="o">+</span><span class="n">t</span><span class="o">-</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">T</span><span class="o">+</span><span class="n">t</span><span class="o">-</span><span class="n">j</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sub_Σz</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[3.000041, 0.729   , 1.4661  ],
       [0.729   , 1.0025  , 0.9     ],
       [1.4661  , 0.9     , 1.8125  ]])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">multi_normal_ex3</span> <span class="o">=</span> <span class="n">MultivariateNormal</span><span class="p">(</span><span class="n">sub_μz</span><span class="p">,</span> <span class="n">sub_Σz</span><span class="p">)</span>
<span class="n">multi_normal_ex3</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sub_y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[:</span><span class="n">t</span><span class="o">-</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

<span class="n">multi_normal_ex3</span><span class="o">.</span><span class="n">cond_dist</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sub_y</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(array([-0.93253735]), array([[1.81413617]]))
</pre></div>
</div>
</div>
</div>
</section>
<section id="id13">
<h3><span class="section-number">12.9.4. </span>构建沃尔德表示<a class="headerlink" href="#id13" title="Permalink to this heading">#</a></h3>
<p>现在我们将应用科列斯基分解来分解
<span class="math notranslate nohighlight">\(\Sigma_{y}=H H^{\prime}\)</span> 并形成</p>
<div class="math notranslate nohighlight">
\[
\epsilon = H^{-1} Y.
\]</div>
<p>然后我们可以将 <span class="math notranslate nohighlight">\(y_{t}\)</span> 表示为</p>
<div class="math notranslate nohighlight">
\[
y_{t} = h_{t,t} \epsilon_{t} + h_{t,t-1} \epsilon_{t-1} + \dots + h_{t,0} \epsilon_{0}.
\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">Σy</span><span class="p">)</span>

<span class="n">H</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[1.00124922, 0.        , 0.        , 0.        ],
       [0.8988771 , 1.00225743, 0.        , 0.        ],
       [0.80898939, 0.89978675, 1.00225743, 0.        ],
       [0.72809046, 0.80980808, 0.89978676, 1.00225743]])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ε</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">H</span><span class="p">)</span> <span class="o">@</span> <span class="n">y</span>

<span class="n">ε</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([-1.88934344,  0.54713652,  1.10511947,  0.2584836 ])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">y</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([-1.89170365, -1.14991592,  0.07146159,  0.32090162])
</pre></div>
</div>
</div>
</div>
<p>这个例子是时间序列分析中所谓的<strong>Wold表示</strong>的一个实例。</p>
</section>
</section>
<section id="id14">
<h2><a class="toc-backref" href="#id32"><span class="section-number">12.10. </span>随机差分方程</a><a class="headerlink" href="#id14" title="Permalink to this heading">#</a></h2>
<p>考虑二阶线性随机差分方程</p>
<div class="math notranslate nohighlight">
\[
y_{t} = \alpha_{0} + \alpha_{1} y_{y-1} + \alpha_{2} y_{t-2} + u_{t}
\]</div>
<p>其中 <span class="math notranslate nohighlight">\(u_{t} \sim N \left(0, \sigma_{u}^{2}\right)\)</span> 且</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\left[\begin{array}{c}
y_{-1}\\
y_{0}
\end{array}\right]\sim N\left(\mu_{\tilde{y}},\Sigma_{\tilde{y}}\right)
\end{split}\]</div>
<p>它可以写成堆叠系统的形式</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\begin{split}
\underset{\equiv A}{\underbrace{\left[\begin{array}{cccccccc}
1 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 &amp; 0\\
-\alpha_{1} &amp; 1 &amp; 0 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 &amp; 0\\
-\alpha_{2} &amp; -\alpha_{1} &amp; 1 &amp; 0 &amp; \cdots &amp; 0 &amp; 0 &amp; 0\\
0 &amp; -\alpha_{2} &amp; -\alpha_{1} &amp; 1 &amp; \cdots &amp; 0 &amp; 0 &amp; 0\\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \cdots &amp; \vdots &amp; \vdots &amp; \vdots\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; \cdots &amp; -\alpha_{2} &amp; -\alpha_{1} &amp; 1
\end{array}\right]}}\left[\begin{array}{c}
y_{1}\\
y_{2}\\
y_{3}\\
y_{4}\\
\vdots\\
y_{T}\end{split}\\\begin{split}\end{array}\right]=\underset{\equiv b}{\underbrace{\left[\begin{array}{c}
\alpha_{0}+\alpha_{1}y_{0}+\alpha_{2}y_{-1}\\
\alpha_{0}+\alpha_{2}y_{0}\\
\alpha_{0}\\
\alpha_{0}\\
\vdots\\
\alpha_{0}
\end{array}\right]}} +\underset{\equiv u}{\underbrace{\left[\begin{array}{c}
u_{1} \\
u_2 \\
u_3\\
u_4\\
\vdots\\
u_T
\end{array}\right]}}
\end{split}\end{aligned}\end{align} \]</div>
<p>我们可以通过求解以下系统来计算 <span class="math notranslate nohighlight">\(y\)</span></p>
<div class="math notranslate nohighlight">
\[
y = A^{-1} \left(b + u\right)
\]</div>
<p>我们有</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mu_{y} = A^{-1} \mu_{b} \\
\Sigma_{y} &amp;= A^{-1} E \left[\left(b - \mu_{b} + u \right) \left(b - \mu_{b} + u \right)^{\prime}\right] \left(A^{-1}\right)^{\prime} \\
           &amp;= A^{-1} \left(\Sigma_{b} + \Sigma_{u} \right) \left(A^{-1}\right)^{\prime}
\end{aligned}
\end{split}\]</div>
<p>其中</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mu_{b}=\left[\begin{array}{c}
\alpha_{0}+\alpha_{1}\mu_{y_{0}}+\alpha_{2}\mu_{y_{-1}}\\
\alpha_{0}+\alpha_{2}\mu_{y_{0}}\\
\alpha_{0}\\
\vdots\\
\alpha_{0}
\end{array}\right]
\end{split}\]</div>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}
\Sigma_{b}=\left[\begin{array}{cc}\\\begin{split}C\Sigma_{\tilde{y}}C^{\prime} &amp; \boldsymbol{0}_{N-2\times N-2}\\
\boldsymbol{0}_{N-2\times2} &amp; \boldsymbol{0}_{N-2\times N-2}
\end{array}\right],\quad C=\left[\begin{array}{cc}
\alpha_{2} &amp; \alpha_{1}\\
0 &amp; \alpha_{2}
\end{array}\right]
\end{split}\end{aligned}\end{align} \]</div>
<div class="math notranslate nohighlight">
\[\begin{split}
\Sigma_{u}=\left[\begin{array}{cccc}
\sigma_{u}^{2} &amp; 0 &amp; \cdots &amp; 0\\
0 &amp; \sigma_{u}^{2} &amp; \cdots &amp; 0\\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots\\
0 &amp; 0 &amp; \cdots &amp; \sigma_{u}^{2}
\end{array}\right]
\end{split}\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 设置参数</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">80</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">160</span>
<span class="c1"># 二阶差分方程的系数</span>
<span class="n">𝛼0</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">𝛼1</span> <span class="o">=</span> <span class="mf">1.53</span>
<span class="n">𝛼2</span> <span class="o">=</span> <span class="o">-</span><span class="mf">.9</span>

<span class="c1"># u的方差</span>
<span class="n">σu</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="n">σu</span> <span class="o">=</span> <span class="mf">10.</span>

<span class="c1"># y_{-1}和y_{0}的分布</span>
<span class="n">μy_tilde</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
<span class="n">Σy_tilde</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">2.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 构建 A 和 A^{\prime}</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">))</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
    <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">𝛼1</span>

    <span class="k">if</span> <span class="n">i</span><span class="o">-</span><span class="mi">2</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">𝛼2</span>

<span class="n">A_inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 计算b和y的均值向量</span>
<span class="n">μb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">𝛼0</span><span class="p">)</span>
<span class="n">μb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">𝛼1</span> <span class="o">*</span> <span class="n">μy_tilde</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">𝛼2</span> <span class="o">*</span> <span class="n">μy_tilde</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">μb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">𝛼2</span> <span class="o">*</span> <span class="n">μy_tilde</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="n">μy</span> <span class="o">=</span> <span class="n">A_inv</span> <span class="o">@</span> <span class="n">μb</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 计算b和y的协方差矩阵</span>
<span class="n">Σu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">σu</span> <span class="o">**</span> <span class="mi">2</span>

<span class="n">Σb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">))</span>

<span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">𝛼2</span><span class="p">,</span> <span class="n">𝛼1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">𝛼2</span><span class="p">]])</span>
<span class="n">Σb</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span> <span class="o">@</span> <span class="n">Σy_tilde</span> <span class="o">@</span> <span class="n">C</span><span class="o">.</span><span class="n">T</span>

<span class="n">Σy</span> <span class="o">=</span> <span class="n">A_inv</span> <span class="o">@</span> <span class="p">(</span><span class="n">Σb</span> <span class="o">+</span> <span class="n">Σu</span><span class="p">)</span> <span class="o">@</span> <span class="n">A_inv</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="id15">
<h2><a class="toc-backref" href="#id33"><span class="section-number">12.11. </span>应用于股票价格模型</a><a class="headerlink" href="#id15" title="Permalink to this heading">#</a></h2>
<p>令</p>
<div class="math notranslate nohighlight">
\[
p_{t} = \sum_{j=0}^{T-t} \beta^{j} y_{t+j}
\]</div>
<p>构造</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\underset{\equiv p}{\underbrace{\left[\begin{array}{c}
p_{1}\\
p_{2}\\
p_{3}\\
\vdots\\
p_{T}
\end{array}\right]}}=\underset{\equiv B}{\underbrace{\left[\begin{array}{ccccc}
1 &amp; \beta &amp; \beta^{2} &amp; \cdots &amp; \beta^{T-1}\\
0 &amp; 1 &amp; \beta &amp; \cdots &amp; \beta^{T-2}\\
0 &amp; 0 &amp; 1 &amp; \cdots &amp; \beta^{T-3}\\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots\\
0 &amp; 0 &amp; 0 &amp; \cdots &amp; 1
\end{array}\right]}}\left[\begin{array}{c}
y_{1}\\
y_{2}\\
y_{3}\\
\vdots\\
y_{T}
\end{array}\right]
\end{split}\]</div>
<p>我们得到</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mu_{p} = B \mu_{y} \\
\Sigma_{p} = B \Sigma_{y} B^{\prime}
\end{aligned}
\end{split}\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">β</span> <span class="o">=</span> <span class="mf">.96</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 构建 B</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">))</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
    <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">:]</span> <span class="o">=</span> <span class="n">β</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>记</p>
<div class="math notranslate nohighlight">
\[\begin{split}
z=\left[\begin{array}{c}
y\\
p
\end{array}\right]=\underset{\equiv D}{\underbrace{\left[\begin{array}{c}
I\\
B
\end{array}\right]}} y
\end{split}\]</div>
<p>因此，<span class="math notranslate nohighlight">\(\{y_t\}_{t=1}^{T}\)</span> 和 <span class="math notranslate nohighlight">\(\{p_t\}_{t=1}^{T}\)</span> 共同
服从多元正态分布
<span class="math notranslate nohighlight">\(N \left(\mu_{z}, \Sigma_{z}\right)\)</span>，其中</p>
<div class="math notranslate nohighlight">
\[
\mu_{z}=D\mu_{y}
\]</div>
<div class="math notranslate nohighlight">
\[
\Sigma_{z}=D\Sigma_{y}D^{\prime}
\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="n">B</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">μz</span> <span class="o">=</span> <span class="n">D</span> <span class="o">@</span> <span class="n">μy</span>
<span class="n">Σz</span> <span class="o">=</span> <span class="n">D</span> <span class="o">@</span> <span class="n">Σy</span> <span class="o">@</span> <span class="n">D</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
</div>
</div>
<p>我们可以使用 <code class="docutils literal notranslate"><span class="pre">MultivariateNormal</span></code> 类来模拟 <span class="math notranslate nohighlight">\(y_{t}\)</span> 和 <span class="math notranslate nohighlight">\(p_{t}\)</span> 的路径，并计算条件期望 <span class="math notranslate nohighlight">\(E \left[p_{t} \mid y_{t-1}, y_{t}\right]\)</span>。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">μz</span><span class="p">,</span> <span class="n">Σz</span><span class="p">)</span>
<span class="n">y</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">z</span><span class="p">[:</span><span class="n">T</span><span class="p">],</span> <span class="n">z</span><span class="p">[</span><span class="n">T</span><span class="p">:]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cond_Ep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">T</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="n">sub_μ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">sub_Σ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">sub_μ</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">μz</span><span class="p">[[</span><span class="n">t</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">t</span><span class="p">]]</span>
    <span class="n">sub_Σ</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Σz</span><span class="p">[[</span><span class="n">t</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">t</span><span class="p">],</span> <span class="p">:][:,</span> <span class="p">[</span><span class="n">t</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="o">-</span><span class="mi">1</span><span class="o">+</span><span class="n">t</span><span class="p">]]</span>

    <span class="n">multi_normal</span> <span class="o">=</span> <span class="n">MultivariateNormal</span><span class="p">(</span><span class="n">sub_μ</span><span class="p">,</span> <span class="n">sub_Σ</span><span class="p">)</span>
    <span class="n">multi_normal</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">cond_Ep</span><span class="p">[</span><span class="n">t</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">multi_normal</span><span class="o">.</span><span class="n">cond_dist</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">t</span><span class="o">-</span><span class="mi">2</span><span class="p">:</span><span class="n">t</span><span class="p">])[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="p">),</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$y_</span><span class="si">{t}</span><span class="s1">$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="p">),</span> <span class="n">y</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$y_{t-1}$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="p">),</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$p_</span><span class="si">{t}</span><span class="s1">$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">T</span><span class="p">),</span> <span class="n">cond_Ep</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$Ep_</span><span class="si">{t}</span><span class="s1">|y_</span><span class="si">{t}</span><span class="s1">, y_{t-1}$&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/aa41d75bfe4b760df1b30b3e119603a045635f7332940ca74e34df42e92cca87.png" src="_images/aa41d75bfe4b760df1b30b3e119603a045635f7332940ca74e34df42e92cca87.png" />
</div>
</div>
<p>在上图中，绿线表示如果人们对股息路径有完美预见时的股票价格，而绿线表示条件期望 <span class="math notranslate nohighlight">\(E p_t | y_t, y_{t-1}\)</span>，这是在人们没有完美预见但基于时间 <span class="math notranslate nohighlight">\(t\)</span> 的信息 <span class="math notranslate nohighlight">\(y_t, y_{t-1}\)</span> 对未来股息进行最优预测时的股票价格。</p>
</section>
<section id="id16">
<h2><a class="toc-backref" href="#id34"><span class="section-number">12.12. </span>滤波基础</a><a class="headerlink" href="#id16" title="Permalink to this heading">#</a></h2>
<p>假设 <span class="math notranslate nohighlight">\(x_0\)</span> 是一个 <span class="math notranslate nohighlight">\(n \times 1\)</span> 随机向量，且 <span class="math notranslate nohighlight">\(y_0\)</span> 是一个由以下<em>观测方程</em>决定的 <span class="math notranslate nohighlight">\(p \times 1\)</span> 随机向量</p>
<div class="math notranslate nohighlight">
\[
y_0 = G x_0 + v_0  , \quad x_0 \sim {\mathcal N}(\hat x_0, \Sigma_0), \quad v_0 \sim {\mathcal N}(0, R)
\]</div>
<p>其中 <span class="math notranslate nohighlight">\(v_0\)</span> 与 <span class="math notranslate nohighlight">\(x_0\)</span> 正交，<span class="math notranslate nohighlight">\(G\)</span> 是一个 <span class="math notranslate nohighlight">\(p \times n\)</span> 矩阵，且 <span class="math notranslate nohighlight">\(R\)</span> 是一个 <span class="math notranslate nohighlight">\(p \times p\)</span> 正定矩阵。</p>
<p>我们考虑这样一个人的问题，他：</p>
<ul class="simple">
<li><p><em>观察到</em> <span class="math notranslate nohighlight">\(y_0\)</span></p></li>
<li><p>没有观察到 <span class="math notranslate nohighlight">\(x_0\)</span></p></li>
<li><p>已知 <span class="math notranslate nohighlight">\(\hat x_0, \Sigma_0, G, R\)</span> 以及向量 <span class="math notranslate nohighlight">\(\begin{bmatrix} x_0 \cr y_0 \end{bmatrix}\)</span> 的联合概率分布</p></li>
<li><p>想要根据他所知道的联合概率分布，从 <span class="math notranslate nohighlight">\(y_0\)</span> 推断 <span class="math notranslate nohighlight">\(x_0\)</span>。</p></li>
</ul>
<p>因此，这个人想要构建基于随机向量 <span class="math notranslate nohighlight">\(y_0\)</span> 的 <span class="math notranslate nohighlight">\(x_0\)</span> 的条件概率分布。</p>
<p><span class="math notranslate nohighlight">\(\begin{bmatrix} x_0 \cr y_0 \end{bmatrix}\)</span> 的联合分布是多元正态分布 <span class="math notranslate nohighlight">\({\mathcal N}(\mu, \Sigma)\)</span>，其中</p>
<div class="math notranslate nohighlight">
\[
\mu = \begin{bmatrix} \hat x_0 \cr G \hat x_0 \end{bmatrix} , \quad
  \Sigma = \begin{bmatrix} \Sigma_0 &amp; \Sigma_0 G' \cr
                          G \Sigma_0 &amp; G \Sigma_0 G' + R \end{bmatrix}
\]</div>
<p>通过适当应用上述关于 <span class="math notranslate nohighlight">\(z_1\)</span> 在给定 <span class="math notranslate nohighlight">\(z_2\)</span> 条件下的均值向量 <span class="math notranslate nohighlight">\(\hat \mu_1\)</span> 和协方差矩阵 <span class="math notranslate nohighlight">\(\hat \Sigma_{11}\)</span> 的公式，我们发现 <span class="math notranslate nohighlight">\(x_0\)</span> 在给定 <span class="math notranslate nohighlight">\(y_0\)</span> 条件下的概率分布是 <span class="math notranslate nohighlight">\({\mathcal N}(\tilde x_0, \tilde \Sigma_0)\)</span>，其中</p>
<div class="math notranslate nohighlight">
\[\begin{aligned} \beta_0  &amp; = \Sigma_0 G' (G \Sigma_0 G' + R)^{-1} \cr
\tilde x_0 &amp; = \hat x_0 + \beta_0 ( y_0 - G \hat x_0) \cr
 \tilde \Sigma_0 &amp; = \Sigma_0 - \Sigma_0 G' (G \Sigma_0 G' + R)^{-1} G \Sigma_0
  \end{aligned}
\]</div>
<p>我们可以通过将<span class="math notranslate nohighlight">\(x_0\)</span>表示为以下形式来表达<span class="math notranslate nohighlight">\(x_0\)</span>在<span class="math notranslate nohighlight">\(y_0\)</span>条件下的概率分布为<span class="math notranslate nohighlight">\({\mathcal N}(\tilde x_0, \tilde \Sigma_0)\)</span>：</p>
<div class="math notranslate nohighlight" id="equation-eq-x0rep2">
<span class="eqno">(12.2)<a class="headerlink" href="#equation-eq-x0rep2" title="Permalink to this equation">#</a></span>\[
 x_0 = \tilde x_0 + \zeta_0
\]</div>
<p>其中<span class="math notranslate nohighlight">\(\zeta_0\)</span>是一个高斯随机向量，它与<span class="math notranslate nohighlight">\(\tilde x_0\)</span>和<span class="math notranslate nohighlight">\(y_0\)</span>正交，并且具有均值向量<span class="math notranslate nohighlight">\(0\)</span>和条件协方差矩阵<span class="math notranslate nohighlight">\(E [\zeta_0 \zeta_0' | y_0] = \tilde \Sigma_0\)</span>。</p>
<section id="id17">
<h3><span class="section-number">12.12.1. </span>迈向动态分析<a class="headerlink" href="#id17" title="Permalink to this heading">#</a></h3>
<p>现在假设我们处在时间序列环境中，并且有一步状态转移方程：</p>
<div class="math notranslate nohighlight">
\[
x_1 = A x_0 + C w_1 ,  \quad w_1 \sim {\mathcal N}(0, I )
\]</div>
<p>其中<span class="math notranslate nohighlight">\(A\)</span>是一个<span class="math notranslate nohighlight">\(n \times n\)</span>矩阵，<span class="math notranslate nohighlight">\(C\)</span>是一个<span class="math notranslate nohighlight">\(n \times m\)</span>矩阵。</p>
<p>使用方程<a class="reference internal" href="#equation-eq-x0rep2">(12.2)</a>，我们也可以将<span class="math notranslate nohighlight">\(x_1\)</span>表示为</p>
<div class="math notranslate nohighlight">
\[x_1 = A (\tilde x_0 + \zeta_0) + C w_1
\]</div>
<p>由此可得</p>
<div class="math notranslate nohighlight">
\[ E x_1 | y_0 = A \tilde x_0
\]</div>
<p>相应的条件协方差矩阵 <span class="math notranslate nohighlight">\(E (x_1 - E x_1| y_0)  (x_1 - E x_1| y_0)' \equiv \Sigma_1\)</span> 为</p>
<div class="math notranslate nohighlight">
\[
 \Sigma_1 = A \tilde \Sigma_0 A' + C C'
\]</div>
<p>或</p>
<div class="math notranslate nohighlight">
\[
\Sigma_1 =  A \Sigma_0 A' - A \Sigma_0 G' (G \Sigma_0 G' + R)^{-1} G \Sigma_0 A'
\]</div>
<p>我们可以将 <span class="math notranslate nohighlight">\(x_1\)</span> 在 <span class="math notranslate nohighlight">\(y_0\)</span> 条件下的均值写作</p>
<div class="math notranslate nohighlight">
\[
 \hat x_1 = A \hat x_0 + A \Sigma_0 G' (G \Sigma_0 G' + R)^{-1} (y_0 - G \hat x_0)
\]</div>
<p>或</p>
<div class="math notranslate nohighlight">
\[
 \hat x_1 = A \hat x_0 + K_0 (y_0 - G \hat x_0)
\]</div>
<p>其中</p>
<div class="math notranslate nohighlight">
\[
K_0 = A \Sigma_0 G' (G \Sigma_0 G' + R)^{-1}
\]</div>
</section>
<section id="id18">
<h3><span class="section-number">12.12.2. </span>动态版本<a class="headerlink" href="#id18" title="Permalink to this heading">#</a></h3>
<p>现在假设对于 <span class="math notranslate nohighlight">\(t \geq 0\)</span>，
<span class="math notranslate nohighlight">\(\{x_{t+1}, y_t\}_{t=0}^\infty\)</span> 由以下方程支配</p>
<div class="math notranslate nohighlight">
\[
\begin{aligned}
x_{t+1} &amp; = A x_t + C w_{t+1} \cr
y_t &amp; = G x_t + v_t
\end{aligned}
\]</div>
<p>其中如前所述 <span class="math notranslate nohighlight">\(x_0 \sim {\mathcal N}(\hat x_0, \Sigma_0)\)</span>，
<span class="math notranslate nohighlight">\(w_{t+1}\)</span> 是独立同分布随机过程的第 <span class="math notranslate nohighlight">\(t+1\)</span> 个分量</p>
<p>过程 <span class="math notranslate nohighlight">\(w_{t+1}\)</span> 服从分布 <span class="math notranslate nohighlight">\(w_{t+1} \sim {\mathcal N}(0, I)\)</span>，而
<span class="math notranslate nohighlight">\(v_t\)</span> 是独立同分布过程的第 <span class="math notranslate nohighlight">\(t\)</span> 个分量，
服从分布 <span class="math notranslate nohighlight">\(v_t \sim {\mathcal N}(0, R)\)</span>，且
<span class="math notranslate nohighlight">\(\{w_{t+1}\}_{t=0}^\infty\)</span> 和 <span class="math notranslate nohighlight">\(\{v_t\}_{t=0}^\infty\)</span>
这两个过程在任意时间点对上都是正交的。</p>
<p>我们上面应用的逻辑和公式表明，在给定
<span class="math notranslate nohighlight">\(y_0, y_1, \ldots , y_{t-1} = y^{t-1}\)</span> 条件下，<span class="math notranslate nohighlight">\(x_t\)</span> 的概率分布为</p>
<div class="math notranslate nohighlight">
\[
x_t | y^{t-1} \sim {\mathcal N}(A \tilde x_t , A \tilde \Sigma_t A' + C C' )
\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\{\tilde x_t, \tilde \Sigma_t\}_{t=1}^\infty\)</span> 可以
通过从 <span class="math notranslate nohighlight">\(t=1\)</span> 开始迭代以下方程计算得到，
初始条件 <span class="math notranslate nohighlight">\(\tilde x_0, \tilde \Sigma_0\)</span> 按照我们上面的方法计算：</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}
\begin{aligned} \Sigma_t &amp; = A  \tilde \Sigma_{t-1} A' + C C' \cr
               \hat x_t &amp; = A \tilde x_{t-1} \cr
\beta_t &amp; = \Sigma_t G' (G \Sigma_t G' + R)^{-1} \cr
\tilde x_t &amp; = \hat x_t + \beta_t ( y_t - G \hat x_t) \cr\\\tilde \Sigma_t &amp; = \Sigma_t - \Sigma_t G' (G \Sigma_t G' + R)^{-1} G \Sigma_t
  \end{aligned}
\end{aligned}\end{align} \]</div>
<p>如果我们将第一个方程向前移动一个周期，然后将第五个方程右侧的<span class="math notranslate nohighlight">\(\tilde \Sigma_t\)</span>表达式代入其中，我们得到</p>
<div class="math notranslate nohighlight">
\[
\Sigma_{t+1}= C C' + A \Sigma_t A' - A \Sigma_t G' (G \Sigma_t G' +R)^{-1} G \Sigma_t A' .
\]</div>
<p>这是一个矩阵黎卡提差分方程，它与另一个出现在线性二次控制理论基础的quantecon讲座中的矩阵黎卡提差分方程密切相关。</p>
<p>那个方程的形式为</p>
<div class="math notranslate nohighlight">
\[P_{t-1} =R + A' P_t A  - A' P_t B
(B' P_t B + Q)^{-1}  B' P_t A  .
\]</div>
<p>请仔细观察前面这两个方程片刻，第一个是条件协方差矩阵的矩阵差分方程，第二个是出现在跨期成本值函数二次型中的矩阵的矩阵差分方程。</p>
<p>尽管这两个方程并不完全相同，但它们展现出显著的家族相似性。</p>
<ul class="simple">
<li><p>第一个方程描述了<strong>向前</strong>推进的动态过程</p></li>
<li><p>第二个方程描述了<strong>向后</strong>推进的动态过程</p></li>
<li><p>虽然许多项都很相似，但一个方程似乎对在另一个方程中扮演相似角色的矩阵进行矩阵变换</p></li>
</ul>
<p>这两个方程的家族相似性反映了控制理论和滤波理论之间存在的超越性<strong>对偶</strong>关系。</p>
</section>
<section id="id19">
<h3><span class="section-number">12.12.3. </span>一个例子<a class="headerlink" href="#id19" title="Permalink to this heading">#</a></h3>
<p>我们可以使用Python类 <em>MultivariateNormal</em> 来构建示例。</p>
<p>这是一个时间为<span class="math notranslate nohighlight">\(0\)</span>的单期问题示例</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">]])</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">]])</span>

<span class="n">x0_hat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span>
<span class="n">Σ0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">.3</span><span class="p">,</span> <span class="mf">2.</span><span class="p">]])</span>

<span class="n">μ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">x0_hat</span><span class="p">,</span> <span class="n">G</span> <span class="o">@</span> <span class="n">x0_hat</span><span class="p">])</span>
<span class="n">Σ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([[</span><span class="n">Σ0</span><span class="p">,</span> <span class="n">Σ0</span> <span class="o">@</span> <span class="n">G</span><span class="o">.</span><span class="n">T</span><span class="p">],</span> <span class="p">[</span><span class="n">G</span> <span class="o">@</span> <span class="n">Σ0</span><span class="p">,</span> <span class="n">G</span> <span class="o">@</span> <span class="n">Σ0</span> <span class="o">@</span> <span class="n">G</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">R</span><span class="p">]])</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 构建多元正态分布实例</span>
<span class="n">multi_normal</span> <span class="o">=</span> <span class="n">MultivariateNormal</span><span class="p">(</span><span class="n">μ</span><span class="p">,</span> <span class="n">Σ</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">multi_normal</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># y的观测值</span>
<span class="n">y0</span> <span class="o">=</span> <span class="mf">2.3</span>

<span class="c1"># x0的条件分布</span>
<span class="n">μ1_hat</span><span class="p">,</span> <span class="n">Σ11</span> <span class="o">=</span> <span class="n">multi_normal</span><span class="o">.</span><span class="n">cond_dist</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y0</span><span class="p">)</span>
<span class="n">μ1_hat</span><span class="p">,</span> <span class="n">Σ11</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(array([-0.078125,  0.803125]),
 array([[ 0.72098214, -0.203125  ],
        [-0.403125  ,  0.228125  ]]))
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">]])</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">2.</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.</span><span class="p">]])</span>

<span class="c1"># x1的条件分布</span>
<span class="n">x1_cond</span> <span class="o">=</span> <span class="n">A</span> <span class="o">@</span> <span class="n">μ1_hat</span>
<span class="n">Σ1_cond</span> <span class="o">=</span> <span class="n">C</span> <span class="o">@</span> <span class="n">C</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">A</span> <span class="o">@</span> <span class="n">Σ11</span> <span class="o">@</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span>
<span class="n">x1_cond</span><span class="p">,</span> <span class="n">Σ1_cond</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(array([0.1215625, 0.24875  ]),
 array([[4.12874554, 1.95523214],
        [1.92123214, 1.04592857]]))
</pre></div>
</div>
</div>
</div>
</section>
<section id="id20">
<h3><span class="section-number">12.12.4. </span>迭代代码<a class="headerlink" href="#id20" title="Permalink to this heading">#</a></h3>
<p>以下是通过迭代方程来解决动态滤波问题的代码，并附有示例。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">iterate</span><span class="p">(</span><span class="n">x0_hat</span><span class="p">,</span> <span class="n">Σ0</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">y_seq</span><span class="p">):</span>

    <span class="n">p</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">T</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_seq</span><span class="p">)</span>
    <span class="n">x_hat_seq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="n">Σ_hat_seq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">T</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

    <span class="n">x_hat_seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x0_hat</span>
    <span class="n">Σ_hat_seq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Σ0</span>

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
        <span class="n">xt_hat</span> <span class="o">=</span> <span class="n">x_hat_seq</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
        <span class="n">Σt</span> <span class="o">=</span> <span class="n">Σ_hat_seq</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
        <span class="n">μ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">xt_hat</span><span class="p">,</span> <span class="n">G</span> <span class="o">@</span> <span class="n">xt_hat</span><span class="p">])</span>
        <span class="n">Σ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([[</span><span class="n">Σt</span><span class="p">,</span> <span class="n">Σt</span> <span class="o">@</span> <span class="n">G</span><span class="o">.</span><span class="n">T</span><span class="p">],</span> <span class="p">[</span><span class="n">G</span> <span class="o">@</span> <span class="n">Σt</span><span class="p">,</span> <span class="n">G</span> <span class="o">@</span> <span class="n">Σt</span> <span class="o">@</span> <span class="n">G</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">R</span><span class="p">]])</span>

        <span class="c1"># 滤波</span>
        <span class="n">multi_normal</span> <span class="o">=</span> <span class="n">MultivariateNormal</span><span class="p">(</span><span class="n">μ</span><span class="p">,</span> <span class="n">Σ</span><span class="p">)</span>
        <span class="n">multi_normal</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">x_tilde</span><span class="p">,</span> <span class="n">Σ_tilde</span> <span class="o">=</span> <span class="n">multi_normal</span><span class="o">.</span><span class="n">cond_dist</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y_seq</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>

        <span class="c1"># 预测</span>
        <span class="n">x_hat_seq</span><span class="p">[</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span> <span class="o">@</span> <span class="n">x_tilde</span>
        <span class="n">Σ_hat_seq</span><span class="p">[</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span> <span class="o">@</span> <span class="n">C</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">A</span> <span class="o">@</span> <span class="n">Σ_tilde</span> <span class="o">@</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span>

    <span class="k">return</span> <span class="n">x_hat_seq</span><span class="p">,</span> <span class="n">Σ_hat_seq</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">iterate</span><span class="p">(</span><span class="n">x0_hat</span><span class="p">,</span> <span class="n">Σ0</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="p">[</span><span class="mf">2.3</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">3.2</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(array([[0.        , 1.        ],
        [0.1215625 , 0.24875   ],
        [0.18680212, 0.06904689],
        [0.75576875, 0.05558463]]),
 array([[[1.        , 0.5       ],
         [0.3       , 2.        ]],
 
        [[4.12874554, 1.95523214],
         [1.92123214, 1.04592857]],
 
        [[4.08198663, 1.99218488],
         [1.98640488, 1.00886423]],
 
        [[4.06457628, 2.00041999],
         [1.99943739, 1.00275526]]]))
</pre></div>
</div>
</div>
</div>
<p>刚才描述的迭代算法是著名的<strong>卡尔曼滤波器</strong>的一个版本。</p>
<p>我们在<a class="reference internal" href="kalman.html"><span class="doc">卡尔曼滤波器初探</span></a>中描述了卡尔曼滤波器及其一些应用。</p>
</section>
</section>
<section id="id21">
<h2><a class="toc-backref" href="#id35"><span class="section-number">12.13. </span>经典因子分析模型</a><a class="headerlink" href="#id21" title="Permalink to this heading">#</a></h2>
<p>在心理学和其他领域广泛使用的因子分析模型可以表示为：</p>
<div class="math notranslate nohighlight">
\[
Y = \Lambda f + U
\]</div>
<p>其中：</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(Y\)</span> 是 <span class="math notranslate nohighlight">\(n \times 1\)</span> 随机向量，
<span class="math notranslate nohighlight">\(E U U^{\prime} = D\)</span> 是一个对角矩阵，</p></li>
<li><p><span class="math notranslate nohighlight">\(\Lambda\)</span> 是 <span class="math notranslate nohighlight">\(n \times k\)</span> 系数矩阵，</p></li>
<li><p><span class="math notranslate nohighlight">\(f\)</span> 是 <span class="math notranslate nohighlight">\(k \times 1\)</span> 随机向量，
<span class="math notranslate nohighlight">\(E f f^{\prime} = I\)</span>，</p></li>
<li><p><span class="math notranslate nohighlight">\(U\)</span> 是 <span class="math notranslate nohighlight">\(n \times 1\)</span> 随机向量，且 <span class="math notranslate nohighlight">\(U \perp f\)</span>（即 <span class="math notranslate nohighlight">\(E U f' = 0\)</span>）</p></li>
<li><p>假设 <span class="math notranslate nohighlight">\(k\)</span> 相对于 <span class="math notranslate nohighlight">\(n\)</span> 较小；通常
<span class="math notranslate nohighlight">\(k\)</span> 只有 <span class="math notranslate nohighlight">\(1\)</span> 或 <span class="math notranslate nohighlight">\(2\)</span>，就像我们的智商示例中那样。</p></li>
</ol>
<p>这意味着：</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\Sigma_y = E Y Y^{\prime} = \Lambda \Lambda^{\prime} + D \\
E Y f^{\prime} = \Lambda \\
E f Y^{\prime} = \Lambda^{\prime}
\end{aligned}
\end{split}\]</div>
<p>因此，协方差矩阵 <span class="math notranslate nohighlight">\(\Sigma_Y\)</span> 是一个对角</p>
<p>矩阵 <span class="math notranslate nohighlight">\(D\)</span> 和一个秩为 <span class="math notranslate nohighlight">\(k\)</span> 的半正定矩阵 <span class="math notranslate nohighlight">\(\Lambda \Lambda^{\prime}\)</span>。</p>
<p>这意味着 <span class="math notranslate nohighlight">\(Y\)</span> 向量的 <span class="math notranslate nohighlight">\(n\)</span> 个分量之间的所有协方差都是通过它们与 <span class="math notranslate nohighlight">\(k&lt;\)</span> 个因子的共同依赖关系来中介的。</p>
<p>构造</p>
<div class="math notranslate nohighlight">
\[\begin{split}
Z=\left(\begin{array}{c}
f\\
Y
\end{array}\right)
\end{split}\]</div>
<p>扩展随机向量 <span class="math notranslate nohighlight">\(Z\)</span> 的协方差矩阵可以计算为</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\Sigma_{z} = EZZ^{\prime}=\left(\begin{array}{cc}
I &amp; \Lambda^{\prime}\\
\Lambda &amp; \Lambda\Lambda^{\prime}+D
\end{array}\right)
\end{split}\]</div>
<p>接下来，我们首先构造 <span class="math notranslate nohighlight">\(N=10\)</span> 和 <span class="math notranslate nohighlight">\(k=2\)</span> 情况下的均值向量和协方差矩阵。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
<p>我们设定系数矩阵<span class="math notranslate nohighlight">\(\Lambda\)</span>和<span class="math notranslate nohighlight">\(U\)</span>的协方差矩阵为</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\Lambda=\left(\begin{array}{cc}
1 &amp; 0\\
\vdots &amp; \vdots\\
1 &amp; 0\\
0 &amp; 1\\
\vdots &amp; \vdots\\
0 &amp; 1
\end{array}\right),\quad D=\left(\begin{array}{cccc}
\sigma_{u}^{2} &amp; 0 &amp; \cdots &amp; 0\\
0 &amp; \sigma_{u}^{2} &amp; \cdots &amp; 0\\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots\\
0 &amp; 0 &amp; \cdots &amp; \sigma_{u}^{2}
\end{array}\right)
\end{split}\]</div>
<p>其中<span class="math notranslate nohighlight">\(\Lambda\)</span>的第一列前半部分填充为<span class="math notranslate nohighlight">\(1\)</span>，后半部分为<span class="math notranslate nohighlight">\(0\)</span>，第二列则相反。</p>
<p><span class="math notranslate nohighlight">\(D\)</span>是一个对角矩阵，对角线上的元素为参数<span class="math notranslate nohighlight">\(\sigma_{u}^{2}\)</span>。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Λ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
<span class="n">Λ</span><span class="p">[:</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">Λ</span><span class="p">[</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">σu</span> <span class="o">=</span> <span class="mf">.5</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="n">σu</span> <span class="o">**</span> <span class="mi">2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 计算 Σy</span>
<span class="n">Σy</span> <span class="o">=</span> <span class="n">Λ</span> <span class="o">@</span> <span class="n">Λ</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">D</span>
</pre></div>
</div>
</div>
</div>
<p>我们现在可以构建<span class="math notranslate nohighlight">\(Z\)</span>的均值向量和协方差矩阵。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">μz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="n">N</span><span class="p">)</span>

<span class="n">Σz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">k</span><span class="o">+</span><span class="n">N</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="n">N</span><span class="p">))</span>

<span class="n">Σz</span><span class="p">[:</span><span class="n">k</span><span class="p">,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
<span class="n">Σz</span><span class="p">[:</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">:]</span> <span class="o">=</span> <span class="n">Λ</span><span class="o">.</span><span class="n">T</span>
<span class="n">Σz</span><span class="p">[</span><span class="n">k</span><span class="p">:,</span> <span class="p">:</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Λ</span>
<span class="n">Σz</span><span class="p">[</span><span class="n">k</span><span class="p">:,</span> <span class="n">k</span><span class="p">:]</span> <span class="o">=</span> <span class="n">Σy</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">μz</span><span class="p">,</span> <span class="n">Σz</span><span class="p">)</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">z</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">k</span><span class="p">:]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">multi_normal_factor</span> <span class="o">=</span> <span class="n">MultivariateNormal</span><span class="p">(</span><span class="n">μz</span><span class="p">,</span> <span class="n">Σz</span><span class="p">)</span>
<span class="n">multi_normal_factor</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>让我们计算隐藏因子<span class="math notranslate nohighlight">\(f\)</span>在观测值<span class="math notranslate nohighlight">\(Y\)</span>上的条件分布，即<span class="math notranslate nohighlight">\(f \mid Y=y\)</span>。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">multi_normal_factor</span><span class="o">.</span><span class="n">cond_dist</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(array([ 1.1498889, -0.9083476]),
 array([[0.04761905, 0.        ],
        [0.        , 0.04761905]]))
</pre></div>
</div>
</div>
</div>
<p>我们可以验证条件期望
<span class="math notranslate nohighlight">\(E \left[f \mid Y=y\right] = B Y\)</span> 其中
<span class="math notranslate nohighlight">\(B = \Lambda^{\prime} \Sigma_{y}^{-1}\)</span>。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">=</span> <span class="n">Λ</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">Σy</span><span class="p">)</span>

<span class="n">B</span> <span class="o">@</span> <span class="n">y</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([ 1.1498889, -0.9083476])
</pre></div>
</div>
</div>
</div>
<p>类似地，我们可以计算条件分布 <span class="math notranslate nohighlight">\(Y \mid f\)</span>。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">multi_normal_factor</span><span class="o">.</span><span class="n">cond_dist</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(array([ 1.51850567,  1.51850567,  1.51850567,  1.51850567,  1.51850567,
        -0.88080678, -0.88080678, -0.88080678, -0.88080678, -0.88080678]),
 array([[0.25, 0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.  ],
        [0.  , 0.25, 0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.  ],
        [0.  , 0.  , 0.25, 0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.  ],
        [0.  , 0.  , 0.  , 0.25, 0.  , 0.  , 0.  , 0.  , 0.  , 0.  ],
        [0.  , 0.  , 0.  , 0.  , 0.25, 0.  , 0.  , 0.  , 0.  , 0.  ],
        [0.  , 0.  , 0.  , 0.  , 0.  , 0.25, 0.  , 0.  , 0.  , 0.  ],
        [0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.25, 0.  , 0.  , 0.  ],
        [0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.25, 0.  , 0.  ],
        [0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.25, 0.  ],
        [0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.25]]))
</pre></div>
</div>
</div>
</div>
<p>可以验证该均值为
<span class="math notranslate nohighlight">\(\Lambda I^{-1} f = \Lambda f\)</span>。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Λ</span> <span class="o">@</span> <span class="n">f</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([ 1.51850567,  1.51850567,  1.51850567,  1.51850567,  1.51850567,
       -0.88080678, -0.88080678, -0.88080678, -0.88080678, -0.88080678])
</pre></div>
</div>
</div>
</div>
</section>
<section id="pca">
<h2><a class="toc-backref" href="#id36"><span class="section-number">12.14. </span>PCA和因子分析</a><a class="headerlink" href="#pca" title="Permalink to this heading">#</a></h2>
<p>要了解主成分分析(PCA),请参阅本讲座<a class="reference internal" href="svd_intro.html"><span class="doc">奇异值分解</span></a>。</p>
<p>让我们来做个有趣的练习,对实际上由我们的因子分析模型支配的协方差矩阵 <span class="math notranslate nohighlight">\(\Sigma_y\)</span> 进行PCA分解。</p>
<p>从技术上讲,这意味着PCA模型是错误设定的。(你能解释为什么吗?)</p>
<p>尽管如此,这个练习将让我们研究PCA的前两个主成分如何近似我们假设真实支配Y数据的因子分析模型中两个因子 <span class="math notranslate nohighlight">\(f_i\)</span> (<span class="math notranslate nohighlight">\(i=1,2\)</span>)的条件期望 <span class="math notranslate nohighlight">\(E f_i | Y\)</span>。</p>
<p>因此我们计算PCA分解</p>
<div class="math notranslate nohighlight">
\[
\Sigma_{y} = P \tilde{\Lambda} P^{\prime}
\]</div>
<p>其中 <span class="math notranslate nohighlight">\(\tilde{\Lambda}\)</span> 是一个对角矩阵。</p>
<p>我们有</p>
<div class="math notranslate nohighlight">
\[
Y = P \epsilon
\]</div>
<p>和</p>
<div class="math notranslate nohighlight">
\[
\epsilon = P^\prime Y
\]</div>
<p>注意,我们将按特征值<em>降序</em>排列 <span class="math notranslate nohighlight">\(P\)</span> 中的特征向量。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">𝜆_tilde</span><span class="p">,</span> <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">Σy</span><span class="p">)</span>

<span class="c1"># 按特征值排列特征向量</span>
<span class="n">ind</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">𝜆_tilde</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">P</span> <span class="o">=</span> <span class="n">P</span><span class="p">[:,</span> <span class="n">ind</span><span class="p">]</span>
<span class="n">𝜆_tilde</span> <span class="o">=</span> <span class="n">𝜆_tilde</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
<span class="n">Λ_tilde</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">𝜆_tilde</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;𝜆_tilde =&#39;</span><span class="p">,</span> <span class="n">𝜆_tilde</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>𝜆_tilde = [5.25 5.25 0.25 0.25 0.25 0.25 0.25 0.25 0.25 0.25]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 验证特征向量的正交性</span>
<span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">P</span> <span class="o">@</span> <span class="n">P</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">N</span><span class="p">))</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>8.881784197001252e-16
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 验证特征值分解是否正确</span>
<span class="n">P</span> <span class="o">@</span> <span class="n">Λ_tilde</span> <span class="o">@</span> <span class="n">P</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([[1.25, 1.  , 1.  , 1.  , 1.  , 0.  , 0.  , 0.  , 0.  , 0.  ],
       [1.  , 1.25, 1.  , 1.  , 1.  , 0.  , 0.  , 0.  , 0.  , 0.  ],
       [1.  , 1.  , 1.25, 1.  , 1.  , 0.  , 0.  , 0.  , 0.  , 0.  ],
       [1.  , 1.  , 1.  , 1.25, 1.  , 0.  , 0.  , 0.  , 0.  , 0.  ],
       [1.  , 1.  , 1.  , 1.  , 1.25, 0.  , 0.  , 0.  , 0.  , 0.  ],
       [0.  , 0.  , 0.  , 0.  , 0.  , 1.25, 1.  , 1.  , 1.  , 1.  ],
       [0.  , 0.  , 0.  , 0.  , 0.  , 1.  , 1.25, 1.  , 1.  , 1.  ],
       [0.  , 0.  , 0.  , 0.  , 0.  , 1.  , 1.  , 1.25, 1.  , 1.  ],
       [0.  , 0.  , 0.  , 0.  , 0.  , 1.  , 1.  , 1.  , 1.25, 1.  ],
       [0.  , 0.  , 0.  , 0.  , 0.  , 1.  , 1.  , 1.  , 1.  , 1.25]])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ε</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">y</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ε = &quot;</span><span class="p">,</span> <span class="n">ε</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>ε =  [-2.13268332  2.69979123 -0.33692815  0.05695313 -0.21808164 -0.06542939
 -0.04374063 -0.2726217  -0.80741426  0.51412639]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 打印两个因子的值</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;f = &#39;</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>f =  [ 1.51850567 -0.88080678]
</pre></div>
</div>
</div>
</div>
<p>下面我们将绘制几个图：</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(N\)</span> 个 <span class="math notranslate nohighlight">\(y\)</span> 值</p></li>
<li><p><span class="math notranslate nohighlight">\(N\)</span> 个主成分 <span class="math notranslate nohighlight">\(\epsilon\)</span> 值</p></li>
<li><p>第一个因子 <span class="math notranslate nohighlight">\(f_1\)</span> 的值，仅绘制前 <span class="math notranslate nohighlight">\(N/2\)</span> 个在 <span class="math notranslate nohighlight">\(\Lambda\)</span> 中具有非零载荷的 <span class="math notranslate nohighlight">\(y\)</span> 观测值</p></li>
<li><p>第二个因子 <span class="math notranslate nohighlight">\(f_2\)</span> 的值，仅绘制最后 <span class="math notranslate nohighlight">\(N/2\)</span> 个在 <span class="math notranslate nohighlight">\(\Lambda\)</span> 中具有非零载荷的观测值</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">y</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">ε</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$\epsilon$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$f_</span><span class="si">{1}</span><span class="s1">$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;-.&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$f_</span><span class="si">{2}</span><span class="s1">$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;&gt;:2: SyntaxWarning: invalid escape sequence &#39;\e&#39;
&lt;&gt;:2: SyntaxWarning: invalid escape sequence &#39;\e&#39;
/tmp/ipykernel_7482/2845509298.py:2: SyntaxWarning: invalid escape sequence &#39;\e&#39;
  plt.scatter(range(N), ε, label=&#39;$\epsilon$&#39;)
</pre></div>
</div>
<img alt="_images/828b93d8cc657877a579ece3a5fc6fd3ff0fb389436ca34fd687e1e1acfdb61a.png" src="_images/828b93d8cc657877a579ece3a5fc6fd3ff0fb389436ca34fd687e1e1acfdb61a.png" />
</div>
</div>
<p>因此，前两个 <span class="math notranslate nohighlight">\(\epsilon_{j}\)</span> 对应于最大的两个特征值。</p>
<p>让我们来看看它们，之后我们将查看 <span class="math notranslate nohighlight">\(E f | y = B y\)</span></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ε</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([-2.13268332,  2.69979123])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 与 Ef|y 比较</span>
<span class="n">B</span> <span class="o">@</span> <span class="n">y</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([ 1.1498889, -0.9083476])
</pre></div>
</div>
</div>
</div>
<p><span class="math notranslate nohighlight">\(y_{t}\)</span> 中由前两个主成分解释的方差比例可以按如下方式计算。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">𝜆_tilde</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">𝜆_tilde</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.8400000000000001
</pre></div>
</div>
</div>
</div>
<p>计算</p>
<div class="math notranslate nohighlight">
\[
\hat{Y} = P_{j} \epsilon_{j} + P_{k} \epsilon_{k}
\]</div>
<p>其中 <span class="math notranslate nohighlight">\(P_{j}\)</span> 和 <span class="math notranslate nohighlight">\(P_{k}\)</span> 对应最大的两个特征值。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">y_hat</span> <span class="o">=</span> <span class="n">P</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">@</span> <span class="n">ε</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>在这个例子中，Y在前两个主成分上的投影<span class="math notranslate nohighlight">\(\hat{Y}\)</span>很好地近似了<span class="math notranslate nohighlight">\(Ef \mid y\)</span>。</p>
<p>我们通过下面的图来确认这一点，图中展示了<span class="math notranslate nohighlight">\(f\)</span>、<span class="math notranslate nohighlight">\(E y \mid f\)</span>、<span class="math notranslate nohighlight">\(E f \mid y\)</span>和<span class="math notranslate nohighlight">\(\hat{y}\)</span>（在坐标轴上）与<span class="math notranslate nohighlight">\(y\)</span>（在纵轴上）的关系。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">Λ</span> <span class="o">@</span> <span class="n">f</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$Ey|f$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">y_hat</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$\hat</span><span class="si">{y}</span><span class="s1">$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$f_</span><span class="si">{1}</span><span class="s1">$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;-.&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$f_</span><span class="si">{2}</span><span class="s1">$&#39;</span><span class="p">)</span>

<span class="n">Efy</span> <span class="o">=</span> <span class="n">B</span> <span class="o">@</span> <span class="n">y</span>
<span class="n">plt</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="n">Efy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$Ef_</span><span class="si">{1}</span><span class="s1">|y$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="n">Efy</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;-.&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;$Ef_</span><span class="si">{2}</span><span class="s1">|y$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/8ebca85343b521a498f4c1caffb843ecdcfc031e3b0d349ed46d38bc26bd7318.png" src="_images/8ebca85343b521a498f4c1caffb843ecdcfc031e3b0d349ed46d38bc26bd7318.png" />
</div>
</div>
<p><span class="math notranslate nohighlight">\(\hat{Y}\)</span> 的协方差矩阵可以通过先构建 <span class="math notranslate nohighlight">\(\epsilon\)</span> 的协方差矩阵，然后使用 <span class="math notranslate nohighlight">\(\epsilon_{1}\)</span> 和 <span class="math notranslate nohighlight">\(\epsilon_{2}\)</span> 的左上角块来计算。</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Σεjk</span> <span class="o">=</span> <span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">Σy</span> <span class="o">@</span> <span class="n">P</span><span class="p">)[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>

<span class="n">Pjk</span> <span class="o">=</span> <span class="n">P</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span>

<span class="n">Σy_hat</span> <span class="o">=</span> <span class="n">Pjk</span> <span class="o">@</span> <span class="n">Σεjk</span> <span class="o">@</span> <span class="n">Pjk</span><span class="o">.</span><span class="n">T</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Σy_hat = </span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">Σy_hat</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Σy_hat = 
 [[1.05 1.05 1.05 1.05 1.05 0.   0.   0.   0.   0.  ]
 [1.05 1.05 1.05 1.05 1.05 0.   0.   0.   0.   0.  ]
 [1.05 1.05 1.05 1.05 1.05 0.   0.   0.   0.   0.  ]
 [1.05 1.05 1.05 1.05 1.05 0.   0.   0.   0.   0.  ]
 [1.05 1.05 1.05 1.05 1.05 0.   0.   0.   0.   0.  ]
 [0.   0.   0.   0.   0.   1.05 1.05 1.05 1.05 1.05]
 [0.   0.   0.   0.   0.   1.05 1.05 1.05 1.05 1.05]
 [0.   0.   0.   0.   0.   1.05 1.05 1.05 1.05 1.05]
 [0.   0.   0.   0.   0.   1.05 1.05 1.05 1.05 1.05]
 [0.   0.   0.   0.   0.   1.05 1.05 1.05 1.05 1.05]]
</pre></div>
</div>
</div>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                    </div>
                    
                </main> <!-- .page__content -->
                


                <footer class="qe-page__footer">

                    <p><a href="https://creativecommons.org/licenses/by-sa/4.0/"><img src="https://licensebuttons.net/l/by-sa/4.0/80x15.png"></a></p>

                    <p>Creative Commons License &ndash; This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International.</p>

                    <p>A theme by <a href="https://quantecon.org">QuantEcon</a></p>

                </footer> <!-- .page__footer -->

            </div> <!-- .page -->

            

            
            <div class="qe-sidebar bd-sidebar inactive" id="site-navigation">

                <div class="qe-sidebar__header">


                    Contents

                </div>

                <nav class="qe-sidebar__nav" id="qe-sidebar-nav" aria-label="Main navigation">
                    <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  工具与技术
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="sir_model.html">
   1. 新冠病毒建模
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="linear_algebra.html">
   2. 线性代数
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="qr_decomp.html">
   3. QR分解
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="eig_circulant.html">
   4. 循环矩阵
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="svd_intro.html">
   5. 奇异值分解（SVD）
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="var_dmd.html">
   6. 向量自回归和动态模态分解
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="newton_method.html">
   7. 使用牛顿法求解经济模型
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  基础统计学
 </span>
</p>
<ul class="current nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="prob_matrix.html">
   8. 基础概率论与矩阵
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lln_clt.html">
   9. 大数定律 和 中心极限定理
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="prob_meaning.html">
   10. 概率的两种含义
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="multi_hyper.html">
   11. 多元超几何分布
  </a>
 </li>
 <li class="toctree-l1 current active active">
  <a class="current reference internal" href="#">
   12. 多元正态分布
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="hoist_failure.html">
   13. 故障树不确定性
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="back_prop.html">
   14. 人工神经网络简介
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="rand_resp.html">
   15. 随机化回应调查
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="util_rand_resp.html">
   16. Expected Utilities of Random Responses
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  线性规划
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="opt_transport.html">
   17. 最优传输
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="von_neumann_model.html">
   18. 冯·诺依曼增长模型（及其推广）
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  动态系统导论
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="finite_markov.html">
   19. 有限马尔可夫链
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="inventory_dynamics.html">
   20. 库存动态
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="linear_models.html">
   21. 线性状态空间模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="samuelson.html">
   22. 萨缪尔森乘数-加速器模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="kesten_processes.html">
   23. Kesten过程与企业动态
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="wealth_dynamics.html">
   24. 财富分配动态
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="kalman.html">
   25. 卡尔曼滤波初探
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="kalman_2.html">
   26. 卡尔曼滤波器的另一个视角
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  搜索
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="mccall_model.html">
   27. 工作搜寻 I: McCall搜寻模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mccall_model_with_separation.html">
   28. 工作搜寻 II：搜寻与离职
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mccall_fitted_vfi.html">
   29. 求职搜索 III: 拟合值函数迭代
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mccall_correlated.html">
   30. 工作搜寻 IV：相关工资报价
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="career.html">
   31. 职业搜索 V：职业选择建模
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="jv.html">
   32. 在职搜索 VI：在职搜索
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mccall_q.html">
   33. 求职搜索 VII：McCall工人的Q学习
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  消费、储蓄与资本
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="cass_koopmans_1.html">
   34. Cass-Koopmans模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cass_koopmans_2.html">
   35. Cass-Koopmans竞争均衡
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cass_fiscal.html">
   36. 带扭曲性税收的Cass-Koopmans模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ak2.html">
   37. 重叠世代模型中的转换
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cake_eating_problem.html">
   38. 蛋糕食用问题 I：最优储蓄导论
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cake_eating_numerical.html">
   39. 蛋糕食用问题 II：数值方法
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="optgrowth.html">
   40. 最优增长 I：随机最优增长模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="optgrowth_fast.html">
   41. 最优增长 II：使用Numba加速代码
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="coleman_policy_iter.html">
   42. 最优增长 III：时间迭代
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="egm_policy_iter.html">
   43. 最优增长 IV：内生网格法
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ifp.html">
   44. 收入波动问题 I：基本模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ifp_advanced.html">
   45. 收入波动问题 II：资产随机收益
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  贝叶斯定律
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="bayes_nonconj.html">
   46. 非共轭先验
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ar1_bayes.html">
   47. AR(1)参数的后验分布
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ar1_turningpts.html">
   48. 预测 AR(1) 过程
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  信息论
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="odu.html">
   49. 求职搜索 VII: 带学习的搜索
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="likelihood_ratio_process.html">
   50. 似然比过程
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="imp_sample.html">
   51. 计算似然比过程的均值
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="wald_friedman.html">
   52. 让弥尔顿·弗里德曼困惑的问题
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="exchangeable.html">
   53. 可交换性和贝叶斯更新
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="likelihood_bayes.html">
   54. 似然比过程和贝叶斯学习
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mix_model.html">
   55. 错误模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="navy_captain.html">
   56. 贝叶斯与频率主义决策规则的比较
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  LQ控制
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="lqcontrol.html">
   57. LQ控制：基础
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lagrangian_lqdp.html">
   58. LQ控制的拉格朗日方法
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="cross_product_trick.html">
   59. 消除交叉项
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="perm_income.html">
   60. 永久收入模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="perm_income_cons.html">
   61. 永久收入 II：线性二次方法
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lq_inventories.html">
   62. 通过库存实现生产平滑
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  多主体模型
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="lake_model.html">
   63. 就业和失业的湖泊模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="rational_expectations.html">
   64. 理性预期均衡
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="re_with_feedback.html">
   65. 线性理性预期模型中的稳定性
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="markov_perf.html">
   66. 马尔可夫完美均衡
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="uncertainty_traps.html">
   67. 不确定性陷阱
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="aiyagari.html">
   68. 艾亚加里模型
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  资产定价与金融
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="markov_asset.html">
   69. 资产定价：有限状态模型
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ge_arrow.html">
   70. 带有阿罗证券的竞争均衡
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="harrison_kreps.html">
   71. 异质信念与泡沫
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  数据与实证
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="pandas_panel.html">
   72. 面板数据的Pandas使用
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ols.html">
   73. Python线性回归
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mle.html">
   74. 最大似然估计
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  拍卖
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="two_auctions.html">
   75. 一价和二价拍卖
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="house_auction.html">
   76. 多种商品分配机制
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  其他
 </span>
</p>
<ul class="nav bd-sidenav nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="troubleshooting.html">
   77. 故障排除
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="zreferences.html">
   78. 参考文献
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="status.html">
   79. 执行统计
  </a>
 </li>
</ul>

                </nav>

                <div class="qe-sidebar__footer">

                </div>

            </div> <!-- .sidebar -->
            
        </div> <!-- .main -->

        <div class="qe-toolbar">

            <div class="qe-toolbar__inner">

                <ul class="qe-toolbar__main">
                    <li data-tippy-content="Table of Contents" class="btn__sidebar"><i data-feather="menu"></i></li>
                    <li data-tippy-content="Home"><a href="intro.html"><i data-feather="home"></i></a></li>
                    <li class="btn__qelogo"><a href="https://quantecon.org" title=""><span class="show-for-sr">QuantEcon</span></a></li>
                </ul>

                <ul class="qe-toolbar__links">
                    <li class="btn__search">
                        <form action="search.html" method="get">
                            <input type="search" class="form-control" name="q" id="search-input" placeholder="Search..." aria-label="Search..." autocomplete="off" accesskey="k">
                            <i data-feather="search" id="search-icon"></i>
                        </form>
                    </li>
                    <li data-tippy-content="Fullscreen" class="btn__fullscreen"><i data-feather="maximize"></i></li>
                    <li data-tippy-content="Increase font size" class="btn__plus"><i data-feather="plus-circle"></i></li>
                    <li data-tippy-content="Decrease font size" class="btn__minus"><i data-feather="minus-circle"></i></li>
                    <li data-tippy-content="Change contrast" class="btn__contrast"><i data-feather="sunset"></i></li>
                    <li data-tippy-content="Download Notebook"><a href="/_notebooks/multivariate_normal.ipynb" download><i data-feather="download-cloud"></i></a></li>
                    <li class="settings-button" id="settingsButton"><div data-tippy-content="Launch Notebook"><i data-feather="play-circle"></i></div></li>
                        <li data-tippy-content="Download PDF" onClick="window.print()"><i data-feather="file"></i></li>
                    <!--
                    # Enable if looking for link to specific document hosted on GitHub
                    <li data-tippy-content="View Source"><a target="_blank" href="https://github.com/QuantEcon/lecture-python.myst/multivariate_normal.md" download><i data-feather="github"></i></a></li>
                    -->
                    <li data-tippy-content="View Source"><a target="_blank" href="https://github.com/QuantEcon/lecture-python.myst" download><i data-feather="github"></i></a></li>
                </ul>

            </div>

        </div> <!-- .toolbar -->
        <div id="downloadPDFModal" style="display: none;">
            <ul class="pdf-options" style="display: block;">
                <li class="download-pdf-book" onClick="window.print()">
                    <p>Lecture (PDF)</p>
                </li>
                <li class="download-pdf-file">
                    <a href="" download><p>Book (PDF)</p></a>
                </li>
            </ul>
        </div>
        <div id="settingsModal" style="display: none;">
            <p class="modal-title"> Notebook Launcher </p>
            <div class="modal-desc">
            <p>
                Choose public or private cloud service for "Launch" button.
            </p>
            </div>
            <p class="modal-subtitle">Select a server</p>
            <ul class="modal-servers">
            <li class="active launcher-public">
                <span class="label">Public</span>
                <select id="launcher-public-input">
                
                    <option value="https://colab.research.google.com/github/QuantEcon/lecture-python.zh-cn.notebooks/blob/main/multivariate_normal.ipynb">Colab</option>
                
                </select>
                <i class="fas fa-check-circle"></i>
            </li>
            <li class="launcher-private">
                <span class="label">Private</span>
                <input type="text" id="launcher-private-input" data-repourl="https://github.com/QuantEcon/lecture-python.zh-cn.notebooks" data-urlpath="tree/lecture-python.zh-cn.notebooks/multivariate_normal.ipynb" data-branch=main>
                <i class="fas fa-check-circle"></i>
            </li>
            </ul>
            <p class="launch"><a href="https://colab.research.google.com/github/QuantEcon/lecture-python.zh-cn.notebooks/blob/main/multivariate_normal.ipynb" id="advancedLaunchButton" target="_blank">Launch Notebook</a></p>
            <script>
                // QuantEcon Notebook Launcher
                const launcherTypeElements = document.querySelectorAll('#settingsModal .modal-servers li');
                // Highlight the server type if previous selection exists
                if (typeof localStorage.launcherType !== 'undefined') {
                  for (var i = 0; i < launcherTypeElements.length; i++) {
                    launcherTypeElements[i].classList.remove('active');
                    if ( launcherTypeElements[i].classList.contains(localStorage.launcherType) ) {
                      launcherTypeElements[i].classList.add('active');
                    }
                  }
                }
                // Highlight server type on click and set local storage value
                for (var i = 0; i < launcherTypeElements.length; i++) {
                  launcherTypeElements[i].addEventListener('click', function() {
                    for (var j = 0; j < launcherTypeElements.length; j++) {
                      launcherTypeElements[j].classList.remove('active');
                    }
                    this.classList.add('active');
                    if ( this.classList.contains('launcher-private') ) {
                      localStorage.launcherType = 'launcher-private';
                    } else if ( this.classList.contains('launcher-public') ) {
                      localStorage.launcherType = 'launcher-public';
                    }
                    setLaunchServer();
                  })
                }
                const launcherPublic = document.getElementById('launcher-public-input');
                const launcherPrivate = document.getElementById('launcher-private-input');
                const pageName = "multivariate_normal";
                const repoURL = "https://github.com/QuantEcon/lecture-python.zh-cn.notebooks";
                const urlPath = "tree/lecture-python.zh-cn.notebooks/multivariate_normal.ipynb";
                const branch = "main"
                const launchNotebookLink = document.getElementById('advancedLaunchButton');

                // Highlight public server option if previous selection exists
                if (typeof localStorage.launcherPublic !== 'undefined') {
                  launcherPublic.value = localStorage.launcherPublic;
                }
                // Update local storage upon public server selection
                launcherPublic.addEventListener('change', (event) => {
                  setLaunchServer();
                });
                // Populate private server input if previous entry exists
                if (typeof localStorage.launcherPrivate !== 'undefined') {
                  launcherPrivate.value = localStorage.launcherPrivate;
                }
                // Update local storage when a private server is entered
                launcherPrivate.addEventListener('input', (event) => {
                  setLaunchServer();
                });

                // Function to update the "Launch Notebook" link href
                function setLaunchServer() {
                  launchNotebookLink.removeAttribute("style")
                  if ( localStorage.launcherType == 'launcher-private' ) {
                    let repoPrefix = "/user-redirect/git-pull?repo=" + repoURL + "&branch=" + branch + "&urlpath=" + urlPath;
                    launcherPrivateValue = launcherPrivate.value
                    if (!launcherPrivateValue) {
                        launchNotebookLink.removeAttribute("href")
                        launchNotebookLink.style.background = "grey"
                        return
                    }
                    localStorage.launcherPrivate = launcherPrivateValue;
                    privateServer = localStorage.launcherPrivate.replace(/\/$/, "")
                    if (!privateServer.includes("http")) {
                        privateServer = "http://" + privateServer
                    }
                    launchNotebookLinkURL = privateServer + repoPrefix;
                  } else if ( localStorage.launcherType == 'launcher-public' ) {
                    launcherPublicValue = launcherPublic.options[launcherPublic.selectedIndex].value;
                    localStorage.launcherPublic = launcherPublicValue;
                    launchNotebookLinkURL = localStorage.launcherPublic;
                  }
                  if (launchNotebookLinkURL) launchNotebookLink.href = launchNotebookLinkURL;
                }
                // Check if user has previously selected a server
                if ( (typeof localStorage.launcherPrivate !== 'undefined') || (typeof localStorage.launcherPublic !== 'undefined') ) {
                  setLaunchServer();
                }
                </script>

        </div>

    </div> <!-- .wrapper-->
  </body>
</html>